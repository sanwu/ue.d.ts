declare type UClass = any;
declare function gc() : void;
declare type UnrealEngineClass = any;
declare type timeout_handle = any;
declare function setTimeout(fn : (milliseconds: number) => void, timeout : number) : timeout_handle;
declare function clearTimeout(handle : timeout_handle) : void;
declare class UnrealEngineMulticastDelegate<T> {
	Add(fn : T): void;
	Remove(fn : T): void;
}

declare class UnrealEngineDelegate<T> {
	Add(fn : T): void;
	Remove(fn : T): void;
}

declare class Process {
	nextTick(fn : (number) => void): void;
}

declare var process : Process;

declare class Memory {
	bind(ab : ArrayBuffer): void;
	unbind(): void;
}

declare var memory : Memory;

declare class Package extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Package;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Package;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Package;
	static C(Other: UObject): Package;
}

declare class Interface extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Interface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Interface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Interface;
	static C(Other: UObject): Interface;
}

declare class TimerHandle { 
}

declare class CollisionProfileName { 
	Name: string;
}

declare class LinearColor { 
	R: number;
	G: number;
	B: number;
	A: number;
}

declare class Rotator { 
	Pitch: number;
	Yaw: number;
	Roll: number;
}

declare class GenericStruct { 
	Data: number;
}

declare class Quat { 
	X: number;
	Y: number;
	Z: number;
	W: number;
}

declare class Vector { 
	X: number;
	Y: number;
	Z: number;
}

declare class Transform { 
	Rotation: Quat;
	Translation: Vector;
	Scale3D: Vector;
}

declare class UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UObject;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UObject;
	static C(Other: UObject): UObject;
	CreatePackage(PackageName: string): Package;
	GetName(): string;
	GetOuter(): UObject;
	GetOutermost(): UObject;
	Conv_AssetToObject(): UObject;
	CreateCopyForUndoBuffer(): void;
	DoesImplementInterface(Interface: UnrealEngineClass): boolean;
	GetDisplayName(): string;
	GetObjectName(): string;
	IsValid(): boolean;
	ClearTimerbyFunctionName(FunctionName: string): void;
	GetTimerElapsedTimebyFunctionName(FunctionName: string): number;
	GetTimerRemainingTimebyFunctionName(FunctionName: string): number;
	IsTimerActivebyFunctionName(FunctionName: string): boolean;
	IsTimerPausedbyFunctionName(FunctionName: string): boolean;
	PauseTimerbyFunctionName(FunctionName: string): void;
	SetTimerbyFunctionName(FunctionName: string,Time: number,bLooping: boolean): TimerHandle;
	DoesTimerExistbyFunctionName(FunctionName: string): boolean;
	UnpauseTimerbyFunctionName(FunctionName: string): void;
	SetAssetClassPropertyByName(PropertyName: string,Value: any): void;
	SetAssetPropertyByName(PropertyName: string,Value: any): void;
	SetBoolPropertyByName(PropertyName: string,Value: boolean): void;
	SetBytePropertyByName(PropertyName: string,Value: number): void;
	SetClassPropertyByName(PropertyName: string,Value: UnrealEngineClass): void;
	SetCollisionProfileNameProperty(PropertyName: string,Value: CollisionProfileName): void;
	SetFloatPropertyByName(PropertyName: string,Value: number): void;
	SetIntPropertyByName(PropertyName: string,Value: number): void;
	SetLinearColorPropertyByName(PropertyName: string,Value: LinearColor): void;
	SetNamePropertyByName(PropertyName: string,Value: string): void;
	SetObjectPropertyByName(PropertyName: string,Value: UObject): void;
	SetRotatorPropertyByName(PropertyName: string,Value: Rotator): void;
	SetStringPropertyByName(PropertyName: string,Value: string): void;
	SetStructurePropertyByName(PropertyName: string,Value: GenericStruct): void;
	SetTextPropertyByName(PropertyName: string,Value: string): void;
	SetTransformPropertyByName(PropertyName: string,Value: Transform): void;
	SetVectorPropertyByName(PropertyName: string,Value: Vector): void;
	ToString(): string;
	Equal(B: UObject): boolean;
	NotEqual(B: UObject): boolean;
	SelectObject(B: UObject,bSelectA: boolean): UObject;
	SetArrayPropertyByName(PropertyName: string,Value: number[]): void;
	GetClass(): UnrealEngineClass;
	ExecuteUbergraph(EntryPoint: number): void;
}

declare class GCObjectReferencer extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GCObjectReferencer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GCObjectReferencer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GCObjectReferencer;
	static C(Other: UObject): GCObjectReferencer;
}

declare class TextBuffer extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextBuffer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextBuffer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBuffer;
	static C(Other: UObject): TextBuffer;
}

declare class Field extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Field;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Field;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Field;
	static C(Other: UObject): Field;
}

declare class Struct extends Field { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Struct;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Struct;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Struct;
	static C(Other: UObject): Struct;
}

declare class ScriptStruct extends Struct { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ScriptStruct;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ScriptStruct;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScriptStruct;
	static C(Other: UObject): ScriptStruct;
}

declare class DynamicBlueprintBinding extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DynamicBlueprintBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DynamicBlueprintBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicBlueprintBinding;
	static C(Other: UObject): DynamicBlueprintBinding;
}

declare class SaveGame extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SaveGame;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SaveGame;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SaveGame;
	static C(Other: UObject): SaveGame;
	SaveGameToSlot(SlotName: string,UserIndex: number): boolean;
}

declare class Visual extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Visual;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Visual;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Visual;
	static C(Other: UObject): Visual;
}

declare class PanelWidget extends Widget { 
	Slots: PanelSlot[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PanelWidget;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PanelWidget;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PanelWidget;
	static C(Other: UObject): PanelWidget;
	RemoveChildAt(Index: number): boolean;
	RemoveChild(Content: Widget): boolean;
	HasChild(Content: Widget): boolean;
	HasAnyChildren(): boolean;
	GetChildrenCount(): number;
	GetChildIndex(Content: Widget): number;
	GetChildAt(Index: number): Widget;
	ClearChildren(): void;
	AddChild(Content: Widget): PanelSlot;
}

declare class PanelSlot extends Visual { 
	Parent: PanelWidget;
	Content: Widget;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PanelSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PanelSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PanelSlot;
	static C(Other: UObject): PanelSlot;
}

declare type ESlateVisibility = string;
declare type EMouseCursor = string;
declare class Vector2D { 
	X: number;
	Y: number;
}

declare class WidgetTransform { 
	Translation: Vector2D;
	Scale: Vector2D;
	Shear: Vector2D;
	Angle: number;
}

declare type EUINavigationRule = string;
declare class WidgetNavigationData { 
	Rule: EUINavigationRule;
	WidgetToFocus: string;
}

declare class WidgetNavigation extends UObject { 
	Up: WidgetNavigationData;
	Down: WidgetNavigationData;
	Left: WidgetNavigationData;
	Right: WidgetNavigationData;
	Next: WidgetNavigationData;
	Previous: WidgetNavigationData;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WidgetNavigation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WidgetNavigation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetNavigation;
	static C(Other: UObject): WidgetNavigation;
}

declare class PropertyPathSegment { 
	Name: string;
	ArrayIndex: number;
	Struct: Struct;
	Field: Field;
}

declare class DynamicPropertyPath { 
	Segments: PropertyPathSegment[];
}

declare class PropertyBinding extends UObject { 
	SourceObject: any;
	SourcePath: DynamicPropertyPath;
	DestinationProperty: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PropertyBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PropertyBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyBinding;
	static C(Other: UObject): PropertyBinding;
}

declare type EWidgetDesignFlags = string;
declare class Margin { 
	Left: number;
	Top: number;
	Right: number;
	Bottom: number;
}

declare class Anchors { 
	Minimum: Vector2D;
	Maximum: Vector2D;
}

declare class AnchorData { 
	Offsets: Margin;
	Anchors: Anchors;
	Alignment: Vector2D;
}

declare class CanvasPanelSlot extends PanelSlot { 
	LayoutData: AnchorData;
	bAutoSize: boolean;
	ZOrder: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CanvasPanelSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CanvasPanelSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CanvasPanelSlot;
	static C(Other: UObject): CanvasPanelSlot;
	SetZOrder(InZOrder: number): void;
	SetSize(InSize: Vector2D): void;
	SetPosition(InPosition: Vector2D): void;
	SetOffsets(InOffset: Margin): void;
	SetMinimum(InMinimumAnchors: Vector2D): void;
	SetMaximum(InMaximumAnchors: Vector2D): void;
	SetLayout(InLayoutData: AnchorData): void;
	SetAutoSize(InbAutoSize: boolean): void;
	SetAnchors(InAnchors: Anchors): void;
	SetAlignment(InAlignment: Vector2D): void;
	GetZOrder(): number;
	GetSize(): Vector2D;
	GetPosition(): Vector2D;
	GetOffsets(): Margin;
	GetLayout(): AnchorData;
	GetAutoSize(): boolean;
	GetAnchors(): Anchors;
	GetAlignment(): Vector2D;
}

declare type EHorizontalAlignment = string;
declare type EVerticalAlignment = string;
declare class GridSlot extends PanelSlot { 
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	Row: number;
	RowSpan: number;
	Column: number;
	ColumnSpan: number;
	Layer: number;
	Nudge: Vector2D;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GridSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GridSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GridSlot;
	static C(Other: UObject): GridSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetRowSpan(InRowSpan: number): void;
	SetRow(InRow: number): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	SetColumnSpan(InColumnSpan: number): void;
	SetColumn(InColumn: number): void;
}

declare type ESlateSizeRule = string;
declare class SlateChildSize { 
	Value: number;
	SizeRule: ESlateSizeRule;
}

declare class HorizontalBoxSlot extends PanelSlot { 
	Padding: Margin;
	Size: SlateChildSize;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): HorizontalBoxSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): HorizontalBoxSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HorizontalBoxSlot;
	static C(Other: UObject): HorizontalBoxSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetSize(InSize: SlateChildSize): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
}

declare class OverlaySlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): OverlaySlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): OverlaySlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OverlaySlot;
	static C(Other: UObject): OverlaySlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
}

declare class UniformGridSlot extends PanelSlot { 
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	Row: number;
	Column: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UniformGridSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UniformGridSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformGridSlot;
	static C(Other: UObject): UniformGridSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetRow(InRow: number): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	SetColumn(InColumn: number): void;
}

declare class VerticalBoxSlot extends PanelSlot { 
	Padding: Margin;
	Size: SlateChildSize;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VerticalBoxSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VerticalBoxSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VerticalBoxSlot;
	static C(Other: UObject): VerticalBoxSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetSize(InSize: SlateChildSize): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
}

declare type ETickingGroup = string;
declare class TickFunction { 
	TickGroup: ETickingGroup;
	bTickEvenWhenPaused: boolean;
	bCanEverTick: boolean;
	bStartWithTickEnabled: boolean;
	bAllowTickOnDedicatedServer: boolean;
	TickInterval: number;
}

declare class ActorTickFunction extends TickFunction { 
}

declare type ENetRole = string;
declare type EVectorQuantization = string;
declare type ERotatorQuantization = string;
declare class RepMovement { 
	LinearVelocity: Vector;
	AngularVelocity: Vector;
	Location: Vector;
	Rotation: Rotator;
	bSimulatedPhysicSleep: boolean;
	bRepPhysics: boolean;
	LocationQuantizationLevel: EVectorQuantization;
	VelocityQuantizationLevel: EVectorQuantization;
	RotationQuantizationLevel: ERotatorQuantization;
}

declare class Vector_NetQuantize100 extends Vector { 
}

declare class ActorComponentTickFunction extends TickFunction { 
}

declare class AssetUserData extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AssetUserData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AssetUserData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetUserData;
	static C(Other: UObject): AssetUserData;
}

declare type EComponentCreationMethod = string;
declare class Guid { 
	A: number;
	B: number;
	C: number;
	D: number;
}

declare class SimpleMemberReference { 
	MemberParent: UObject;
	MemberName: string;
	MemberGuid: Guid;
}

declare type EEndPlayReason = string;
declare class ActorComponent extends UObject { 
	PrimaryComponentTick: ActorComponentTickFunction;
	ComponentTags: string[];
	AssetUserData: AssetUserData[];
	bReplicates: boolean;
	bNetAddressable: boolean;
	bCreatedByConstructionScript: boolean;
	bInstanceComponent: boolean;
	bAutoActivate: boolean;
	bIsActive: boolean;
	bEditableWhenInherited: boolean;
	bWantsBeginPlay: boolean;
	CreationMethod: EComponentCreationMethod;
	UCSModifiedProperties: SimpleMemberReference[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorComponent;
	static C(Other: UObject): ActorComponent;
	ToggleActive(): void;
	SetTickGroup(NewTickGroup: ETickingGroup): void;
	SetTickableWhenPaused(bTickableWhenPaused: boolean): void;
	SetIsReplicated(ShouldReplicate: boolean): void;
	SetComponentTickEnabled(bEnabled: boolean): void;
	SetActive(bNewActive: boolean,bReset: boolean): void;
	RemoveTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	RemoveTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	Tick(DeltaSeconds: number): void;
	EndPlay(EndPlayReason: EEndPlayReason): void;
	BeginPlay(): void;
	OnRep_IsActive(): void;
	DestroyComponent(UObject: UObject): void;
	IsComponentTickEnabled(): boolean;
	IsComponentBeingDestroyed(): boolean;
	IsActive(): boolean;
	GetOwner(): Actor;
	Deactivate(): void;
	ComponentHasTag(Tag: string): boolean;
	AddTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	AddTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	Activate(bReset: boolean): void;
}

declare type EComponentMobility = string;
declare type EDetailMode = string;
declare type EBrushType = string;
declare class Color { 
	B: number;
	G: number;
	R: number;
	A: number;
}

declare class Model extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Model;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Model;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Model;
	static C(Other: UObject): Model;
}

declare type ESceneDepthPriorityGroup = string;
declare type EIndirectLightingCacheQuality = string;
declare type ECollisionResponse = string;
declare class CollisionResponseContainer { 
	WorldStatic: ECollisionResponse;
	WorldDynamic: ECollisionResponse;
	Pawn: ECollisionResponse;
	Visibility: ECollisionResponse;
	Camera: ECollisionResponse;
	PhysicsBody: ECollisionResponse;
	Vehicle: ECollisionResponse;
	Destructible: ECollisionResponse;
	EngineTraceChannel1: ECollisionResponse;
	EngineTraceChannel2: ECollisionResponse;
	EngineTraceChannel3: ECollisionResponse;
	EngineTraceChannel4: ECollisionResponse;
	EngineTraceChannel5: ECollisionResponse;
	EngineTraceChannel6: ECollisionResponse;
	GameTraceChannel1: ECollisionResponse;
	GameTraceChannel2: ECollisionResponse;
	GameTraceChannel3: ECollisionResponse;
	GameTraceChannel4: ECollisionResponse;
	GameTraceChannel5: ECollisionResponse;
	GameTraceChannel6: ECollisionResponse;
	GameTraceChannel7: ECollisionResponse;
	GameTraceChannel8: ECollisionResponse;
	GameTraceChannel9: ECollisionResponse;
	GameTraceChannel10: ECollisionResponse;
	GameTraceChannel11: ECollisionResponse;
	GameTraceChannel12: ECollisionResponse;
	GameTraceChannel13: ECollisionResponse;
	GameTraceChannel14: ECollisionResponse;
	GameTraceChannel15: ECollisionResponse;
	GameTraceChannel16: ECollisionResponse;
	GameTraceChannel17: ECollisionResponse;
	GameTraceChannel18: ECollisionResponse;
}

declare class ResponseChannel { 
	Channel: string;
	Response: ECollisionResponse;
}

declare class CollisionResponse { 
	ResponseToChannels: CollisionResponseContainer;
	ResponseArray: ResponseChannel[];
}

declare type EWalkableSlopeBehavior = string;
declare class WalkableSlopeOverride { 
	WalkableSlopeBehavior: EWalkableSlopeBehavior;
	WalkableSlopeAngle: number;
}

declare type EFrictionCombineMode = string;
declare class PhysicalMaterialPropertyBase extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PhysicalMaterialPropertyBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PhysicalMaterialPropertyBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicalMaterialPropertyBase;
	static C(Other: UObject): PhysicalMaterialPropertyBase;
}

declare type EPhysicalSurface = string;
declare class DataAsset extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DataAsset;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DataAsset;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataAsset;
	static C(Other: UObject): DataAsset;
}

declare class TireType extends DataAsset { 
	FrictionScale: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TireType;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TireType;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TireType;
	static C(Other: UObject): TireType;
}

declare class TireFrictionScalePair { 
	TireType: TireType;
	FrictionScale: number;
}

declare class PhysicalMaterial extends UObject { 
	Friction: number;
	FrictionCombineMode: EFrictionCombineMode;
	bOverrideFrictionCombineMode: boolean;
	Restitution: number;
	RestitutionCombineMode: EFrictionCombineMode;
	bOverrideRestitutionCombineMode: boolean;
	Density: number;
	RaiseMassToPower: number;
	DestructibleDamageThresholdScale: number;
	PhysicalMaterialProperty: PhysicalMaterialPropertyBase;
	SurfaceType: EPhysicalSurface;
	TireFrictionScale: number;
	TireFrictionScales: TireFrictionScalePair[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PhysicalMaterial;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PhysicalMaterial;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicalMaterial;
	static C(Other: UObject): PhysicalMaterial;
}

declare type ESleepFamily = string;
declare type EDOFMode = string;
declare type ECollisionEnabled = string;
declare type ECollisionChannel = string;
declare class BodyInstance { 
	Scale3D: Vector;
	ResponseToChannels: CollisionResponseContainer;
	CollisionProfileName: string;
	CollisionResponses: CollisionResponse;
	bUseCCD: boolean;
	bNotifyRigidBodyCollision: boolean;
	bSimulatePhysics: boolean;
	bOverrideMass: boolean;
	bEnableGravity: boolean;
	bAutoWeld: boolean;
	bStartAwake: boolean;
	bGenerateWakeEvents: boolean;
	bUpdateMassWhenScaleChanges: boolean;
	bLockTranslation: boolean;
	bLockRotation: boolean;
	bLockXTranslation: boolean;
	bLockYTranslation: boolean;
	bLockZTranslation: boolean;
	bLockXRotation: boolean;
	bLockYRotation: boolean;
	bLockZRotation: boolean;
	bOverrideMaxAngularVelocity: boolean;
	bUseAsyncScene: boolean;
	bOverrideMaxDepenetrationVelocity: boolean;
	bOverrideWalkableSlopeOnInstance: boolean;
	MaxDepenetrationVelocity: number;
	MassInKg: number;
	LinearDamping: number;
	AngularDamping: number;
	CustomDOFPlaneNormal: Vector;
	COMNudge: Vector;
	MassScale: number;
	WalkableSlopeOverride: WalkableSlopeOverride;
	PhysMaterialOverride: PhysicalMaterial;
	MaxAngularVelocity: number;
	CustomSleepThresholdMultiplier: number;
	PhysicsBlendWeight: number;
	PositionSolverIterationCount: number;
	RigidActorSyncId: any;
	RigidActorAsyncId: any;
	VelocitySolverIterationCount: number;
	SleepFamily: ESleepFamily;
	DOFMode: EDOFMode;
	CollisionEnabled: ECollisionEnabled;
	ObjectType: ECollisionChannel;
}

declare type EHasCustomNavigableGeometry = string;
declare type ECanBeCharacterBase = string;
declare class Vector_NetQuantize extends Vector { 
}

declare class Vector_NetQuantizeNormal extends Vector { 
}

declare class HitResult { 
	bBlockingHit: boolean;
	bStartPenetrating: boolean;
	Time: number;
	Distance: number;
	Location: Vector_NetQuantize;
	ImpactPoint: Vector_NetQuantize;
	Normal: Vector_NetQuantizeNormal;
	ImpactNormal: Vector_NetQuantizeNormal;
	TraceStart: Vector_NetQuantize;
	TraceEnd: Vector_NetQuantize;
	PenetrationDepth: number;
	Item: number;
	PhysMaterial: any;
	Actor: any;
	Component: any;
	BoneName: string;
	FaceIndex: number;
}

declare type ETouchIndex = string;
declare class PrimitiveComponentPostPhysicsTickFunction extends TickFunction { 
}

declare type EOverlapFilterOption = string;
declare type EObjectTypeQuery = string;
declare class SubsurfaceProfileStruct { 
	ScatterRadius: number;
	SubsurfaceColor: LinearColor;
	FalloffColor: LinearColor;
}

declare class SubsurfaceProfile extends UObject { 
	Settings: SubsurfaceProfileStruct;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SubsurfaceProfile;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SubsurfaceProfile;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubsurfaceProfile;
	static C(Other: UObject): SubsurfaceProfile;
}

declare class LightmassMaterialInterfaceSettings { 
	bCastShadowAsMasked: boolean;
	EmissiveBoost: number;
	DiffuseBoost: number;
	ExportResolutionScale: number;
	bOverrideCastShadowAsMasked: boolean;
	bOverrideEmissiveBoost: boolean;
	bOverrideDiffuseBoost: boolean;
	bOverrideExportResolutionScale: boolean;
}

declare class StringAssetReference { 
	AssetLongPathname: string;
}

declare class ThumbnailInfo extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ThumbnailInfo;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ThumbnailInfo;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ThumbnailInfo;
	static C(Other: UObject): ThumbnailInfo;
}

declare type EAttachLocation = string;
declare type EFontCacheType = string;
declare class FontCharacter { 
	StartU: number;
	StartV: number;
	USize: number;
	VSize: number;
	TextureIndex: number;
	VerticalOffset: number;
}

declare type ETextureSourceFormat = string;
declare class TextureSource { 
	Id: Guid;
	SizeX: number;
	SizeY: number;
	NumSlices: number;
	NumMips: number;
	bPNGCompressed: boolean;
	bGuidIsHash: boolean;
	Format: ETextureSourceFormat;
}

declare class AssetImportInfo { 
}

declare class AssetImportData extends UObject { 
	SourceFilePath: string;
	SourceFileTimestamp: string;
	SourceData: AssetImportInfo;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AssetImportData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AssetImportData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetImportData;
	static C(Other: UObject): AssetImportData;
}

declare type ETexturePowerOfTwoSetting = string;
declare type TextureMipGenSettings = string;
declare type ECompositeTextureMode = string;
declare type TextureCompressionSettings = string;
declare type TextureFilter = string;
declare type TextureGroup = string;
declare class Texture extends UObject { 
	Source: TextureSource;
	LightingGuid: Guid;
	SourceFilePath: string;
	AssetImportData: AssetImportData;
	AdjustBrightness: number;
	AdjustBrightnessCurve: number;
	AdjustVibrance: number;
	AdjustSaturation: number;
	AdjustRGBCurve: number;
	AdjustHue: number;
	AdjustMinAlpha: number;
	AdjustMaxAlpha: number;
	CompressionNoAlpha: boolean;
	CompressionNone: boolean;
	DeferCompression: boolean;
	MaxTextureSize: number;
	bDitherMipMapAlpha: boolean;
	bPreserveBorder: boolean;
	bFlipGreenChannel: boolean;
	bForcePVRTC4: boolean;
	PowerOfTwoMode: ETexturePowerOfTwoSetting;
	PaddingColor: Color;
	bChromaKeyTexture: boolean;
	ChromaKeyThreshold: number;
	ChromaKeyColor: Color;
	MipGenSettings: TextureMipGenSettings;
	CompositeTexture: Texture;
	CompositeTextureMode: ECompositeTextureMode;
	CompositePower: number;
	LODBias: number;
	NumCinematicMipLevels: number;
	SRGB: boolean;
	bUseLegacyGamma: boolean;
	NeverStream: boolean;
	bNoTiling: boolean;
	bUseCinematicMipLevels: boolean;
	CachedCombinedLODBias: number;
	bAsyncResourceReleaseHasBeenStarted: boolean;
	CompressionSettings: TextureCompressionSettings;
	Filter: TextureFilter;
	LODGroup: TextureGroup;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Texture;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Texture;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Texture;
	static C(Other: UObject): Texture;
}

declare class IntPoint { 
	X: number;
	Y: number;
}

declare type TextureAddress = string;
declare type ESlateBrushDrawType = string;
declare type ESlateColorStylingMode = string;
declare class SlateColor { 
	SpecifiedColor: LinearColor;
	ColorUseRule: ESlateColorStylingMode;
}

declare type ESlateBrushTileType = string;
declare type ESlateBrushMirrorType = string;
declare type ESlateBrushImageType = string;
declare class Box2D { 
	Min: Vector2D;
	Max: Vector2D;
	IsValid: number;
}

declare class SlateBrush { 
	ImageSize: Vector2D;
	DrawAs: ESlateBrushDrawType;
	Margin: Margin;
	Tint: LinearColor;
	TintColor: SlateColor;
	Tiling: ESlateBrushTileType;
	Mirroring: ESlateBrushMirrorType;
	ImageType: ESlateBrushImageType;
	ResourceObject: UObject;
	ResourceName: string;
	bIsDynamicallyLoaded: boolean;
	bHasUObject: boolean;
	UVRegion: Box2D;
}

declare class Texture2D extends Texture { 
	RequestedMips: number;
	ResidentMips: number;
	StreamingIndex: number;
	FirstResourceMemMip: number;
	ImportedSize: IntPoint;
	ForceMipLevelsToBeResidentTimestamp: number;
	bTemporarilyDisableStreaming: boolean;
	bIsStreamable: boolean;
	bHasCancelationPending: boolean;
	bForceMiplevelsToBeResident: boolean;
	bGlobalForceMipLevelsToBeResident: boolean;
	bHasBeenPaintedInEditor: boolean;
	AddressX: TextureAddress;
	AddressY: TextureAddress;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Texture2D;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Texture2D;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Texture2D;
	static C(Other: UObject): Texture2D;
	MakeBrushFromTexture(Width: number,Height: number): SlateBrush;
	GetSizeY(): number;
	GetSizeX(): number;
}

declare type EFontImportCharacterSet = string;
declare class FontImportOptionsData { 
	FontName: string;
	Height: number;
	bEnableAntialiasing: boolean;
	bEnableBold: boolean;
	bEnableItalic: boolean;
	bEnableUnderline: boolean;
	bAlphaOnly: boolean;
	CharacterSet: EFontImportCharacterSet;
	Chars: string;
	UnicodeRange: string;
	CharsFilePath: string;
	CharsFileWildcard: string;
	bCreatePrintableOnly: boolean;
	bIncludeASCIIRange: boolean;
	ForegroundColor: LinearColor;
	bEnableDropShadow: boolean;
	TexturePageWidth: number;
	TexturePageMaxHeight: number;
	XPadding: number;
	YPadding: number;
	ExtendBoxTop: number;
	ExtendBoxBottom: number;
	ExtendBoxRight: number;
	ExtendBoxLeft: number;
	bEnableLegacyMode: boolean;
	Kerning: number;
	bUseDistanceFieldAlpha: boolean;
	DistanceFieldScaleFactor: number;
	DistanceFieldScanRadiusScale: number;
}

declare class FontBulkData extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FontBulkData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FontBulkData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontBulkData;
	static C(Other: UObject): FontBulkData;
}

declare type EFontHinting = string;
declare class FontData { 
	FontFilename: string;
	BulkDataPtr: FontBulkData;
	Hinting: EFontHinting;
	FontData: number[];
}

declare class TypefaceEntry { 
	Name: string;
	Font: FontData;
}

declare class Typeface { 
	Fonts: TypefaceEntry[];
}

declare type ERangeBoundTypes = string;
declare class Int32RangeBound { 
	Type: ERangeBoundTypes;
	Value: number;
}

declare class Int32Range { 
	LowerBound: Int32RangeBound;
	UpperBound: Int32RangeBound;
}

declare class CompositeSubFont { 
	Typeface: Typeface;
	CharacterRanges: Int32Range[];
	ScalingFactor: number;
	EditorName: string;
}

declare class CompositeFont { 
	DefaultTypeface: Typeface;
	SubTypefaces: CompositeSubFont[];
}

declare class Font extends UObject { 
	FontCacheType: EFontCacheType;
	Characters: FontCharacter[];
	Textures: Texture2D[];
	IsRemapped: number;
	EmScale: number;
	Ascent: number;
	Descent: number;
	Leading: number;
	Kerning: number;
	ImportOptions: FontImportOptionsData;
	NumCharacters: number;
	MaxCharHeight: number[];
	ScalingFactor: number;
	LegacyFontSize: number;
	LegacyFontName: string;
	CompositeFont: CompositeFont;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Font;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Font;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Font;
	static C(Other: UObject): Font;
}

declare class FontParameterValue { 
	ParameterName: string;
	FontValue: Font;
	FontPage: number;
	ExpressionGUID: Guid;
}

declare class ScalarParameterValue { 
	ParameterName: string;
	ParameterValue: number;
	ExpressionGUID: Guid;
}

declare class TextureParameterValue { 
	ParameterName: string;
	ParameterValue: Texture;
	ExpressionGUID: Guid;
}

declare class VectorParameterValue { 
	ParameterName: string;
	ParameterValue: LinearColor;
	ExpressionGUID: Guid;
}

declare type EBlendMode = string;
declare type EMaterialShadingModel = string;
declare class MaterialInstanceBasePropertyOverrides { 
	bOverride_OpacityMaskClipValue: boolean;
	bOverride_BlendMode: boolean;
	bOverride_ShadingModel: boolean;
	bOverride_DitheredLODTransition: boolean;
	bOverride_TwoSided: boolean;
	OpacityMaskClipValue: number;
	BlendMode: EBlendMode;
	ShadingModel: EMaterialShadingModel;
	TwoSided: boolean;
	DitheredLODTransition: boolean;
}

declare class MaterialInstance extends MaterialInterface { 
	PhysMaterial: PhysicalMaterial;
	Parent: MaterialInterface;
	bHasStaticPermutationResource: boolean;
	bOverrideSubsurfaceProfile: boolean;
	ParentLightingGuid: Guid;
	FontParameterValues: FontParameterValue[];
	ScalarParameterValues: ScalarParameterValue[];
	TextureParameterValues: TextureParameterValue[];
	VectorParameterValues: VectorParameterValue[];
	bOverrideBaseProperties: boolean;
	BasePropertyOverrides: MaterialInstanceBasePropertyOverrides;
	ReferencedTextureGuids: Guid[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialInstance;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialInstance;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstance;
	static C(Other: UObject): MaterialInstance;
}

declare class MaterialInstanceDynamic extends MaterialInstance { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialInstanceDynamic;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialInstanceDynamic;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstanceDynamic;
	static C(Other: UObject): MaterialInstanceDynamic;
	SetVectorParameterValue(ParameterName: string,Value: LinearColor): void;
	SetTextureParameterValue(ParameterName: string,Value: Texture): void;
	SetScalarParameterValue(ParameterName: string,Value: number): void;
	InterpolateMaterialInstanceParameters(MaterialA: MaterialInstance,MaterialB: MaterialInstance,Alpha: number): void;
	GetVectorParameterValue(ParameterName: string): LinearColor;
	GetTextureParameterValue(ParameterName: string): Texture;
	GetScalarParameterValue(ParameterName: string): number;
	CopyMaterialInstanceParameters(SourceMaterialToCopyFrom: MaterialInterface): void;
	CopyParameterOverrides(MaterialInstance: MaterialInstance): void;
}

declare class DecalComponent extends SceneComponent { 
	DecalMaterial: MaterialInterface;
	SortOrder: number;
	FadeScreenSize: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DecalComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DecalComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DecalComponent;
	static C(Other: UObject): DecalComponent;
	SetSortOrder(Value: number): void;
	SetDecalMaterial(NewDecalMaterial: MaterialInterface): void;
	GetDecalMaterial(): MaterialInterface;
	CreateDynamicMaterialInstance(): MaterialInstanceDynamic;
}

declare class MaterialExpressionComment extends MaterialExpression { 
	SizeX: number;
	SizeY: number;
	Text: string;
	CommentColor: LinearColor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionComment;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionComment;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionComment;
	static C(Other: UObject): MaterialExpressionComment;
}

declare class MaterialFunction extends UObject { 
	StateId: Guid;
	ParentFunction: MaterialFunction;
	Description: string;
	bExposeToLibrary: boolean;
	LibraryCategories: string[];
	LibraryCategoriesText: string[];
	FunctionExpressions: MaterialExpression[];
	FunctionEditorComments: MaterialExpressionComment[];
	PreviewMaterial: Material;
	bReentrantFlag: boolean;
	CombinedInputTypes: any;
	CombinedOutputTypes: any;
	ThumbnailInfo: ThumbnailInfo;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialFunction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialFunction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialFunction;
	static C(Other: UObject): MaterialFunction;
}

declare class ExpressionOutput { 
	OutputName: string;
	Mask: number;
	MaskR: number;
	MaskG: number;
	MaskB: number;
	MaskA: number;
}

declare class MaterialExpression extends UObject { 
	MaterialExpressionEditorX: number;
	MaterialExpressionEditorY: number;
	MaterialExpressionGuid: Guid;
	Material: Material;
	UFunction: MaterialFunction;
	Desc: string;
	BorderColor: Color;
	bRealtimePreview: boolean;
	bNeedToUpdatePreview: boolean;
	bIsParameterExpression: boolean;
	bCommentBubbleVisible: boolean;
	bShowOutputNameOnPin: boolean;
	bHidePreviewWindow: boolean;
	bCollapsed: boolean;
	bShaderInputData: boolean;
	bShowInputs: boolean;
	bShowOutputs: boolean;
	MenuCategories: string[];
	Outputs: ExpressionOutput[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpression;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpression;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpression;
	static C(Other: UObject): MaterialExpression;
}

declare class MaterialInput { 
	Expression: MaterialExpression;
	OutputIndex: number;
	InputName: string;
	Mask: number;
	MaskR: number;
	MaskG: number;
	MaskB: number;
	MaskA: number;
	GCC64_Padding: number;
}

declare class ColorMaterialInput extends MaterialInput { 
	UseConstant: boolean;
	Constant: Color;
}

declare class ScalarMaterialInput extends MaterialInput { 
	UseConstant: boolean;
	Constant: number;
}

declare class VectorMaterialInput extends MaterialInput { 
	UseConstant: boolean;
	Constant: Vector;
}

declare type EMaterialDomain = string;
declare type EDecalBlendMode = string;
declare type EMaterialDecalResponse = string;
declare class Vector2MaterialInput extends MaterialInput { 
	UseConstant: boolean;
	ConstantX: number;
	ConstantY: number;
}

declare class ExpressionInput { 
	Expression: MaterialExpression;
	OutputIndex: number;
	InputName: string;
	Mask: number;
	MaskR: number;
	MaskG: number;
	MaskB: number;
	MaskA: number;
	GCC64_Padding: number;
}

declare class MaterialAttributesInput extends ExpressionInput { 
}

declare type ETranslucencyLightingMode = string;
declare type EMaterialTessellationMode = string;
declare class MaterialFunctionInfo { 
	StateId: Guid;
	UFunction: MaterialFunction;
}

declare class CollectionParameterBase { 
	ParameterName: string;
	Id: Guid;
}

declare class CollectionScalarParameter extends CollectionParameterBase { 
	DefaultValue: number;
}

declare class CollectionVectorParameter extends CollectionParameterBase { 
	DefaultValue: LinearColor;
}

declare class MaterialParameterCollection extends UObject { 
	StateId: Guid;
	ScalarParameters: CollectionScalarParameter[];
	VectorParameters: CollectionVectorParameter[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialParameterCollection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialParameterCollection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialParameterCollection;
	static C(Other: UObject): MaterialParameterCollection;
}

declare class MaterialParameterCollectionInfo { 
	StateId: Guid;
	ParameterCollection: MaterialParameterCollection;
}

declare type EBlendableLocation = string;
declare class Material extends MaterialInterface { 
	PhysMaterial: PhysicalMaterial;
	DiffuseColor: ColorMaterialInput;
	SpecularColor: ColorMaterialInput;
	BaseColor: ColorMaterialInput;
	Metallic: ScalarMaterialInput;
	Specular: ScalarMaterialInput;
	Roughness: ScalarMaterialInput;
	Normal: VectorMaterialInput;
	EmissiveColor: ColorMaterialInput;
	Opacity: ScalarMaterialInput;
	OpacityMask: ScalarMaterialInput;
	MaterialDomain: EMaterialDomain;
	BlendMode: EBlendMode;
	DecalBlendMode: EDecalBlendMode;
	MaterialDecalResponse: EMaterialDecalResponse;
	ShadingModel: EMaterialShadingModel;
	OpacityMaskClipValue: number;
	WorldPositionOffset: VectorMaterialInput;
	WorldDisplacement: VectorMaterialInput;
	TessellationMultiplier: ScalarMaterialInput;
	SubsurfaceColor: ColorMaterialInput;
	ClearCoat: ScalarMaterialInput;
	ClearCoatRoughness: ScalarMaterialInput;
	AmbientOcclusion: ScalarMaterialInput;
	Refraction: ScalarMaterialInput;
	CustomizedUVs: Vector2MaterialInput;
	MaterialAttributes: MaterialAttributesInput;
	PixelDepthOffset: ScalarMaterialInput;
	bEnableSeparateTranslucency: boolean;
	bEnableResponsiveAA: boolean;
	bScreenSpaceReflections: boolean;
	TwoSided: boolean;
	DitheredLODTransition: boolean;
	NumCustomizedUVs: number;
	TranslucencyLightingMode: ETranslucencyLightingMode;
	TranslucencyDirectionalLightingIntensity: number;
	TranslucentShadowDensityScale: number;
	TranslucentSelfShadowDensityScale: number;
	TranslucentSelfShadowSecondDensityScale: number;
	TranslucentSelfShadowSecondOpacity: number;
	TranslucentBackscatteringExponent: number;
	TranslucentMultipleScatteringExtinction: LinearColor;
	TranslucentShadowStartOffset: number;
	bDisableDepthTest: boolean;
	bGenerateSphericalParticleNormals: boolean;
	bTangentSpaceNormal: boolean;
	bUseEmissiveForDynamicAreaLighting: boolean;
	bBlockGI: boolean;
	bUsedAsSpecialEngineMaterial: boolean;
	bUsedWithSkeletalMesh: boolean;
	bUsedWithEditorCompositing: boolean;
	bUsedWithLandscape: boolean;
	bUsedWithParticleSprites: boolean;
	bUsedWithBeamTrails: boolean;
	bUsedWithMeshParticles: boolean;
	bUsedWithStaticLighting: boolean;
	bUsedWithFluidSurfaces: boolean;
	bUsedWithMorphTargets: boolean;
	bUsedWithSplineMeshes: boolean;
	bUsedWithInstancedStaticMeshes: boolean;
	bUsesDistortion: boolean;
	bUsedWithClothing: boolean;
	bUsedWithUI: boolean;
	bAutomaticallySetUsageInEditor: boolean;
	bFullyRough: boolean;
	bUseLightmapDirectionality: boolean;
	D3D11TessellationMode: EMaterialTessellationMode;
	bEnableCrackFreeDisplacement: boolean;
	bEnableAdaptiveTessellation: boolean;
	MaxDisplacement: number;
	Wireframe: boolean;
	bOutputVelocityOnBasePass: boolean;
	EditorX: number;
	EditorY: number;
	EditorPitch: number;
	EditorYaw: number;
	Expressions: MaterialExpression[];
	EditorComments: MaterialExpressionComment[];
	MaterialFunctionInfos: MaterialFunctionInfo[];
	MaterialParameterCollectionInfos: MaterialParameterCollectionInfo[];
	bCanMaskedBeAssumedOpaque: boolean;
	bIsMasked: boolean;
	bIsPreviewMaterial: boolean;
	bUseMaterialAttributes: boolean;
	bUseTranslucencyVertexFog: boolean;
	bAllowDevelopmentShaderCompile: boolean;
	bIsMaterialEditorStatsMaterial: boolean;
	UsageFlagWarnings: any;
	BlendableLocation: EBlendableLocation;
	BlendablePriority: number;
	RefractionDepthBias: number;
	StateId: Guid;
	ExpressionTextureReferences: Texture[];
	ReferencedTextureGuids: Guid[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Material;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Material;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Material;
	static C(Other: UObject): Material;
}

declare class MaterialInterface extends UObject { 
	SubsurfaceProfile: SubsurfaceProfile;
	LightmassSettings: LightmassMaterialInterfaceSettings;
	PreviewMesh: StringAssetReference;
	ThumbnailInfo: ThumbnailInfo;
	LightingGuid: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInterface;
	static C(Other: UObject): MaterialInterface;
	SpawnDecalAttached(DecalSize: Vector,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,LifeSpan: number): DecalComponent;
	MakeBrushFromMaterial(Width: number,Height: number): SlateBrush;
	GetPhysicalMaterial(): PhysicalMaterial;
	GetBaseMaterial(): Material;
}

declare class OverlapInfo { 
}

declare type EAutoReceiveInput = string;
declare type EAutoPossessAI = string;
declare class SpriteCategoryInfo { 
	Category: string;
	DisplayName: string;
	Description: string;
}

declare class BillboardComponent extends PrimitiveComponent { 
	Sprite: Texture2D;
	bIsScreenSizeScaled: boolean;
	ScreenSize: number;
	U: number;
	UL: number;
	V: number;
	VL: number;
	SpriteCategoryName: string;
	SpriteInfo: SpriteCategoryInfo;
	bUseInEditorScaling: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BillboardComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BillboardComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BillboardComponent;
	static C(Other: UObject): BillboardComponent;
	SetUV(NewU: number,NewUL: number,NewV: number,NewVL: number): void;
	SetSpriteAndUV(NewSprite: Texture2D,NewU: number,NewUL: number,NewV: number,NewVL: number): void;
	SetSprite(NewSprite: Texture2D): void;
}

declare class LayerActorStats { 
	Type: UnrealEngineClass;
	Total: number;
}

declare class Layer extends UObject { 
	LayerName: string;
	bIsVisible: boolean;
	ActorStats: LayerActorStats[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Layer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Layer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Layer;
	static C(Other: UObject): Layer;
}

declare class KShapeElem { 
}

declare class Plane extends Vector { 
	W: number;
}

declare class Matrix { 
	XPlane: Plane;
	YPlane: Plane;
	ZPlane: Plane;
	WPlane: Plane;
}

declare class KSphereElem extends KShapeElem { 
	TM: Matrix;
	Center: Vector;
	Radius: number;
}

declare class KBoxElem extends KShapeElem { 
	TM: Matrix;
	Center: Vector;
	Orientation: Quat;
	X: number;
	Y: number;
	Z: number;
}

declare class KSphylElem extends KShapeElem { 
	TM: Matrix;
	Center: Vector;
	Orientation: Quat;
	Radius: number;
	Length: number;
}

declare class Box { 
	Min: Vector;
	Max: Vector;
	IsValid: number;
}

declare class KConvexElem extends KShapeElem { 
	VertexData: Vector[];
	ElemBox: Box;
	Transform: Transform;
}

declare class KAggregateGeom { 
	SphereElems: KSphereElem[];
	BoxElems: KBoxElem[];
	SphylElems: KSphylElem[];
	ConvexElems: KConvexElem[];
}

declare type EPhysicsType = string;
declare type EBodyCollisionResponse = string;
declare type ECollisionTraceFlag = string;
declare class BodySetup extends UObject { 
	AggGeom: KAggregateGeom;
	BoneName: string;
	PhysicsType: EPhysicsType;
	bAlwaysFullAnimWeight: boolean;
	bConsiderForBounds: boolean;
	bMeshCollideAll: boolean;
	bDoubleSidedGeometry: boolean;
	bGenerateNonMirroredCollision: boolean;
	bSharedCookedData: boolean;
	bGenerateMirroredCollision: boolean;
	PhysMaterial: PhysicalMaterial;
	CollisionReponse: EBodyCollisionResponse;
	CollisionTraceFlag: ECollisionTraceFlag;
	DefaultInstance: BodyInstance;
	WalkableSlopeOverride: WalkableSlopeOverride;
	BuildScale: number;
	BuildScale3D: Vector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BodySetup;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BodySetup;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BodySetup;
	static C(Other: UObject): BodySetup;
}

declare class ModelComponent extends PrimitiveComponent { 
	ModelBodySetup: BodySetup;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ModelComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ModelComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ModelComponent;
	static C(Other: UObject): ModelComponent;
}

declare class BlueprintCore extends UObject { 
	SkeletonGeneratedClass: UnrealEngineClass;
	GeneratedClass: UnrealEngineClass;
	bLegacyNeedToPurgeSkelRefs: boolean;
	bLegacyGeneratedClassIsAuthoritative: boolean;
	BlueprintGuid: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintCore;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintCore;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintCore;
	static C(Other: UObject): BlueprintCore;
}

declare class BPVariableMetaDataEntry { 
	DataKey: string;
	DataValue: string;
}

declare class SCS_Node extends UObject { 
	ComponentTemplate: ActorComponent;
	VariableName: string;
	CategoryName: string;
	AttachToName: string;
	ParentComponentOrVariableName: string;
	ParentComponentOwnerClassName: string;
	bIsParentComponentNative: boolean;
	ChildNodes: SCS_Node[];
	MetaDataArray: BPVariableMetaDataEntry[];
	VariableGuid: Guid;
	bIsFalseRoot: boolean;
	bIsNative: boolean;
	NativeComponentName: string;
	bVariableNameAutoGenerated: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SCS_Node;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SCS_Node;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SCS_Node;
	static C(Other: UObject): SCS_Node;
}

declare class SimpleConstructionScript extends UObject { 
	RootNodes: SCS_Node[];
	DefaultSceneRootNode: SCS_Node;
	RootNode: SCS_Node;
	ActorComponentNodes: SCS_Node[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SimpleConstructionScript;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SimpleConstructionScript;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SimpleConstructionScript;
	static C(Other: UObject): SimpleConstructionScript;
}

declare class EdGraphSchema extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EdGraphSchema;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EdGraphSchema;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphSchema;
	static C(Other: UObject): EdGraphSchema;
}

declare type EEdGraphPinDirection = string;
declare class EdGraphPinType { 
	PinCategory: string;
	PinSubCategory: string;
	PinSubCategoryObject: any;
	PinSubCategoryMemberReference: SimpleMemberReference;
	bIsArray: boolean;
	bIsReference: boolean;
	bIsConst: boolean;
	bIsWeakPointer: boolean;
}

declare class EdGraphPin extends UObject { 
	PinName: string;
	PinFriendlyName: string;
	PinToolTip: string;
	Direction: EEdGraphPinDirection;
	PinType: EdGraphPinType;
	DefaultValue: string;
	AutogeneratedDefaultValue: string;
	DefaultObject: UObject;
	DefaultTextValue: string;
	LinkedTo: EdGraphPin[];
	SubPins: EdGraphPin[];
	ParentPin: EdGraphPin;
	bHidden: boolean;
	bNotConnectable: boolean;
	bDefaultValueIsReadOnly: boolean;
	bDefaultValueIsIgnored: boolean;
	bIsDiffing: boolean;
	bAdvancedView: boolean;
	bDisplayAsMutableRef: boolean;
	PersistentGuid: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EdGraphPin;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EdGraphPin;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphPin;
	static C(Other: UObject): EdGraphPin;
}

declare type ENodeAdvancedPins = string;
declare class EdGraphNode extends UObject { 
	Pins: EdGraphPin[];
	NodePosX: number;
	NodePosY: number;
	NodeWidth: number;
	NodeHeight: number;
	bCanResizeNode: boolean;
	bHasCompilerMessage: boolean;
	bCanRenameNode: boolean;
	NodeComment: string;
	bCommentBubblePinned: boolean;
	bCommentBubbleVisible: boolean;
	ErrorType: number;
	ErrorMsg: string;
	NodeGuid: Guid;
	AdvancedPinDisplay: ENodeAdvancedPins;
	bIsNodeEnabled: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EdGraphNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EdGraphNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphNode;
	static C(Other: UObject): EdGraphNode;
}

declare class EdGraph extends UObject { 
	Schema: UnrealEngineClass;
	Nodes: EdGraphNode[];
	bEditable: boolean;
	bAllowDeletion: boolean;
	bAllowRenaming: boolean;
	SubGraphs: EdGraph[];
	GraphGuid: Guid;
	InterfaceGuid: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EdGraph;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EdGraph;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraph;
	static C(Other: UObject): EdGraph;
}

declare type ETimelineLengthMode = string;
declare class TTTrackBase { 
	TrackName: string;
	bIsExternalCurve: boolean;
}

declare class CurveBase extends UObject { 
	AssetImportData: AssetImportData;
	ImportPath: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CurveBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CurveBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveBase;
	static C(Other: UObject): CurveBase;
	GetValueRange(MinValue?: number,MaxValue?: number): {MinValue: number, MaxValue: number};
	GetTimeRange(MinTime?: number,MaxTime?: number): {MinTime: number, MaxTime: number};
}

declare class KeyHandleMap { 
}

declare class IndexedCurve { 
	KeyHandlesToIndices: KeyHandleMap;
}

declare type ERichCurveExtrapolation = string;
declare type ERichCurveInterpMode = string;
declare type ERichCurveTangentMode = string;
declare type ERichCurveTangentWeightMode = string;
declare class RichCurveKey { 
	InterpMode: ERichCurveInterpMode;
	TangentMode: ERichCurveTangentMode;
	TangentWeightMode: ERichCurveTangentWeightMode;
	Time: number;
	Value: number;
	ArriveTangent: number;
	ArriveTangentWeight: number;
	LeaveTangent: number;
	LeaveTangentWeight: number;
}

declare class RichCurve extends IndexedCurve { 
	PreInfinityExtrap: ERichCurveExtrapolation;
	PostInfinityExtrap: ERichCurveExtrapolation;
	Keys: RichCurveKey[];
	DefaultValue: number;
}

declare class CurveFloat extends CurveBase { 
	FloatCurve: RichCurve;
	bIsEventCurve: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CurveFloat;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CurveFloat;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveFloat;
	static C(Other: UObject): CurveFloat;
	GetFloatValue(InTime: number): number;
}

declare class TTEventTrack extends TTTrackBase { 
	CurveKeys: CurveFloat;
}

declare class TTFloatTrack extends TTTrackBase { 
	CurveFloat: CurveFloat;
}

declare class CurveVector extends CurveBase { 
	FloatCurves: RichCurve;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CurveVector;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CurveVector;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveVector;
	static C(Other: UObject): CurveVector;
	GetVectorValue(InTime: number): Vector;
}

declare class TTVectorTrack extends TTTrackBase { 
	CurveVector: CurveVector;
}

declare class CurveLinearColor extends CurveBase { 
	FloatCurves: RichCurve;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CurveLinearColor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CurveLinearColor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveLinearColor;
	static C(Other: UObject): CurveLinearColor;
	GetLinearColorValue(InTime: number): LinearColor;
}

declare class TTLinearColorTrack extends TTTrackBase { 
	CurveLinearColor: CurveLinearColor;
}

declare class TimelineTemplate extends UObject { 
	TimelineLength: number;
	LengthMode: ETimelineLengthMode;
	bAutoPlay: boolean;
	bLoop: boolean;
	bReplicated: boolean;
	bValidatedAsWired: boolean;
	EventTracks: TTEventTrack[];
	FloatTracks: TTFloatTrack[];
	VectorTracks: TTVectorTrack[];
	LinearColorTracks: TTLinearColorTrack[];
	MetaDataArray: BPVariableMetaDataEntry[];
	TimelineGuid: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TimelineTemplate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TimelineTemplate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TimelineTemplate;
	static C(Other: UObject): TimelineTemplate;
}

declare class ComponentKey { 
	OwnerClass: UnrealEngineClass;
	SCSVariableName: string;
	AssociatedGuid: Guid;
}

declare class ComponentOverrideRecord { 
	ComponentTemplate: ActorComponent;
	ComponentKey: ComponentKey;
}

declare class InheritableComponentHandler extends UObject { 
	Records: ComponentOverrideRecord[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InheritableComponentHandler;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InheritableComponentHandler;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InheritableComponentHandler;
	static C(Other: UObject): InheritableComponentHandler;
}

declare type EBlueprintType = string;
declare type EBlueprintStatus = string;
declare class BPVariableDescription { 
	VarName: string;
	VarGuid: Guid;
	VarType: EdGraphPinType;
	FriendlyName: string;
	Category: string;
	PropertyFlags: any;
	RepNotifyFunc: string;
	MetaDataArray: BPVariableMetaDataEntry[];
	DefaultValue: string;
}

declare class BPInterfaceDescription { 
	Interface: UnrealEngineClass;
	Graphs: EdGraph[];
}

declare class EditedDocumentInfo { 
	EditedObject: UObject;
	SavedViewOffset: Vector2D;
	SavedZoomAmount: number;
}

declare class Breakpoint extends UObject { 
	bEnabled: boolean;
	UNode: EdGraphNode;
	bStepOnce: boolean;
	bStepOnce_WasPreviouslyDisabled: boolean;
	bStepOnce_RemoveAfterHit: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Breakpoint;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Breakpoint;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Breakpoint;
	static C(Other: UObject): Breakpoint;
}

declare class Blueprint extends BlueprintCore { 
	bRecompileOnLoad: boolean;
	ParentClass: UnrealEngineClass;
	PRIVATE_InnermostPreviousCDO: UObject;
	bHasBeenRegenerated: boolean;
	bIsRegeneratingOnLoad: boolean;
	bIsNewlyCreated: boolean;
	bForceFullEditor: boolean;
	bRunConstructionScriptOnDrag: boolean;
	bGenerateConstClass: boolean;
	BlueprintDescription: string;
	BlueprintCategory: string;
	HideCategories: string[];
	bDisplayCompilePIEWarning: boolean;
	SearchGuid: Guid;
	bDeprecate: boolean;
	SimpleConstructionScript: SimpleConstructionScript;
	UbergraphPages: EdGraph[];
	FunctionGraphs: EdGraph[];
	DelegateSignatureGraphs: EdGraph[];
	MacroGraphs: EdGraph[];
	IntermediateGeneratedGraphs: EdGraph[];
	EventGraphs: EdGraph[];
	bDuplicatingReadOnly: boolean;
	ComponentTemplates: ActorComponent[];
	Timelines: TimelineTemplate[];
	InheritableComponentHandler: InheritableComponentHandler;
	BlueprintType: EBlueprintType;
	Status: EBlueprintStatus;
	NewVariables: BPVariableDescription[];
	CategorySorting: string[];
	ImplementedInterfaces: BPInterfaceDescription[];
	BlueprintSystemVersion: number;
	LastEditedDocuments: EditedDocumentInfo[];
	Breakpoints: Breakpoint[];
	PinWatches: EdGraphPin[];
	ThumbnailInfo: ThumbnailInfo;
	bBeingCompiled: boolean;
	CrcLastCompiledCDO: any;
	CrcLastCompiledSignature: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Blueprint;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Blueprint;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Blueprint;
	static C(Other: UObject): Blueprint;
	GetBlueprintGeneratedClass(): UnrealEngineClass;
	CreateSaveGameObjectFromBlueprint(): SaveGame;
}

declare class LevelScriptBlueprint extends Blueprint { 
	FriendlyName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelScriptBlueprint;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelScriptBlueprint;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelScriptBlueprint;
	static C(Other: UObject): LevelScriptBlueprint;
}

declare class IntVector { 
	X: number;
	Y: number;
	Z: number;
}

declare class LevelScriptActor extends Actor { 
	bInputEnabled: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelScriptActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelScriptActor;
	static C(Other: UObject): LevelScriptActor;
	WorldOriginLocationChanged(OldOriginLocation: IntVector,NewOriginLocation: IntVector): void;
	SetCinematicMode(bCinematicMode: boolean,bHidePlayer: boolean,bAffectsHUD: boolean,bAffectsMovement: boolean,bAffectsTurning: boolean): void;
	RemoteEvent(EventName: string): boolean;
	LevelReset(): void;
}

declare class NavAgentSelector { 
	bSupportsAgent0: boolean;
	bSupportsAgent1: boolean;
	bSupportsAgent2: boolean;
	bSupportsAgent3: boolean;
	bSupportsAgent4: boolean;
	bSupportsAgent5: boolean;
	bSupportsAgent6: boolean;
	bSupportsAgent7: boolean;
	bSupportsAgent8: boolean;
	bSupportsAgent9: boolean;
	bSupportsAgent10: boolean;
	bSupportsAgent11: boolean;
	bSupportsAgent12: boolean;
	bSupportsAgent13: boolean;
	bSupportsAgent14: boolean;
	bSupportsAgent15: boolean;
}

declare class NavArea extends UObject { 
	DefaultCost: number;
	FixedAreaEnteringCost: number;
	DrawColor: Color;
	SupportedAgents: NavAgentSelector;
	bSupportsAgent0: boolean;
	bSupportsAgent1: boolean;
	bSupportsAgent2: boolean;
	bSupportsAgent3: boolean;
	bSupportsAgent4: boolean;
	bSupportsAgent5: boolean;
	bSupportsAgent6: boolean;
	bSupportsAgent7: boolean;
	bSupportsAgent8: boolean;
	bSupportsAgent9: boolean;
	bSupportsAgent10: boolean;
	bSupportsAgent11: boolean;
	bSupportsAgent12: boolean;
	bSupportsAgent13: boolean;
	bSupportsAgent14: boolean;
	bSupportsAgent15: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavArea;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavArea;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavArea;
	static C(Other: UObject): NavArea;
}

declare class ShapeComponent extends PrimitiveComponent { 
	ShapeColor: Color;
	ShapeBodySetup: BodySetup;
	bDrawOnlyIfSelected: boolean;
	bShouldCollideWhenPlacing: boolean;
	bDynamicObstacle: boolean;
	AreaClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ShapeComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ShapeComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ShapeComponent;
	static C(Other: UObject): ShapeComponent;
}

declare class CapsuleComponent extends ShapeComponent { 
	CapsuleHalfHeight: number;
	CapsuleRadius: number;
	CapsuleHeight: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CapsuleComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CapsuleComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CapsuleComponent;
	static C(Other: UObject): CapsuleComponent;
	SetCapsuleSize(InRadius: number,InHalfHeight: number,bUpdateOverlaps: boolean): void;
	SetCapsuleRadius(Radius: number,bUpdateOverlaps: boolean): void;
	SetCapsuleHalfHeight(HalfHeight: number,bUpdateOverlaps: boolean): void;
	GetUnscaledCapsuleSize(OutRadius?: number,OutHalfHeight?: number): {OutRadius: number, OutHalfHeight: number};
	GetUnscaledCapsuleRadius(): number;
	GetUnscaledCapsuleHalfHeight(): number;
	GetShapeScale(): number;
	GetScaledCapsuleSize(OutRadius?: number,OutHalfHeight?: number): {OutRadius: number, OutHalfHeight: number};
	GetScaledCapsuleRadius(): number;
	GetScaledCapsuleHalfHeight(): number;
}

declare class NavigationObjectBase extends Actor { 
	CapsuleComponent: CapsuleComponent;
	GoodSprite: BillboardComponent;
	BadSprite: BillboardComponent;
	bIsPIEPlayerStart: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavigationObjectBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationObjectBase;
	static C(Other: UObject): NavigationObjectBase;
}

declare class NavigationDataChunk extends UObject { 
	NavigationDataName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavigationDataChunk;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavigationDataChunk;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationDataChunk;
	static C(Other: UObject): NavigationDataChunk;
}

declare class MaterialSimplificationSettings { 
	BaseColorMapSize: IntPoint;
	bNormalMap: boolean;
	NormalMapSize: IntPoint;
	MetallicConstant: number;
	bMetallicMap: boolean;
	MetallicMapSize: IntPoint;
	RoughnessConstant: number;
	bRoughnessMap: boolean;
	RoughnessMapSize: IntPoint;
	SpecularConstant: number;
	bSpecularMap: boolean;
	SpecularMapSize: IntPoint;
}

declare class LevelSimplificationDetails { 
	bCreatePackagePerAsset: boolean;
	DetailsPercentage: number;
	StaticMeshMaterial: MaterialSimplificationSettings;
	bOverrideLandscapeExportLOD: boolean;
	LandscapeExportLOD: number;
	LandscapeMaterial: MaterialSimplificationSettings;
	bBakeFoliageToLandscape: boolean;
	bBakeGrassToLandscape: boolean;
	bGenerateMeshNormalMap: boolean;
	bGenerateMeshMetallicMap: boolean;
	bGenerateMeshRoughnessMap: boolean;
	bGenerateMeshSpecularMap: boolean;
	bGenerateLandscapeNormalMap: boolean;
	bGenerateLandscapeMetallicMap: boolean;
	bGenerateLandscapeRoughnessMap: boolean;
	bGenerateLandscapeSpecularMap: boolean;
}

declare class Level extends UObject { 
	OwningWorld: World;
	Model: Model;
	ModelComponents: ModelComponent[];
	LevelScriptBlueprint: LevelScriptBlueprint;
	LevelScriptActor: LevelScriptActor;
	NavListStart: NavigationObjectBase;
	NavListEnd: NavigationObjectBase;
	NavDataChunks: NavigationDataChunk[];
	LightmapTotalSize: number;
	ShadowmapTotalSize: number;
	StaticNavigableGeometry: Vector[];
	bIsVisible: boolean;
	bLocked: boolean;
	LevelSimplification: LevelSimplificationDetails;
	AssetUserData: AssetUserData[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Level;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Level;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Level;
	static C(Other: UObject): Level;
}

declare class Player extends UObject { 
	PlayerController: PlayerController;
	CurrentNetSpeed: number;
	ConfiguredInternetSpeed: number;
	ConfiguredLanSpeed: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Player;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Player;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Player;
	static C(Other: UObject): Player;
}

declare class ChildConnection extends NetConnection { 
	Parent: NetConnection;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ChildConnection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ChildConnection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChildConnection;
	static C(Other: UObject): ChildConnection;
}

declare class PackageMap extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PackageMap;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PackageMap;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PackageMap;
	static C(Other: UObject): PackageMap;
}

declare class Channel extends UObject { 
	Connection: NetConnection;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Channel;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Channel;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Channel;
	static C(Other: UObject): Channel;
}

declare class NetConnection extends Player { 
	Children: ChildConnection[];
	Driver: NetDriver;
	PackageMap: PackageMap;
	OpenChannels: Channel[];
	SentTemporaries: Actor[];
	ViewTarget: Actor;
	OwningActor: Actor;
	MaxPacket: number;
	InternalAck: boolean;
	LastReceiveTime: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NetConnection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NetConnection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetConnection;
	static C(Other: UObject): NetConnection;
}

declare class Property extends Field { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Property;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Property;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Property;
	static C(Other: UObject): Property;
}

declare class NetDriver extends UObject { 
	NetConnectionClassName: string;
	MaxDownloadSize: number;
	bClampListenServerTickRate: boolean;
	NetServerMaxTickRate: number;
	MaxInternetClientRate: number;
	MaxClientRate: number;
	ServerTravelPause: number;
	SpawnPrioritySeconds: number;
	RelevantTimeout: number;
	KeepAliveTime: number;
	InitialConnectTimeout: number;
	ConnectionTimeout: number;
	ServerConnection: NetConnection;
	ClientConnections: NetConnection[];
	World: World;
	NetConnectionClass: UnrealEngineClass;
	RoleProperty: Property;
	RemoteRoleProperty: Property;
	NetDriverName: string;
	Time: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NetDriver;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NetDriver;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetDriver;
	static C(Other: UObject): NetDriver;
}

declare class LineBatchComponent extends PrimitiveComponent { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LineBatchComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LineBatchComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LineBatchComponent;
	static C(Other: UObject): LineBatchComponent;
}

declare class ReporterBase extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReporterBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReporterBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReporterBase;
	static C(Other: UObject): ReporterBase;
}

declare class ReporterGraph extends ReporterBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReporterGraph;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReporterGraph;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReporterGraph;
	static C(Other: UObject): ReporterGraph;
}

declare class CanvasUVTri { 
	V0_Pos: Vector2D;
	V0_UV: Vector2D;
	V0_Color: LinearColor;
	V1_Pos: Vector2D;
	V1_UV: Vector2D;
	V1_Color: LinearColor;
	V2_Pos: Vector2D;
	V2_UV: Vector2D;
	V2_Color: LinearColor;
}

declare class Canvas extends UObject { 
	OrgX: number;
	OrgY: number;
	ClipX: number;
	ClipY: number;
	DrawColor: Color;
	bCenterX: boolean;
	bCenterY: boolean;
	bNoSmooth: boolean;
	SizeX: number;
	SizeY: number;
	ColorModulate: Plane;
	DefaultTexture: Texture2D;
	GradientTexture0: Texture2D;
	ReporterGraph: ReporterGraph;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Canvas;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Canvas;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Canvas;
	static C(Other: UObject): Canvas;
	ClippedTextSize(RenderFont: Font,RenderText: string,Scale: Vector2D): Vector2D;
	WrappedTextSize(RenderFont: Font,RenderText: string): Vector2D;
	Project(WorldLocation: Vector): Vector;
	DrawTriangles(RenderTexture: Texture,Triangles: CanvasUVTri[]): void;
	DrawTexture(RenderTexture: Texture,ScreenPosition: Vector2D,ScreenSize: Vector2D,CoordinatePosition: Vector2D,CoordinateSize: Vector2D,RenderColor: LinearColor,BlendMode: EBlendMode,Rotation: number,PivotPoint: Vector2D): void;
	DrawText(RenderFont: Font,RenderText: string,ScreenPosition: Vector2D,RenderColor: LinearColor,Kerning: number,ShadowColor: LinearColor,ShadowOffset: Vector2D,bCentreX: boolean,bCentreY: boolean,bOutlined: boolean,OutlineColor: LinearColor): void;
	DrawPolygon(RenderTexture: Texture,ScreenPosition: Vector2D,Radius: Vector2D,NumberOfSides: number,RenderColor: LinearColor): void;
	DrawMaterialTriangles(RenderMaterial: MaterialInterface,Triangles: CanvasUVTri[]): void;
	DrawMaterial(RenderMaterial: MaterialInterface,ScreenPosition: Vector2D,ScreenSize: Vector2D,CoordinatePosition: Vector2D,CoordinateSize: Vector2D,Rotation: number,PivotPoint: Vector2D): void;
	DrawLine(ScreenPositionA: Vector2D,ScreenPositionB: Vector2D,Thickness: number,RenderColor: LinearColor): void;
	DrawBox(ScreenPosition: Vector2D,ScreenSize: Vector2D,Thickness: number): void;
	DrawBorder(BorderTexture: Texture,BackgroundTexture: Texture,LeftBorderTexture: Texture,RightBorderTexture: Texture,TopBorderTexture: Texture,BottomBorderTexture: Texture,ScreenPosition: Vector2D,ScreenSize: Vector2D,CoordinatePosition: Vector2D,CoordinateSize: Vector2D,RenderColor: LinearColor,BorderScale: Vector2D,BackgroundScale: Vector2D,Rotation: number,PivotPoint: Vector2D,CornerSize: Vector2D): void;
	Deproject(ScreenPosition: Vector2D,WorldOrigin?: Vector,WorldDirection?: Vector): {WorldOrigin: Vector, WorldDirection: Vector};
}

declare class DebugTextInfo { 
	SrcActor: Actor;
	SrcActorOffset: Vector;
	SrcActorDesiredOffset: Vector;
	DebugText: string;
	TimeRemaining: number;
	Duration: number;
	TextColor: Color;
	bAbsoluteLocation: boolean;
	bKeepAttachedToActor: boolean;
	bDrawShadow: boolean;
	OrigActorLocation: Vector;
	Font: Font;
	FontScale: number;
}

declare class HUD extends Actor { 
	WhiteColor: Color;
	GreenColor: Color;
	RedColor: Color;
	PlayerOwner: PlayerController;
	bLostFocusPaused: boolean;
	bShowHUD: boolean;
	bShowDebugInfo: boolean;
	bShowHitBoxDebugInfo: boolean;
	bShowOverlays: boolean;
	bEnableDebugTextShadow: boolean;
	PostRenderedActors: Actor[];
	LastHUDRenderTime: number;
	RenderDelta: number;
	DebugDisplay: string[];
	ToggledDebugCategories: string[];
	Canvas: Canvas;
	DebugCanvas: Canvas;
	DebugTextList: DebugTextInfo[];
	ShowDebugTargetDesiredClass: UnrealEngineClass;
	ShowDebugTargetActor: Actor;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): HUD;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HUD;
	static C(Other: UObject): HUD;
	ShowHUD(): void;
	ShowDebugToggleSubCategory(Category: string): void;
	ShowDebugForReticleTargetToggle(DesiredClass: UnrealEngineClass): void;
	ShowDebug(DebugType: string): void;
	RemoveDebugText(SrcActor: Actor,bLeaveDurationText: boolean): void;
	RemoveAllDebugStrings(): void;
	HitBoxReleased(BoxName: string): void;
	HitBoxEndCursorOver(BoxName: string): void;
	HitBoxClicked(BoxName: string): void;
	HitBoxBeginCursorOver(BoxName: string): void;
	ReceiveDrawHUD(SizeX: number,SizeY: number): void;
	Project(Location: Vector): Vector;
	GetTextSize(Text: string,OutWidth?: number,OutHeight?: number,Font?: Font,Scale?: number): {OutWidth: number, OutHeight: number};
	GetOwningPlayerController(): PlayerController;
	GetOwningPawn(): Pawn;
	GetActorsInSelectionRectangle(ClassFilter: UnrealEngineClass,FirstPoint: Vector2D,SecondPoint: Vector2D,OutActors?: Actor[],bIncludeNonCollidingComponents?: boolean,bActorMustBeFullyEnclosed?: boolean): {OutActors: Actor[]};
	DrawTextureSimple(Texture: Texture,ScreenX: number,ScreenY: number,Scale: number,bScalePosition: boolean): void;
	DrawTexture(Texture: Texture,ScreenX: number,ScreenY: number,ScreenW: number,ScreenH: number,TextureU: number,TextureV: number,TextureUWidth: number,TextureVHeight: number,TintColor: LinearColor,BlendMode: EBlendMode,Scale: number,bScalePosition: boolean,Rotation: number,RotPivot: Vector2D): void;
	DrawText(Text: string,TextColor: LinearColor,ScreenX: number,ScreenY: number,Font: Font,Scale: number,bScalePosition: boolean): void;
	DrawRect(RectColor: LinearColor,ScreenX: number,ScreenY: number,ScreenW: number,ScreenH: number): void;
	DrawMaterialTriangle(Material: MaterialInterface,V0_Pos: Vector2D,V1_Pos: Vector2D,V2_Pos: Vector2D,V0_UV: Vector2D,V1_UV: Vector2D,V2_UV: Vector2D,V0_Color: LinearColor,V1_Color: LinearColor,V2_Color: LinearColor): void;
	DrawMaterialSimple(Material: MaterialInterface,ScreenX: number,ScreenY: number,ScreenW: number,ScreenH: number,Scale: number,bScalePosition: boolean): void;
	DrawMaterial(Material: MaterialInterface,ScreenX: number,ScreenY: number,ScreenW: number,ScreenH: number,MaterialU: number,MaterialV: number,MaterialUWidth: number,MaterialVHeight: number,Scale: number,bScalePosition: boolean,Rotation: number,RotPivot: Vector2D): void;
	DrawLine(StartScreenX: number,StartScreenY: number,EndScreenX: number,EndScreenY: number,LineColor: LinearColor): void;
	Deproject(ScreenX: number,ScreenY: number,WorldPosition?: Vector,WorldDirection?: Vector): {WorldPosition: Vector, WorldDirection: Vector};
	AddHitBox(Position: Vector2D,Size: Vector2D,InName: string,bConsumesInput: boolean,Priority: number): void;
	AddDebugText(DebugText: string,SrcActor: Actor,Duration: number,Offset: Vector,DesiredOffset: Vector,TextColor: Color,bSkipOverwriteCheck: boolean,bAbsoluteLocation: boolean,bKeepAttachedToActor: boolean,InFont: Font,FontScale: number,bDrawShadow: boolean): void;
}

declare class GameSession extends Info { 
	MaxSpectators: number;
	MaxPlayers: number;
	MaxSplitscreensPerConnection: number;
	bRequiresPushToTalk: boolean;
	SessionName: string;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameSession;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameSession;
	static C(Other: UObject): GameSession;
}

declare class LocalMessage extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LocalMessage;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LocalMessage;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalMessage;
	static C(Other: UObject): LocalMessage;
}

declare type EPlaneConstraintAxisSetting = string;
declare class MovementComponent extends ActorComponent { 
	UpdatedComponent: SceneComponent;
	UpdatedPrimitive: PrimitiveComponent;
	Velocity: Vector;
	bConstrainToPlane: boolean;
	bSnapToPlaneAtStart: boolean;
	PlaneConstraintAxisSetting: EPlaneConstraintAxisSetting;
	PlaneConstraintNormal: Vector;
	PlaneConstraintOrigin: Vector;
	bUpdateOnlyIfRendered: boolean;
	bAutoUpdateTickRegistration: boolean;
	bAutoRegisterUpdatedComponent: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovementComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovementComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovementComponent;
	static C(Other: UObject): MovementComponent;
	StopMovementImmediately(): void;
	SnapUpdatedComponentToPlane(): void;
	SetUpdatedComponent(NewUpdatedComponent: SceneComponent): void;
	SetPlaneConstraintOrigin(PlaneOrigin: Vector): void;
	SetPlaneConstraintNormal(PlaneNormal: Vector): void;
	SetPlaneConstraintFromVectors(Forward: Vector,Up: Vector): void;
	SetPlaneConstraintEnabled(bEnabled: boolean): void;
	SetPlaneConstraintAxisSetting(NewAxisSetting: EPlaneConstraintAxisSetting): void;
	PhysicsVolumeChanged(NewVolume: PhysicsVolume): void;
	MoveUpdatedComponent(Delta: Vector,NewRotation: Rotator,OutHit?: HitResult,bSweep?: boolean,bTeleport?: boolean): {OutHit: HitResult, $: boolean};
	GetModifiedMaxSpeed(): number;
	GetMaxSpeedModifier(): number;
	IsExceedingMaxSpeed(MaxSpeed: number): boolean;
	GetPlaneConstraintOrigin(): Vector;
	GetPlaneConstraintNormal(): Vector;
	GetPlaneConstraintAxisSetting(): EPlaneConstraintAxisSetting;
	GetPhysicsVolume(): PhysicsVolume;
	GetMaxSpeed(): number;
	GetGravityZ(): number;
	ConstrainNormalToPlane(Normal: Vector): Vector;
	ConstrainLocationToPlane(Location: Vector): Vector;
	ConstrainDirectionToPlane(Direction: Vector): Vector;
}

declare class MovementProperties { 
	bCanCrouch: boolean;
	bCanJump: boolean;
	bCanWalk: boolean;
	bCanSwim: boolean;
	bCanFly: boolean;
}

declare class NavAgentProperties extends MovementProperties { 
	AgentRadius: number;
	AgentHeight: number;
	AgentStepHeight: number;
	NavWalkingSearchHeightScale: number;
}

declare class NavMovementComponent extends MovementComponent { 
	NavAgentProps: NavAgentProperties;
	bUpdateNavAgentWithOwnersCollision: boolean;
	MovementState: MovementProperties;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavMovementComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavMovementComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavMovementComponent;
	static C(Other: UObject): NavMovementComponent;
	StopMovementKeepPathing(): void;
	StopActiveMovement(): void;
	IsSwimming(): boolean;
	IsMovingOnGround(): boolean;
	IsFlying(): boolean;
	IsFalling(): boolean;
	IsCrouching(): boolean;
}

declare class PawnMovementComponent extends NavMovementComponent { 
	PawnOwner: Pawn;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PawnMovementComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PawnMovementComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnMovementComponent;
	static C(Other: UObject): PawnMovementComponent;
	GetInputVector(): Vector;
	IsMoveInputIgnored(): boolean;
	GetPendingInputVector(): Vector;
	GetPawnOwner(): Pawn;
	GetLastInputVector(): Vector;
	ConsumeInputVector(): Vector;
	AddInputVector(WorldVector: Vector,bForce: boolean): void;
}

declare class SphereComponent extends ShapeComponent { 
	SphereRadius: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SphereComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SphereComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SphereComponent;
	static C(Other: UObject): SphereComponent;
	SetSphereRadius(InSphereRadius: number,bUpdateOverlaps: boolean): void;
	GetUnscaledSphereRadius(): number;
	GetShapeScale(): number;
	GetScaledSphereRadius(): number;
}

declare class MeshComponent extends PrimitiveComponent { 
	OverrideMaterials: MaterialInterface[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MeshComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MeshComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshComponent;
	static C(Other: UObject): MeshComponent;
	GetMaterials(): MaterialInterface[];
}

declare class MeshBuildSettings { 
	bUseMikkTSpace: boolean;
	bRecomputeNormals: boolean;
	bRecomputeTangents: boolean;
	bRemoveDegenerates: boolean;
	bBuildAdjacencyBuffer: boolean;
	bUseFullPrecisionUVs: boolean;
	bGenerateLightmapUVs: boolean;
	MinLightmapResolution: number;
	SrcLightmapIndex: number;
	DstLightmapIndex: number;
	BuildScale: number;
	BuildScale3D: Vector;
	DistanceFieldResolutionScale: number;
	bGenerateDistanceFieldAsIfTwoSided: boolean;
	DistanceFieldReplacementMesh: StaticMesh;
}

declare type EMeshFeatureImportance = string;
declare class MeshReductionSettings { 
	PercentTriangles: number;
	MaxDeviation: number;
	WeldingThreshold: number;
	HardAngleThreshold: number;
	SilhouetteImportance: EMeshFeatureImportance;
	TextureImportance: EMeshFeatureImportance;
	ShadingImportance: EMeshFeatureImportance;
	bRecalculateNormals: boolean;
	BaseLODModel: number;
}

declare class StaticMeshSourceModel { 
	BuildSettings: MeshBuildSettings;
	ReductionSettings: MeshReductionSettings;
	LODDistance: number;
	ScreenSize: number;
}

declare class AssetEditorOrbitCameraPosition { 
	bIsSet: boolean;
	CamOrbitPoint: Vector;
	CamOrbitZoom: Vector;
	CamOrbitRotation: Rotator;
}

declare class StaticMeshSocket extends UObject { 
	SocketName: string;
	RelativeLocation: Vector;
	RelativeRotation: Rotator;
	RelativeScale: Vector;
	Tag: string;
	PreviewStaticMesh: StaticMesh;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): StaticMeshSocket;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): StaticMeshSocket;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshSocket;
	static C(Other: UObject): StaticMeshSocket;
}

declare class BoxSphereBounds { 
	Origin: Vector;
	BoxExtent: Vector;
	SphereRadius: number;
}

declare class NavCollisionCylinder { 
	Offset: Vector;
	Radius: number;
	Height: number;
}

declare class NavCollisionBox { 
	Offset: Vector;
	Extent: Vector;
}

declare class NavCollision extends UObject { 
	CylinderCollision: NavCollisionCylinder[];
	BoxCollision: NavCollisionBox[];
	AreaClass: UnrealEngineClass;
	bIsDynamicObstacle: boolean;
	bGatherConvexGeometry: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavCollision;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavCollision;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavCollision;
	static C(Other: UObject): NavCollision;
}

declare class StaticMesh extends UObject { 
	SourceModels: StaticMeshSourceModel[];
	AutoLODPixelError: number;
	LODGroup: string;
	bAutoComputeLODScreenSize: boolean;
	MinLOD: number;
	Materials: MaterialInterface[];
	LightMapResolution: number;
	LightMapCoordinateIndex: number;
	BodySetup: BodySetup;
	bUseMaximumStreamingTexelRatio: boolean;
	bStripComplexCollisionForConsole: boolean;
	bHasNavigationData: boolean;
	StreamingDistanceMultiplier: number;
	LpvBiasMultiplier: number;
	AssetImportData: AssetImportData;
	SourceFilePath: string;
	SourceFileTimestamp: string;
	ThumbnailInfo: ThumbnailInfo;
	EditorCameraPosition: AssetEditorOrbitCameraPosition;
	bCustomizedCollision: boolean;
	Sockets: StaticMeshSocket[];
	PositiveBoundsExtension: Vector;
	NegativeBoundsExtension: Vector;
	ExtendedBounds: BoxSphereBounds;
	ElementToIgnoreForTexFactor: number;
	AssetUserData: AssetUserData[];
	NavCollision: NavCollision;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): StaticMesh;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): StaticMesh;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMesh;
	static C(Other: UObject): StaticMesh;
	GetBoundingBox(): Box;
}

declare class PackedNormal { 
	X: number;
	Y: number;
	Z: number;
	W: number;
}

declare class PaintedVertex { 
	Position: Vector;
	Normal: PackedNormal;
	Color: Color;
}

declare class StaticMeshComponentLODInfo { 
	PaintedVertices: PaintedVertex[];
}

declare class LightmassPrimitiveSettings { 
	bUseTwoSidedLighting: boolean;
	bShadowIndirectOnly: boolean;
	bUseEmissiveForStaticLighting: boolean;
	bUseVertexNormalForHemisphereGather: boolean;
	EmissiveLightFalloffExponent: number;
	EmissiveLightExplicitInfluenceRadius: number;
	EmissiveBoost: number;
	DiffuseBoost: number;
	FullyOccludedSamplesFraction: number;
}

declare class StaticMeshComponent extends MeshComponent { 
	ForcedLodModel: number;
	PreviousLODLevel: number;
	bOverrideMinLOD: boolean;
	MinLOD: number;
	StaticMesh: StaticMesh;
	bOverrideWireframeColor: boolean;
	WireframeColorOverride: Color;
	SelectedEditorSection: number;
	bIgnoreInstanceForTextureStreaming: boolean;
	bOverrideLightMapRes: boolean;
	OverriddenLightMapRes: number;
	StreamingDistanceMultiplier: number;
	SubDivisionStepSize: number;
	bUseSubDivisions: boolean;
	IrrelevantLights: Guid[];
	LODData: StaticMeshComponentLODInfo[];
	StaticMeshDerivedDataKey: string;
	LightmassSettings: LightmassPrimitiveSettings;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): StaticMeshComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): StaticMeshComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshComponent;
	static C(Other: UObject): StaticMeshComponent;
	SetStaticMesh(NewMesh: StaticMesh): boolean;
	SetForcedLodModel(NewForcedLodModel: number): void;
	OnRep_StaticMesh(OldStaticMesh: StaticMesh): void;
	GetLocalBounds(Min?: Vector,Max?: Vector): {Min: Vector, Max: Vector};
}

declare class DefaultPawn extends Pawn { 
	BaseTurnRate: number;
	BaseLookUpRate: number;
	MovementComponent: PawnMovementComponent;
	CollisionComponent: SphereComponent;
	MeshComponent: StaticMeshComponent;
	bAddDefaultMovementBindings: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DefaultPawn;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DefaultPawn;
	static C(Other: UObject): DefaultPawn;
	TurnAtRate(Rate: number): void;
	Turn(Val: number): void;
	MoveUp_World(Val: number): void;
	MoveRight(Val: number): void;
	MoveForward(Val: number): void;
	LookUpAtRate(Rate: number): void;
	LookUp(Val: number): void;
}

declare class SpectatorPawn extends DefaultPawn { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SpectatorPawn;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpectatorPawn;
	static C(Other: UObject): SpectatorPawn;
}

declare class GameClassShortName { 
	ShortName: string;
	GameClassName: string;
}

declare class GameMode extends Info { 
	bUseSeamlessTravel: boolean;
	bPauseable: boolean;
	bStartPlayersAsSpectators: boolean;
	bDelayedStart: boolean;
	OptionsString: string;
	DefaultPawnClass: UnrealEngineClass;
	HUDClass: UnrealEngineClass;
	NumSpectators: number;
	NumPlayers: number;
	NumBots: number;
	MinRespawnDelay: number;
	GameSession: GameSession;
	NumTravellingPlayers: number;
	DefaultPlayerName: string;
	EngineMessageClass: UnrealEngineClass;
	PlayerControllerClass: UnrealEngineClass;
	SpectatorClass: UnrealEngineClass;
	ReplaySpectatorPlayerControllerClass: UnrealEngineClass;
	PlayerStateClass: UnrealEngineClass;
	GameStateClass: UnrealEngineClass;
	GameState: GameState;
	InactivePlayerArray: PlayerState[];
	GameModeClassAliases: GameClassShortName[];
	InactivePlayerStateLifeSpan: number;
	bHandleDedicatedServerReplays: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameMode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameMode;
	static C(Other: UObject): GameMode;
	HandleSeamlessTravelPlayer(C?: Controller): {C: Controller};
	StartPlay(): void;
	StartMatch(): void;
	SpawnDefaultPawnFor(NewPlayer: Controller,StartSpot: Actor): Pawn;
	ShouldReset(ActorToReset: Actor): boolean;
	SetBandwidthLimit(AsyncIOBandwidthLimit: number): void;
	ReturnToMainMenuHost(): void;
	RestartGame(): void;
	ResetLevel(): void;
	ReadyToStartMatch(): boolean;
	ReadyToEndMatch(): boolean;
	PlayerCanRestart(Player: PlayerController): boolean;
	MustSpectate(NewPlayerController: PlayerController): boolean;
	OnPostLogin(NewPlayer: PlayerController): void;
	OnSwapPlayerControllers(OldPC: PlayerController,NewPC: PlayerController): void;
	OnSetMatchState(NewState: string): void;
	OnRestartPlayer(NewPlayer: Controller): void;
	OnLogout(ExitingController: Controller): void;
	OnChangeName(Other: Controller,NewName: string,bNameChange: boolean): void;
	FindPlayerStart(Player: Controller): Actor;
	IsMatchInProgress(): boolean;
	InitStartSpot(StartSpot: Actor,NewPlayer: Controller): void;
	HasMatchStarted(): boolean;
	HasMatchEnded(): boolean;
	GetNumPlayers(): number;
	GetMatchState(): string;
	GetDefaultPawnClassForController(InController: Controller): UnrealEngineClass;
	FindPlayerStart(Player: Controller,IncomingName: string): Actor;
	EndMatch(): void;
	ChoosePlayerStart(Player: Controller): Actor;
	ChangeName(Controller: Controller,NewName: string,bNameChange: boolean): void;
	CanSpectate(Viewer: PlayerController,ViewTarget: PlayerState): boolean;
	AbortMatch(): void;
}

declare class GameState extends Info { 
	GameModeClass: UnrealEngineClass;
	AuthorityGameMode: GameMode;
	SpectatorClass: UnrealEngineClass;
	MatchState: string;
	PreviousMatchState: string;
	ElapsedTime: number;
	PlayerArray: PlayerState[];
	ReplicatedWorldTimeSeconds: number;
	ServerWorldTimeSecondsDelta: number;
	ServerWorldTimeSecondsUpdateFrequency: number;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameState;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameState;
	static C(Other: UObject): GameState;
	OnRep_SpectatorClass(): void;
	OnRep_ReplicatedWorldTimeSeconds(): void;
	OnRep_MatchState(): void;
	OnRep_GameModeClass(): void;
	OnRep_ElapsedTime(): void;
	GetServerWorldTimeSeconds(): number;
}

declare class GameNetworkManager extends Info { 
	AdjustedNetSpeed: number;
	LastNetSpeedUpdateTime: number;
	TotalNetBandwidth: number;
	MinDynamicBandwidth: number;
	MaxDynamicBandwidth: number;
	bIsStandbyCheckingEnabled: boolean;
	bHasStandbyCheatTriggered: boolean;
	StandbyRxCheatTime: number;
	StandbyTxCheatTime: number;
	BadPingThreshold: number;
	PercentMissingForRxStandby: number;
	PercentMissingForTxStandby: number;
	PercentForBadPing: number;
	JoinInProgressStandbyWaitTime: number;
	MoveRepSize: number;
	MAXPOSITIONERRORSQUARED: number;
	MAXNEARZEROVELOCITYSQUARED: number;
	CLIENTADJUSTUPDATECOST: number;
	MAXCLIENTUPDATEINTERVAL: number;
	ClientAuthorativePosition: boolean;
	bUseDistanceBasedRelevancy: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameNetworkManager;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameNetworkManager;
	static C(Other: UObject): GameNetworkManager;
}

declare type EAudioOutputTarget = string;
declare class SoundClassProperties { 
	Volume: number;
	Pitch: number;
	StereoBleed: number;
	LFEBleed: number;
	VoiceCenterChannelVolume: number;
	RadioFilterVolume: number;
	RadioFilterVolumeThreshold: number;
	bApplyEffects: boolean;
	bAlwaysPlay: boolean;
	bIsUISound: boolean;
	bIsMusic: boolean;
	bReverb: boolean;
	bCenterChannelOnly: boolean;
	bApplyAmbientVolumes: boolean;
	OutputTarget: EAudioOutputTarget;
}

declare class AudioEQEffect { 
	HFFrequency: number;
	HFGain: number;
	MFCutoffFrequency: number;
	MFBandwidth: number;
	MFGain: number;
	LFFrequency: number;
	LFGain: number;
}

declare class SoundClassAdjuster { 
	SoundClassObject: SoundClass;
	VolumeAdjuster: number;
	PitchAdjuster: number;
	bApplyToChildren: boolean;
	VoiceCenterChannelVolumeAdjuster: number;
}

declare class SoundMix extends UObject { 
	bApplyEQ: boolean;
	EQPriority: number;
	EQSettings: AudioEQEffect;
	SoundClassEffects: SoundClassAdjuster[];
	InitialDelay: number;
	FadeInTime: number;
	Duration: number;
	FadeOutTime: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundMix;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundMix;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundMix;
	static C(Other: UObject): SoundMix;
}

declare class PassiveSoundMixModifier { 
	SoundMix: SoundMix;
	MinVolumeThreshold: number;
	MaxVolumeThreshold: number;
}

declare class SoundClass extends UObject { 
	Properties: SoundClassProperties;
	ChildClasses: SoundClass[];
	PassiveSoundMixModifiers: PassiveSoundMixModifier[];
	ParentClass: SoundClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundClass;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundClass;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundClass;
	static C(Other: UObject): SoundClass;
}

declare type EMaxConcurrentResolutionRule = string;
declare type ESoundDistanceModel = string;
declare class RuntimeFloatCurve { 
	EditorCurveData: RichCurve;
	ExternalCurve: CurveFloat;
}

declare type ESoundDistanceCalc = string;
declare type EAttenuationShape = string;
declare type ESoundSpatializationAlgorithm = string;
declare class AttenuationSettings { 
	bAttenuate: boolean;
	bSpatialize: boolean;
	bAttenuateWithLPF: boolean;
	DistanceAlgorithm: ESoundDistanceModel;
	CustomAttenuationCurve: RuntimeFloatCurve;
	DistanceType: ESoundDistanceCalc;
	AttenuationShape: EAttenuationShape;
	dBAttenuationAtMax: number;
	OmniRadius: number;
	SpatializationAlgorithm: ESoundSpatializationAlgorithm;
	RadiusMin: number;
	RadiusMax: number;
	AttenuationShapeExtents: Vector;
	ConeOffset: number;
	FalloffDistance: number;
	LPFRadiusMin: number;
	LPFRadiusMax: number;
}

declare class SoundAttenuation extends UObject { 
	Attenuation: AttenuationSettings;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundAttenuation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundAttenuation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundAttenuation;
	static C(Other: UObject): SoundAttenuation;
}

declare type ESoundGroup = string;
declare class SubtitleCue { 
	Text: string;
	Time: number;
}

declare class LocalizedSubtitle { 
	LanguageExt: string;
	Subtitles: SubtitleCue[];
	bMature: boolean;
	bManualWordWrap: boolean;
	bSingleLine: boolean;
}

declare class SoundWave extends SoundBase { 
	CompressionQuality: number;
	bLooping: boolean;
	bStreaming: boolean;
	StreamingPriority: number;
	bMature: boolean;
	bManualWordWrap: boolean;
	bSingleLine: boolean;
	SoundGroup: ESoundGroup;
	SpokenText: string;
	Volume: number;
	Pitch: number;
	NumChannels: number;
	SampleRate: number;
	ChannelOffsets: number[];
	ChannelSizes: number[];
	RawPCMDataSize: number;
	Subtitles: SubtitleCue[];
	Comment: string;
	LocalizedSubtitles: LocalizedSubtitle[];
	SourceFilePath: string;
	SourceFileTimestamp: string;
	AssetImportData: AssetImportData;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundWave;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundWave;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundWave;
	static C(Other: UObject): SoundWave;
}

declare class AudioComponentParam { 
	ParamName: string;
	FloatParam: number;
	BoolParam: boolean;
	IntParam: number;
	SoundWaveParam: SoundWave;
}

declare class AudioComponent extends SceneComponent { 
	Sound: SoundBase;
	InstanceParameters: AudioComponentParam[];
	SoundClassOverride: SoundClass;
	bAutoDestroy: boolean;
	bStopWhenOwnerDestroyed: boolean;
	bShouldRemainActiveIfDropped: boolean;
	bAllowSpatialization: boolean;
	bOverrideAttenuation: boolean;
	bIsUISound: boolean;
	PitchModulationMin: number;
	PitchModulationMax: number;
	VolumeModulationMin: number;
	VolumeModulationMax: number;
	VolumeMultiplier: number;
	PitchMultiplier: number;
	HighFrequencyGainMultiplier: number;
	AttenuationSettings: SoundAttenuation;
	AttenuationOverrides: AttenuationSettings;
	OnAudioFinished: UnrealEngineMulticastDelegate<() => void>;
	OnQueueSubtitles: UnrealEngineDelegate<(Subtitles: SubtitleCue[], CueDuration: number) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AudioComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AudioComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioComponent;
	static C(Other: UObject): AudioComponent;
	Stop(): void;
	SetWaveParameter(InName: string,InWave: SoundWave): void;
	SetVolumeMultiplier(NewVolumeMultiplier: number): void;
	SetUISound(bInUISound: boolean): void;
	SetSound(NewSound: SoundBase): void;
	SetPitchMultiplier(NewPitchMultiplier: number): void;
	SetIntegerParameter(InName: string,InInt: number): void;
	SetFloatParameter(InName: string,InFloat: number): void;
	SetBooleanParameter(InName: string,InBool: boolean): void;
	Play(StartTime: number): void;
	IsPlaying(): boolean;
	FadeOut(FadeOutDuration: number,FadeVolumeLevel: number): void;
	FadeIn(FadeInDuration: number,FadeVolumeLevel: number,StartTime: number): void;
	GetAttenuationSettingsToApply(OutAttenuationSettings?: AttenuationSettings): {OutAttenuationSettings: AttenuationSettings, $: boolean};
	AdjustVolume(AdjustVolumeDuration: number,AdjustVolumeLevel: number): void;
	AdjustAttenuation(InAttenuationSettings: AttenuationSettings): void;
}

declare class SoundBase extends UObject { 
	SoundClassObject: SoundClass;
	bDebug: boolean;
	MaxConcurrentResolutionRule: EMaxConcurrentResolutionRule;
	MaxConcurrentPlayCount: number;
	Duration: number;
	AttenuationSettings: SoundAttenuation;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundBase;
	static C(Other: UObject): SoundBase;
	SpawnSoundAttached(AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bStopWhenAttachedToDestroyed: boolean,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation): AudioComponent;
}

declare class PhysicsCollisionHandler extends UObject { 
	ImpactThreshold: number;
	ImpactReFireDelay: number;
	DefaultImpactSound: SoundBase;
	LastImpactSoundTime: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PhysicsCollisionHandler;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PhysicsCollisionHandler;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsCollisionHandler;
	static C(Other: UObject): PhysicsCollisionHandler;
}

declare type EStreamingVolumeUsage = string;
declare class LevelStreamingVolume extends Volume { 
	StreamingLevelNames: string[];
	bEditorPreVisOnly: boolean;
	bDisabled: boolean;
	StreamingUsage: EStreamingVolumeUsage;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelStreamingVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelStreamingVolume;
	static C(Other: UObject): LevelStreamingVolume;
}

declare class LevelStreaming extends UObject { 
	PackageName: string;
	WorldAsset: any;
	PackageNameToLoad: string;
	LODPackageNames: string[];
	LevelTransform: Transform;
	bShouldBeVisibleInEditor: boolean;
	bLocked: boolean;
	bShouldBeLoaded: boolean;
	bShouldBeVisible: boolean;
	bShouldBlockOnLoad: boolean;
	LevelLODIndex: number;
	bDisableDistanceStreaming: boolean;
	bDrawOnLevelStatusMap: boolean;
	DrawColor: Color;
	LevelColor: LinearColor;
	EditorStreamingVolumes: LevelStreamingVolume[];
	MinTimeBetweenVolumeUnloadRequests: number;
	Keywords: string[];
	OnLevelLoaded: UnrealEngineMulticastDelegate<() => void>;
	OnLevelUnloaded: UnrealEngineMulticastDelegate<() => void>;
	OnLevelShown: UnrealEngineMulticastDelegate<() => void>;
	OnLevelHidden: UnrealEngineMulticastDelegate<() => void>;
	LoadedLevel: Level;
	PendingUnloadLevel: Level;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelStreaming;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelStreaming;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelStreaming;
	static C(Other: UObject): LevelStreaming;
	IsStreamingStatePending(): boolean;
	IsLevelVisible(): boolean;
	IsLevelLoaded(): boolean;
	GetLevelScriptActor(): LevelScriptActor;
	CreateInstance(UniqueInstanceName: string): LevelStreaming;
}

declare class DemoNetDriver extends NetDriver { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DemoNetDriver;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DemoNetDriver;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DemoNetDriver;
	static C(Other: UObject): DemoNetDriver;
}

declare class ParticleEventManager extends Actor { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleEventManager;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleEventManager;
	static C(Other: UObject): ParticleEventManager;
}

declare class BlueprintFunctionLibrary extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintFunctionLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintFunctionLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintFunctionLibrary;
	static C(Other: UObject): BlueprintFunctionLibrary;
}

declare class StringClassReference extends StringAssetReference { 
}

declare class NavDataConfig extends NavAgentProperties { 
	Name: string;
	Color: Color;
	DefaultQueryExtent: Vector;
	NavigationDataClass: UnrealEngineClass;
	NavigationDataClassName: StringClassReference;
}

declare type ERuntimeGenerationType = string;
declare class SupportedAreaData { 
	AreaClassName: string;
	AreaID: number;
	AreaClass: UnrealEngineClass;
}

declare class NavigationData extends Actor { 
	RenderingComp: PrimitiveComponent;
	NavDataConfig: NavDataConfig;
	bEnableDrawing: boolean;
	bRebuildAtRuntime: boolean;
	RuntimeGeneration: ERuntimeGenerationType;
	bForceRebuildOnLoad: boolean;
	ObservedPathsTickInterval: number;
	SupportedAreas: SupportedAreaData[];
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavigationData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationData;
	static C(Other: UObject): NavigationData;
}

declare type ENavDataGatheringModeConfig = string;
declare type FNavigationSystemRunMode = string;
declare class NavigationFilterArea { 
	AreaClass: UnrealEngineClass;
	TravelCostOverride: number;
	EnteringCostOverride: number;
	bIsExcluded: boolean;
	bOverrideTravelCost: boolean;
	bOverrideEnteringCost: boolean;
}

declare class NavigationFilterFlags { 
	bNavFlag0: boolean;
	bNavFlag1: boolean;
	bNavFlag2: boolean;
	bNavFlag3: boolean;
	bNavFlag4: boolean;
	bNavFlag5: boolean;
	bNavFlag6: boolean;
	bNavFlag7: boolean;
	bNavFlag8: boolean;
	bNavFlag9: boolean;
	bNavFlag10: boolean;
	bNavFlag11: boolean;
	bNavFlag12: boolean;
	bNavFlag13: boolean;
	bNavFlag14: boolean;
	bNavFlag15: boolean;
}

declare class NavigationQueryFilter extends UObject { 
	Areas: NavigationFilterArea[];
	IncludeFlags: NavigationFilterFlags;
	ExcludeFlags: NavigationFilterFlags;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavigationQueryFilter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavigationQueryFilter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationQueryFilter;
	static C(Other: UObject): NavigationQueryFilter;
}

declare class NavMeshBoundsVolume extends Volume { 
	SupportedAgents: NavAgentSelector;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavMeshBoundsVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavMeshBoundsVolume;
	static C(Other: UObject): NavMeshBoundsVolume;
}

declare type ENavigationQueryResult = string;
declare type ENavPathEvent = string;
declare type ENavigationOptionFlag = string;
declare class NavigationPath extends UObject { 
	PathUpdatedNotifier: UnrealEngineMulticastDelegate<(AffectedPath: NavigationPath, PathEvent: ENavPathEvent) => void>;
	PathPoints: Vector[];
	RecalculateOnInvalidation: ENavigationOptionFlag;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavigationPath;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavigationPath;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationPath;
	static C(Other: UObject): NavigationPath;
	IsValid(): boolean;
	IsStringPulled(): boolean;
	IsPartial(): boolean;
	GetPathLength(): number;
	GetPathCost(): number;
	GetDebugString(): string;
	EnableRecalculationOnInvalidation(DoRecalculation: ENavigationOptionFlag): void;
	EnableDebugDrawing(bShouldDrawDebugData: boolean,PathColor: LinearColor): void;
}

declare class NavigationSystem extends BlueprintFunctionLibrary { 
	MainNavData: NavigationData;
	AbstractNavData: NavigationData;
	bAutoCreateNavigationData: boolean;
	bAllowClientSideNavigation: boolean;
	bSupportRebuilding: boolean;
	bInitialBuildingLocked: boolean;
	bSkipAgentHeightCheckWhenPickingNavData: boolean;
	DataGatheringMode: ENavDataGatheringModeConfig;
	bGenerateNavigationOnlyAroundNavigationInvokers: boolean;
	ActiveTilesUpdateInterval: number;
	SupportedAgents: NavDataConfig[];
	DirtyAreasUpdateFreq: number;
	NavDataSet: NavigationData[];
	NavDataRegistrationQueue: NavigationData[];
	OnNavDataRegisteredEvent: UnrealEngineMulticastDelegate<(NavData: NavigationData) => void>;
	OnNavigationGenerationFinishedDelegate: UnrealEngineMulticastDelegate<(NavData: NavigationData) => void>;
	OperationMode: FNavigationSystemRunMode;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavigationSystem;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavigationSystem;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationSystem;
	static C(Other: UObject): NavigationSystem;
	UnregisterNavigationInvoker(Invoker: Actor): void;
	static SimpleMoveToLocation(Controller: Controller,Goal: Vector): void;
	static SimpleMoveToActor(Controller: Controller,Goal: Actor): void;
	SetMaxSimultaneousTileGenerationJobsCount(MaxNumberOfJobs: number): void;
	SetGeometryGatheringMode(NewMode: ENavDataGatheringModeConfig): void;
	ResetMaxSimultaneousTileGenerationJobsCount(): void;
	RegisterNavigationInvoker(Invoker: Actor,TileGenerationRadius: number,TileRemovalRadius: number): void;
	static ProjectPointToNavigation(WorldContext: UObject,Point: Vector,NavData: NavigationData,FilterClass: UnrealEngineClass,QueryExtent: Vector): Vector;
	OnNavigationBoundsUpdated(NavVolume: NavMeshBoundsVolume): void;
	static NavigationRaycast(WorldContext: UObject,RayStart: Vector,RayEnd: Vector,HitLocation?: Vector,FilterClass?: UnrealEngineClass,Querier?: Controller): {HitLocation: Vector, $: boolean};
	static IsNavigationBeingBuilt(WorldContext: UObject): boolean;
	static GetRandomReachablePointInRadius(WorldContext: UObject,Origin: Vector,Radius: number,NavData: NavigationData,FilterClass: UnrealEngineClass): Vector;
	static GetRandomPointInRadius(WorldContext: UObject,Origin: Vector,Radius: number,NavData: NavigationData,FilterClass: UnrealEngineClass): Vector;
	static GetRandomPointInNavigableRadius(WorldContext: UObject,Origin: Vector,Radius: number,NavData: NavigationData,FilterClass: UnrealEngineClass): Vector;
	static GetRandomPoint(WorldContext: UObject,NavData: NavigationData,FilterClass: UnrealEngineClass): Vector;
	static GetPathLength(WorldContext: UObject,PathStart: Vector,PathEnd: Vector,PathLength?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {PathLength: number, $: ENavigationQueryResult};
	static GetPathCost(WorldContext: UObject,PathStart: Vector,PathEnd: Vector,PathCost?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {PathCost: number, $: ENavigationQueryResult};
	static GetNavigationSystem(WorldContext: UObject): NavigationSystem;
	static FindPathToLocationSynchronously(WorldContext: UObject,PathStart: Vector,PathEnd: Vector,PathfindingContext: Actor,FilterClass: UnrealEngineClass): NavigationPath;
	static FindPathToActorSynchronously(WorldContext: UObject,PathStart: Vector,GoalActor: Actor,TetherDistance: number,PathfindingContext: Actor,FilterClass: UnrealEngineClass): NavigationPath;
}

declare class AISystemBase extends UObject { 
	AISystemClassName: StringClassReference;
	AISystemModuleName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISystemBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISystemBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISystemBase;
	static C(Other: UObject): AISystemBase;
}

declare class NavAvoidanceData { 
}

declare class AvoidanceManager extends UObject { 
	DefaultTimeToLive: number;
	LockTimeAfterAvoid: number;
	LockTimeAfterClean: number;
	DeltaTimeToPredict: number;
	ArtificialRadiusExpansion: number;
	TestHeightDifference: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AvoidanceManager;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AvoidanceManager;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AvoidanceManager;
	static C(Other: UObject): AvoidanceManager;
	RegisterMovementComponent(MovementComp: MovementComponent,AvoidanceWeight: number): boolean;
	GetObjectCount(): number;
	GetNewAvoidanceUID(): number;
	GetAvoidanceVelocityIgnoringUID(AvoidanceData: NavAvoidanceData,DeltaTime: number,IgnoreThisUID: number): Vector;
	GetAvoidanceVelocityForComponent(MovementComp: MovementComponent): Vector;
	GetAvoidanceVelocity(AvoidanceData: NavAvoidanceData,DeltaTime: number): Vector;
}

declare class ScriptViewportClient extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ScriptViewportClient;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ScriptViewportClient;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScriptViewportClient;
	static C(Other: UObject): ScriptViewportClient;
}

declare class Console extends UObject { 
	ConsoleTargetPlayer: LocalPlayer;
	DefaultTexture_Black: Texture2D;
	DefaultTexture_White: Texture2D;
	HistoryBuffer: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Console;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Console;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Console;
	static C(Other: UObject): Console;

	assert(test?: boolean, message?: string, ...optionalParams: any[]): void;
    clear(): void;
    count(countTitle?: string): void;
    debug(message?: string, ...optionalParams: any[]): void;
    dir(value?: any, ...optionalParams: any[]): void;
    dirxml(value: any): void;
    error(message?: any, ...optionalParams: any[]): void;
    exception(message?: string, ...optionalParams: any[]): void;
    group(groupTitle?: string): void;
    groupCollapsed(groupTitle?: string): void;
    groupEnd(): void;
    info(message?: any, ...optionalParams: any[]): void;
    log(message?: any, ...optionalParams: any[]): void;
    profile(reportName?: string): void;
    profileEnd(): void;
    table(...data: any[]): void;
    time(timerName?: string): void;
    timeEnd(timerName?: string): void;
    trace(message?: any, ...optionalParams: any[]): void;
    warn(message?: any, ...optionalParams: any[]): void;
}

declare class DebugDisplayProperty { 
	Obj: UObject;
	WithinClass: UnrealEngineClass;
}

declare class GameViewportClient extends ScriptViewportClient { 
	ViewportConsole: Console;
	DebugProperties: DebugDisplayProperty[];
	World: World;
	GameInstance: GameInstance;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameViewportClient;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameViewportClient;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameViewportClient;
	static C(Other: UObject): GameViewportClient;
	SSSwapControllers(): void;
	ShowTitleSafeArea(): void;
	SetConsoleTarget(PlayerIndex: number): void;
}

declare type EAspectRatioAxisConstraint = string;
declare class LocalPlayer extends Player { 
	ViewportClient: GameViewportClient;
	AspectRatioAxisConstraint: EAspectRatioAxisConstraint;
	PendingLevelPlayerControllerClass: UnrealEngineClass;
	bSentSplitJoin: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LocalPlayer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LocalPlayer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalPlayer;
	static C(Other: UObject): LocalPlayer;
}

declare class OnlineSession extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): OnlineSession;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): OnlineSession;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineSession;
	static C(Other: UObject): OnlineSession;
}

declare type ETravelFailure = string;
declare type ENetworkFailure = string;
declare class GameInstance extends UObject { 
	LocalPlayers: LocalPlayer[];
	OnlineSession: OnlineSession;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameInstance;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameInstance;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameInstance;
	static C(Other: UObject): GameInstance;
	Shutdown(): void;
	Init(): void;
	TravelError(FailureType: ETravelFailure): void;
	NetworkError(FailureType: ENetworkFailure,bIsServer: boolean): void;
	DebugRemovePlayer(ControllerId: number): void;
	DebugCreatePlayer(ControllerId: number): void;
}

declare class MaterialParameterCollectionInstance extends UObject { 
	Collection: MaterialParameterCollection;
	World: World;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialParameterCollectionInstance;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialParameterCollectionInstance;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialParameterCollectionInstance;
	static C(Other: UObject): MaterialParameterCollectionInstance;
}

declare class LevelViewportInfo { 
	CamPosition: Vector;
	CamRotation: Rotator;
	CamOrthoZoom: number;
	CamUpdated: boolean;
}

declare class WorldComposition extends UObject { 
	TilesStreaming: LevelStreaming[];
	TilesStreamingTimeThreshold: any;
	bLoadAllTilesDuringCinematic: boolean;
	bRebaseOriginIn3DSpace: boolean;
	RebaseOriginDistance: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WorldComposition;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WorldComposition;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldComposition;
	static C(Other: UObject): WorldComposition;
}

declare type ETraceTypeQuery = string;
declare type EDrawDebugTrace = string;
declare class LatentActionInfo { 
	Linkage: number;
	UUID: number;
	ExecutionFunction: string;
	CallbackTarget: UObject;
}

declare class DebugFloatHistory { 
	Samples: number[];
	MaxSamples: number;
	MinValue: number;
	MaxValue: number;
	bAutoAdjustMinMax: boolean;
}

declare type EQuitPreference = string;
declare class ReverbEffect extends UObject { 
	Density: number;
	Diffusion: number;
	Gain: number;
	GainHF: number;
	DecayTime: number;
	DecayHFRatio: number;
	ReflectionsGain: number;
	ReflectionsDelay: number;
	LateGain: number;
	LateDelay: number;
	AirAbsorptionGainHF: number;
	RoomRolloffFactor: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReverbEffect;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReverbEffect;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReverbEffect;
	static C(Other: UObject): ReverbEffect;
}

declare class DamageType extends UObject { 
	bCausedByWorld: boolean;
	bScaleMomentumByMass: boolean;
	DamageImpulse: number;
	bRadialDamageVelChange: boolean;
	DestructibleImpulse: number;
	DestructibleDamageSpreadScale: number;
	DamageFalloff: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DamageType;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DamageType;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DamageType;
	static C(Other: UObject): DamageType;
}

declare type ESpawnActorCollisionHandlingMethod = string;
declare type ESuggestProjVelocityTraceOption = string;
declare type ECameraProjectionMode = string;
declare class TextureCube extends Texture { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextureCube;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextureCube;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureCube;
	static C(Other: UObject): TextureCube;
}

declare type EDepthOfFieldMethod = string;
declare type EAntiAliasingMethod = string;
declare class WeightedBlendable { 
	Weight: number;
	UObject: UObject;
}

declare class WeightedBlendables { 
	Array: WeightedBlendable[];
}

declare class PostProcessSettings { 
	bOverride_WhiteTemp: boolean;
	bOverride_WhiteTint: boolean;
	bOverride_ColorSaturation: boolean;
	bOverride_ColorContrast: boolean;
	bOverride_ColorGamma: boolean;
	bOverride_ColorGain: boolean;
	bOverride_ColorOffset: boolean;
	bOverride_FilmWhitePoint: boolean;
	bOverride_FilmSaturation: boolean;
	bOverride_FilmChannelMixerRed: boolean;
	bOverride_FilmChannelMixerGreen: boolean;
	bOverride_FilmChannelMixerBlue: boolean;
	bOverride_FilmContrast: boolean;
	bOverride_FilmDynamicRange: boolean;
	bOverride_FilmHealAmount: boolean;
	bOverride_FilmToeAmount: boolean;
	bOverride_FilmShadowTint: boolean;
	bOverride_FilmShadowTintBlend: boolean;
	bOverride_FilmShadowTintAmount: boolean;
	bOverride_FilmSlope: boolean;
	bOverride_FilmToe: boolean;
	bOverride_FilmShoulder: boolean;
	bOverride_FilmBlackClip: boolean;
	bOverride_FilmWhiteClip: boolean;
	bOverride_SceneColorTint: boolean;
	bOverride_SceneFringeIntensity: boolean;
	bOverride_SceneFringeSaturation: boolean;
	bOverride_AmbientCubemapTint: boolean;
	bOverride_AmbientCubemapIntensity: boolean;
	bOverride_BloomIntensity: boolean;
	bOverride_BloomThreshold: boolean;
	bOverride_Bloom1Tint: boolean;
	bOverride_Bloom1Size: boolean;
	bOverride_Bloom2Size: boolean;
	bOverride_Bloom2Tint: boolean;
	bOverride_Bloom3Tint: boolean;
	bOverride_Bloom3Size: boolean;
	bOverride_Bloom4Tint: boolean;
	bOverride_Bloom4Size: boolean;
	bOverride_Bloom5Tint: boolean;
	bOverride_Bloom5Size: boolean;
	bOverride_Bloom6Tint: boolean;
	bOverride_Bloom6Size: boolean;
	bOverride_BloomSizeScale: boolean;
	bOverride_BloomDirtMaskIntensity: boolean;
	bOverride_BloomDirtMaskTint: boolean;
	bOverride_BloomDirtMask: boolean;
	bOverride_AutoExposureLowPercent: boolean;
	bOverride_AutoExposureHighPercent: boolean;
	bOverride_AutoExposureMinBrightness: boolean;
	bOverride_AutoExposureMaxBrightness: boolean;
	bOverride_AutoExposureSpeedUp: boolean;
	bOverride_AutoExposureSpeedDown: boolean;
	bOverride_AutoExposureBias: boolean;
	bOverride_HistogramLogMin: boolean;
	bOverride_HistogramLogMax: boolean;
	bOverride_LensFlareIntensity: boolean;
	bOverride_LensFlareTint: boolean;
	bOverride_LensFlareTints: boolean;
	bOverride_LensFlareBokehSize: boolean;
	bOverride_LensFlareBokehShape: boolean;
	bOverride_LensFlareThreshold: boolean;
	bOverride_VignetteIntensity: boolean;
	bOverride_GrainIntensity: boolean;
	bOverride_GrainJitter: boolean;
	bOverride_AmbientOcclusionIntensity: boolean;
	bOverride_AmbientOcclusionStaticFraction: boolean;
	bOverride_AmbientOcclusionRadius: boolean;
	bOverride_AmbientOcclusionFadeDistance: boolean;
	bOverride_AmbientOcclusionFadeRadius: boolean;
	bOverride_AmbientOcclusionDistance: boolean;
	bOverride_AmbientOcclusionRadiusInWS: boolean;
	bOverride_AmbientOcclusionPower: boolean;
	bOverride_AmbientOcclusionBias: boolean;
	bOverride_AmbientOcclusionQuality: boolean;
	bOverride_AmbientOcclusionMipBlend: boolean;
	bOverride_AmbientOcclusionMipScale: boolean;
	bOverride_AmbientOcclusionMipThreshold: boolean;
	bOverride_LPVIntensity: boolean;
	bOverride_LPVDirectionalOcclusionIntensity: boolean;
	bOverride_LPVDirectionalOcclusionRadius: boolean;
	bOverride_LPVDiffuseOcclusionExponent: boolean;
	bOverride_LPVSpecularOcclusionExponent: boolean;
	bOverride_LPVDiffuseOcclusionIntensity: boolean;
	bOverride_LPVSpecularOcclusionIntensity: boolean;
	bOverride_LPVSize: boolean;
	bOverride_LPVSecondaryOcclusionIntensity: boolean;
	bOverride_LPVSecondaryBounceIntensity: boolean;
	bOverride_LPVGeometryVolumeBias: boolean;
	bOverride_LPVVplInjectionBias: boolean;
	bOverride_LPVEmissiveInjectionIntensity: boolean;
	bOverride_IndirectLightingColor: boolean;
	bOverride_IndirectLightingIntensity: boolean;
	bOverride_ColorGradingIntensity: boolean;
	bOverride_ColorGradingLUT: boolean;
	bOverride_DepthOfFieldFocalDistance: boolean;
	bOverride_DepthOfFieldFstop: boolean;
	bOverride_DepthOfFieldDepthBlurRadius: boolean;
	bOverride_DepthOfFieldDepthBlurAmount: boolean;
	bOverride_DepthOfFieldFocalRegion: boolean;
	bOverride_DepthOfFieldNearTransitionRegion: boolean;
	bOverride_DepthOfFieldFarTransitionRegion: boolean;
	bOverride_DepthOfFieldScale: boolean;
	bOverride_DepthOfFieldMaxBokehSize: boolean;
	bOverride_DepthOfFieldNearBlurSize: boolean;
	bOverride_DepthOfFieldFarBlurSize: boolean;
	bOverride_DepthOfFieldMethod: boolean;
	bOverride_DepthOfFieldBokehShape: boolean;
	bOverride_DepthOfFieldOcclusion: boolean;
	bOverride_DepthOfFieldColorThreshold: boolean;
	bOverride_DepthOfFieldSizeThreshold: boolean;
	bOverride_DepthOfFieldSkyFocusDistance: boolean;
	bOverride_MotionBlurAmount: boolean;
	bOverride_MotionBlurMax: boolean;
	bOverride_MotionBlurPerObjectSize: boolean;
	bOverride_ScreenPercentage: boolean;
	bOverride_AntiAliasingMethod: boolean;
	bOverride_ScreenSpaceReflectionIntensity: boolean;
	bOverride_ScreenSpaceReflectionQuality: boolean;
	bOverride_ScreenSpaceReflectionMaxRoughness: boolean;
	bOverride_ScreenSpaceReflectionRoughnessScale: boolean;
	WhiteTemp: number;
	WhiteTint: number;
	ColorSaturation: Vector;
	ColorContrast: Vector;
	ColorGamma: Vector;
	ColorGain: Vector;
	ColorOffset: Vector;
	FilmWhitePoint: LinearColor;
	FilmShadowTint: LinearColor;
	FilmShadowTintBlend: number;
	FilmShadowTintAmount: number;
	FilmSaturation: number;
	FilmChannelMixerRed: LinearColor;
	FilmChannelMixerGreen: LinearColor;
	FilmChannelMixerBlue: LinearColor;
	FilmContrast: number;
	FilmToeAmount: number;
	FilmHealAmount: number;
	FilmDynamicRange: number;
	FilmSlope: number;
	FilmToe: number;
	FilmShoulder: number;
	FilmBlackClip: number;
	FilmWhiteClip: number;
	SceneColorTint: LinearColor;
	SceneFringeIntensity: number;
	SceneFringeSaturation: number;
	BloomIntensity: number;
	BloomThreshold: number;
	BloomSizeScale: number;
	Bloom1Size: number;
	Bloom2Size: number;
	Bloom3Size: number;
	Bloom4Size: number;
	Bloom5Size: number;
	Bloom6Size: number;
	Bloom1Tint: LinearColor;
	Bloom2Tint: LinearColor;
	Bloom3Tint: LinearColor;
	Bloom4Tint: LinearColor;
	Bloom5Tint: LinearColor;
	Bloom6Tint: LinearColor;
	BloomDirtMaskIntensity: number;
	BloomDirtMaskTint: LinearColor;
	BloomDirtMask: Texture;
	LPVIntensity: number;
	LPVVplInjectionBias: number;
	LPVSize: number;
	LPVSecondaryOcclusionIntensity: number;
	LPVSecondaryBounceIntensity: number;
	LPVGeometryVolumeBias: number;
	LPVEmissiveInjectionIntensity: number;
	LPVDirectionalOcclusionIntensity: number;
	LPVDirectionalOcclusionRadius: number;
	LPVDiffuseOcclusionExponent: number;
	LPVSpecularOcclusionExponent: number;
	LPVDiffuseOcclusionIntensity: number;
	LPVSpecularOcclusionIntensity: number;
	AmbientCubemapTint: LinearColor;
	AmbientCubemapIntensity: number;
	AmbientCubemap: TextureCube;
	AutoExposureLowPercent: number;
	AutoExposureHighPercent: number;
	AutoExposureMinBrightness: number;
	AutoExposureMaxBrightness: number;
	AutoExposureSpeedUp: number;
	AutoExposureSpeedDown: number;
	AutoExposureBias: number;
	HistogramLogMin: number;
	HistogramLogMax: number;
	LensFlareIntensity: number;
	LensFlareTint: LinearColor;
	LensFlareBokehSize: number;
	LensFlareThreshold: number;
	LensFlareBokehShape: Texture;
	LensFlareTints: LinearColor;
	VignetteIntensity: number;
	GrainJitter: number;
	GrainIntensity: number;
	AmbientOcclusionIntensity: number;
	AmbientOcclusionStaticFraction: number;
	AmbientOcclusionRadius: number;
	AmbientOcclusionRadiusInWS: boolean;
	AmbientOcclusionFadeDistance: number;
	AmbientOcclusionFadeRadius: number;
	AmbientOcclusionDistance: number;
	AmbientOcclusionPower: number;
	AmbientOcclusionBias: number;
	AmbientOcclusionQuality: number;
	AmbientOcclusionMipBlend: number;
	AmbientOcclusionMipScale: number;
	AmbientOcclusionMipThreshold: number;
	IndirectLightingColor: LinearColor;
	IndirectLightingIntensity: number;
	ColorGradingIntensity: number;
	ColorGradingLUT: Texture;
	DepthOfFieldMethod: EDepthOfFieldMethod;
	DepthOfFieldDepthBlurAmount: number;
	DepthOfFieldDepthBlurRadius: number;
	DepthOfFieldFstop: number;
	DepthOfFieldFocalDistance: number;
	DepthOfFieldFocalRegion: number;
	DepthOfFieldNearTransitionRegion: number;
	DepthOfFieldFarTransitionRegion: number;
	DepthOfFieldScale: number;
	DepthOfFieldMaxBokehSize: number;
	DepthOfFieldNearBlurSize: number;
	DepthOfFieldFarBlurSize: number;
	DepthOfFieldBokehShape: Texture;
	DepthOfFieldOcclusion: number;
	DepthOfFieldColorThreshold: number;
	DepthOfFieldSizeThreshold: number;
	DepthOfFieldSkyFocusDistance: number;
	MotionBlurAmount: number;
	MotionBlurMax: number;
	MotionBlurPerObjectSize: number;
	ScreenPercentage: number;
	AntiAliasingMethod: EAntiAliasingMethod;
	ScreenSpaceReflectionIntensity: number;
	ScreenSpaceReflectionQuality: number;
	ScreenSpaceReflectionMaxRoughness: number;
	WeightedBlendables: WeightedBlendables;
	Blendables: UObject[];
}

declare class MinimalViewInfo { 
	Location: Vector;
	Rotation: Rotator;
	FOV: number;
	OrthoWidth: number;
	OrthoNearClipPlane: number;
	OrthoFarClipPlane: number;
	AspectRatio: number;
	bConstrainAspectRatio: boolean;
	bUseFieldOfViewForLOD: boolean;
	ProjectionMode: ECameraProjectionMode;
	PostProcessBlendWeight: number;
	PostProcessSettings: PostProcessSettings;
}

declare class CameraCacheEntry { 
	TimeStamp: number;
	POV: MinimalViewInfo;
}

declare class TViewTarget { 
	Target: Actor;
	POV: MinimalViewInfo;
	PlayerState: PlayerState;
}

declare class CameraModifier extends UObject { 
	bDebug: boolean;
	bExclusive: boolean;
	Priority: number;
	CameraOwner: PlayerCameraManager;
	AlphaInTime: number;
	AlphaOutTime: number;
	Alpha: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CameraModifier;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CameraModifier;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraModifier;
	static C(Other: UObject): CameraModifier;
	IsDisabled(): boolean;
	GetViewTarget(): Actor;
	EnableModifier(): void;
	DisableModifier(bImmediate: boolean): void;
	BlueprintModifyPostProcess(DeltaTime: number,PostProcessBlendWeight?: number,PostProcessSettings?: PostProcessSettings): {PostProcessBlendWeight: number, PostProcessSettings: PostProcessSettings};
	BlueprintModifyCamera(DeltaTime: number,ViewLocation: Vector,ViewRotation: Rotator,FOV: number,NewViewLocation?: Vector,NewViewRotation?: Rotator,NewFOV?: number): {NewViewLocation: Vector, NewViewRotation: Rotator, NewFOV: number};
}

declare type EParticleSystemUpdateMode = string;
declare type EEmitterRenderMode = string;
declare class ParticleModule extends UObject { 
	bSpawnModule: boolean;
	bUpdateModule: boolean;
	bFinalUpdateModule: boolean;
	bUpdateForGPUEmitter: boolean;
	bCurvesAsColor: boolean;
	b3DDrawMode: boolean;
	bSupported3DDrawMode: boolean;
	bEnabled: boolean;
	bEditable: boolean;
	LODDuplicate: boolean;
	bSupportsRandomSeed: boolean;
	bRequiresLoopingNotification: boolean;
	LODValidity: number;
	ModuleEditorColor: Color;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModule;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModule;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModule;
	static C(Other: UObject): ParticleModule;
}

declare type EParticleScreenAlignment = string;
declare type EParticleSortMode = string;
declare class DistributionLookupTable { 
	Op: number;
	EntryCount: number;
	EntryStride: number;
	SubEntryStride: number;
	TimeScale: number;
	TimeBias: number;
	Values: number[];
	LockFlag: number;
}

declare class RawDistribution { 
	Table: DistributionLookupTable;
}

declare class Distribution extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Distribution;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Distribution;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Distribution;
	static C(Other: UObject): Distribution;
}

declare class DistributionFloat extends Distribution { 
	bCanBeBaked: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DistributionFloat;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DistributionFloat;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionFloat;
	static C(Other: UObject): DistributionFloat;
}

declare class RawDistributionFloat extends RawDistribution { 
	MinValue: number;
	MaxValue: number;
	Distribution: DistributionFloat;
}

declare type EParticleBurstMethod = string;
declare class ParticleBurst { 
	Count: number;
	CountLow: number;
	Time: number;
}

declare type EParticleSubUVInterpMethod = string;
declare type EEmitterNormalsMode = string;
declare type EParticleUVFlipMode = string;
declare class ParticleModuleRequired extends ParticleModule { 
	Material: MaterialInterface;
	EmitterOrigin: Vector;
	EmitterRotation: Rotator;
	ScreenAlignment: EParticleScreenAlignment;
	bUseLocalSpace: boolean;
	bKillOnDeactivate: boolean;
	bKillOnCompleted: boolean;
	SortMode: EParticleSortMode;
	bUseLegacyEmitterTime: boolean;
	EmitterDuration: number;
	EmitterDurationLow: number;
	bEmitterDurationUseRange: boolean;
	bDurationRecalcEachLoop: boolean;
	EmitterLoops: number;
	SpawnRate: RawDistributionFloat;
	ParticleBurstMethod: EParticleBurstMethod;
	BurstList: ParticleBurst[];
	EmitterDelay: number;
	EmitterDelayLow: number;
	bEmitterDelayUseRange: boolean;
	bDelayFirstLoopOnly: boolean;
	InterpolationMethod: EParticleSubUVInterpMethod;
	SubImages_Horizontal: number;
	SubImages_Vertical: number;
	bScaleUV: boolean;
	RandomImageTime: number;
	RandomImageChanges: number;
	bOverrideSystemMacroUV: boolean;
	MacroUVPosition: Vector;
	MacroUVRadius: number;
	bUseMaxDrawCount: boolean;
	MaxDrawCount: number;
	EmitterNormalsMode: EEmitterNormalsMode;
	NormalsSphereCenter: Vector;
	NormalsCylinderDirection: Vector;
	bOrbitModuleAffectsVelocityAlignment: boolean;
	UVFlippingMode: EParticleUVFlipMode;
	NamedMaterialOverrides: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleRequired;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleRequired;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRequired;
	static C(Other: UObject): ParticleModuleRequired;
}

declare class ParticleModuleSpawnBase extends ParticleModule { 
	bProcessSpawnRate: boolean;
	bProcessBurstList: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleSpawnBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleSpawnBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSpawnBase;
	static C(Other: UObject): ParticleModuleSpawnBase;
}

declare class ParticleModuleSpawn extends ParticleModuleSpawnBase { 
	Rate: RawDistributionFloat;
	RateScale: RawDistributionFloat;
	ParticleBurstMethod: EParticleBurstMethod;
	BurstList: ParticleBurst[];
	BurstScale: RawDistributionFloat;
	bApplyGlobalSpawnRateScale: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleSpawn;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleSpawn;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSpawn;
	static C(Other: UObject): ParticleModuleSpawn;
}

declare class ParticleModuleEventBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleEventBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleEventBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventBase;
	static C(Other: UObject): ParticleModuleEventBase;
}

declare type EParticleEventType = string;
declare class ParticleModuleEventSendToGame extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleEventSendToGame;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleEventSendToGame;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventSendToGame;
	static C(Other: UObject): ParticleModuleEventSendToGame;
}

declare class ParticleEvent_GenerateInfo { 
	Type: EParticleEventType;
	Frequency: number;
	ParticleFrequency: number;
	FirstTimeOnly: boolean;
	LastTimeOnly: boolean;
	UseReflectedImpactVector: boolean;
	bUseOrbitOffset: boolean;
	CustomName: string;
	ParticleModuleEventsToSendToGame: ParticleModuleEventSendToGame[];
}

declare class ParticleModuleEventGenerator extends ParticleModuleEventBase { 
	Events: ParticleEvent_GenerateInfo[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleEventGenerator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleEventGenerator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventGenerator;
	static C(Other: UObject): ParticleModuleEventGenerator;
}

declare class ParticleModuleOrbitBase extends ParticleModule { 
	bUseEmitterTime: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleOrbitBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleOrbitBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleOrbitBase;
	static C(Other: UObject): ParticleModuleOrbitBase;
}

declare type EOrbitChainMode = string;
declare class DistributionVector extends Distribution { 
	bCanBeBaked: boolean;
	bIsDirty: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DistributionVector;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DistributionVector;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionVector;
	static C(Other: UObject): DistributionVector;
}

declare class RawDistributionVector extends RawDistribution { 
	MinValue: number;
	MaxValue: number;
	Distribution: DistributionVector;
}

declare class OrbitOptions { 
	bProcessDuringSpawn: boolean;
	bProcessDuringUpdate: boolean;
	bUseEmitterTime: boolean;
}

declare class ParticleModuleOrbit extends ParticleModuleOrbitBase { 
	ChainMode: EOrbitChainMode;
	OffsetAmount: RawDistributionVector;
	OffsetOptions: OrbitOptions;
	RotationAmount: RawDistributionVector;
	RotationOptions: OrbitOptions;
	RotationRateAmount: RawDistributionVector;
	RotationRateOptions: OrbitOptions;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleOrbit;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleOrbit;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleOrbit;
	static C(Other: UObject): ParticleModuleOrbit;
}

declare class ParticleModuleEventReceiverBase extends ParticleModuleEventBase { 
	EventGeneratorType: EParticleEventType;
	EventName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleEventReceiverBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleEventReceiverBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventReceiverBase;
	static C(Other: UObject): ParticleModuleEventReceiverBase;
}

declare class ParticleLODLevel extends UObject { 
	Level: number;
	bEnabled: boolean;
	RequiredModule: ParticleModuleRequired;
	Modules: ParticleModule[];
	TypeDataModule: ParticleModule;
	SpawnModule: ParticleModuleSpawn;
	EventGenerator: ParticleModuleEventGenerator;
	SpawningModules: ParticleModuleSpawnBase[];
	SpawnModules: ParticleModule[];
	UpdateModules: ParticleModule[];
	OrbitModules: ParticleModuleOrbit[];
	EventReceiverModules: ParticleModuleEventReceiverBase[];
	ConvertedModules: boolean;
	PeakActiveParticles: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleLODLevel;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleLODLevel;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleLODLevel;
	static C(Other: UObject): ParticleLODLevel;
}

declare class ParticleEmitter extends UObject { 
	EmitterName: string;
	SubUVDataOffset: number;
	EmitterRenderMode: EEmitterRenderMode;
	EmitterEditorColor: Color;
	LODLevels: ParticleLODLevel[];
	ConvertedModules: boolean;
	PeakActiveParticles: number;
	InitialAllocationCount: number;
	MediumDetailSpawnRateScale: number;
	QualityLevelSpawnRateScale: number;
	DetailMode: EDetailMode;
	bCollapsed: boolean;
	bIsSoloing: boolean;
	bCookedOut: boolean;
	bDisabledLODsKeepEmitterAlive: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleEmitter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleEmitter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleEmitter;
	static C(Other: UObject): ParticleEmitter;
}

declare class CurveEdEntry { 
	CurveObject: UObject;
	CurveColor: Color;
	CurveName: string;
	bHideCurve: number;
	bColorCurve: number;
	bFloatingPointColorCurve: number;
	bClamp: number;
	ClampLow: number;
	ClampHigh: number;
}

declare class CurveEdTab { 
	TabName: string;
	Curves: CurveEdEntry[];
	ViewStartInput: number;
	ViewEndInput: number;
	ViewStartOutput: number;
	ViewEndOutput: number;
}

declare class InterpCurveEdSetup extends UObject { 
	Tabs: CurveEdTab[];
	ActiveTab: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpCurveEdSetup;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpCurveEdSetup;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpCurveEdSetup;
	static C(Other: UObject): InterpCurveEdSetup;
}

declare type ParticleSystemLODMethod = string;
declare class ParticleSystemLOD { 
}

declare type EParticleSystemOcclusionBoundsMethod = string;
declare class LODSoloTrack { 
	SoloEnableSetting: number[];
}

declare class NamedEmitterMaterial { 
	Name: string;
	Material: MaterialInterface;
}

declare class ParticleSystem extends UObject { 
	SystemUpdateMode: EParticleSystemUpdateMode;
	UpdateTime_FPS: number;
	UpdateTime_Delta: number;
	WarmupTime: number;
	WarmupTickRate: number;
	Emitters: ParticleEmitter[];
	PreviewComponent: ParticleSystemComponent;
	ThumbnailAngle: Rotator;
	ThumbnailDistance: number;
	ThumbnailWarmup: number;
	CurveEdSetup: InterpCurveEdSetup;
	bOrientZAxisTowardCamera: boolean;
	LODDistanceCheckTime: number;
	LODMethod: ParticleSystemLODMethod;
	LODDistances: number[];
	EditorLODSetting: number;
	bRegenerateLODDuplicate: boolean;
	LODSettings: ParticleSystemLOD[];
	bUseFixedRelativeBoundingBox: boolean;
	FixedRelativeBoundingBox: Box;
	SecondsBeforeInactive: number;
	FloorMesh: string;
	FloorPosition: Vector;
	FloorRotation: Rotator;
	FloorScale: number;
	FloorScale3D: Vector;
	BackgroundColor: Color;
	bShouldResetPeakCounts: boolean;
	bHasPhysics: boolean;
	bUseRealtimeThumbnail: boolean;
	ThumbnailImageOutOfDate: boolean;
	ThumbnailImage: Texture2D;
	Delay: number;
	DelayLow: number;
	bUseDelayRange: boolean;
	MacroUVPosition: Vector;
	MacroUVRadius: number;
	OcclusionBoundsMethod: EParticleSystemOcclusionBoundsMethod;
	CustomOcclusionBounds: Box;
	SoloTracking: LODSoloTrack[];
	NamedMaterialSlots: NamedEmitterMaterial[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleSystem;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleSystem;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleSystem;
	static C(Other: UObject): ParticleSystem;
	SpawnEmitterAttached(AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bAutoDestroy: boolean): ParticleSystemComponent;
	ContainsEmitterType(TypeData: UnrealEngineClass): boolean;
}

declare type EBoneTranslationRetargetingMode = string;
declare class BoneNode { 
	Name: string;
	ParentIndex: number;
	TranslationRetargetingMode: EBoneTranslationRetargetingMode;
}

declare class SkeletonToMeshLinkup { 
	SkeletonToMeshTable: number[];
	MeshToSkeletonTable: number[];
}

declare class SkeletalMeshSocket extends UObject { 
	SocketName: string;
	BoneName: string;
	RelativeLocation: Vector;
	RelativeRotation: Rotator;
	RelativeScale: Vector;
	bForceAlwaysAnimated: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SkeletalMeshSocket;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SkeletalMeshSocket;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMeshSocket;
	static C(Other: UObject): SkeletalMeshSocket;
	InitializeSocketFromLocation(SkelComp: SkeletalMeshComponent,WorldLocation: Vector,WorldNormal: Vector): void;
	GetSocketLocation(SkelComp: SkeletalMeshComponent): Vector;
}

declare class SmartNameContainer { 
}

declare class AnimSlotGroup { 
	GroupName: string;
	SlotNames: string[];
}

declare type EConstraintTransform = string;
declare class RigTransformConstraint { 
	TranformType: EConstraintTransform;
	ParentSpace: string;
	Weight: number;
}

declare class TransformBaseConstraint { 
	TransformConstraints: RigTransformConstraint[];
}

declare class TransformBase { 
	UNode: string;
	Constraints: TransformBaseConstraint;
}

declare class UNode { 
	Name: string;
	ParentName: string;
	Transform: Transform;
	DisplayName: string;
	bAdvanced: boolean;
}

declare class Rig extends UObject { 
	TransformBases: TransformBase[];
	Nodes: UNode[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Rig;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Rig;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Rig;
	static C(Other: UObject): Rig;
}

declare class NameMapping { 
	NodeName: string;
	BoneName: string;
}

declare class RigConfiguration { 
	Rig: Rig;
	BoneMappingTable: NameMapping[];
}

declare class PreviewAttachedObjectPair { 
	AttachedObject: any;
	UObject: UObject;
	AttachedTo: string;
}

declare class PreviewAssetAttachContainer { 
	AttachedObjects: PreviewAttachedObjectPair[];
}

declare class BoneReductionSetting { 
	BonesToRemove: string[];
}

declare class Skeleton extends UObject { 
	BoneTree: BoneNode[];
	RefLocalPoses: Transform[];
	LinkupCache: SkeletonToMeshLinkup[];
	Sockets: SkeletalMeshSocket[];
	SmartNames: SmartNameContainer;
	SlotGroups: AnimSlotGroup[];
	PreviewSkeletalMesh: any;
	RigConfig: RigConfiguration;
	AnimationNotifies: string[];
	PreviewAttachedAssetContainer: PreviewAssetAttachContainer;
	BoneReductionSettingsForLODs: BoneReductionSetting[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Skeleton;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Skeleton;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Skeleton;
	static C(Other: UObject): Skeleton;
}

declare class SkeletalMaterial { 
	MaterialInterface: MaterialInterface;
	bEnableShadowCasting: boolean;
}

declare type EAxis = string;
declare class BoneMirrorInfo { 
	SourceIndex: number;
	BoneFlipAxis: EAxis;
}

declare type ETriangleSortOption = string;
declare type ETriangleSortAxis = string;
declare class TriangleSortSettings { 
	TriangleSorting: ETriangleSortOption;
	CustomLeftRightAxis: ETriangleSortAxis;
	CustomLeftRightBoneName: string;
}

declare type SkeletalMeshOptimizationType = string;
declare type SkeletalMeshOptimizationImportance = string;
declare class BoneReference { 
	BoneName: string;
}

declare class SkeletalMeshOptimizationSettings { 
	ReductionMethod: SkeletalMeshOptimizationType;
	NumOfTrianglesPercentage: number;
	MaxDeviationPercentage: number;
	WeldingThreshold: number;
	bRecalcNormals: boolean;
	NormalsThreshold: number;
	SilhouetteImportance: SkeletalMeshOptimizationImportance;
	TextureImportance: SkeletalMeshOptimizationImportance;
	ShadingImportance: SkeletalMeshOptimizationImportance;
	SkinningImportance: SkeletalMeshOptimizationImportance;
	BoneReductionRatio: number;
	MaxBonesPerVertex: number;
	BonesToRemove: BoneReference[];
}

declare class SkeletalMeshLODInfo { 
	ScreenSize: number;
	LODHysteresis: number;
	LODMaterialMap: number[];
	bEnableShadowCasting: boolean[];
	TriangleSortSettings: TriangleSortSettings[];
	bHasBeenSimplified: boolean;
	ReductionSettings: SkeletalMeshOptimizationSettings;
}

declare type ELinearConstraintMotion = string;
declare type EAngularConstraintMotion = string;
declare type EAngularDriveMode = string;
declare class ConstraintInstance { 
	OwnerComponent: SceneComponent;
	JointName: string;
	ConstraintBone1: string;
	ConstraintBone2: string;
	Pos1: Vector;
	PriAxis1: Vector;
	SecAxis1: Vector;
	Pos2: Vector;
	PriAxis2: Vector;
	SecAxis2: Vector;
	bDisableCollision: boolean;
	bEnableProjection: boolean;
	ProjectionLinearTolerance: number;
	ProjectionAngularTolerance: number;
	LinearXMotion: ELinearConstraintMotion;
	LinearYMotion: ELinearConstraintMotion;
	LinearZMotion: ELinearConstraintMotion;
	LinearLimitSize: number;
	bLinearLimitSoft: boolean;
	LinearLimitStiffness: number;
	LinearLimitDamping: number;
	bLinearBreakable: boolean;
	LinearBreakThreshold: number;
	AngularSwing1Motion: EAngularConstraintMotion;
	AngularTwistMotion: EAngularConstraintMotion;
	AngularSwing2Motion: EAngularConstraintMotion;
	bSwingLimitSoft: boolean;
	bTwistLimitSoft: boolean;
	Swing1LimitAngle: number;
	TwistLimitAngle: number;
	Swing2LimitAngle: number;
	SwingLimitStiffness: number;
	SwingLimitDamping: number;
	TwistLimitStiffness: number;
	TwistLimitDamping: number;
	AngularRotationOffset: Rotator;
	bAngularBreakable: boolean;
	AngularBreakThreshold: number;
	bLinearXPositionDrive: boolean;
	bLinearXVelocityDrive: boolean;
	bLinearYPositionDrive: boolean;
	bLinearYVelocityDrive: boolean;
	bLinearZPositionDrive: boolean;
	bLinearZVelocityDrive: boolean;
	bLinearPositionDrive: boolean;
	bLinearVelocityDrive: boolean;
	LinearPositionTarget: Vector;
	LinearVelocityTarget: Vector;
	LinearDriveSpring: number;
	LinearDriveDamping: number;
	LinearDriveForceLimit: number;
	bSwingPositionDrive: boolean;
	bSwingVelocityDrive: boolean;
	bTwistPositionDrive: boolean;
	bTwistVelocityDrive: boolean;
	bAngularSlerpDrive: boolean;
	bAngularOrientationDrive: boolean;
	bEnableSwingDrive: boolean;
	bEnableTwistDrive: boolean;
	bAngularVelocityDrive: boolean;
	AngularPositionTarget: Quat;
	AngularDriveMode: EAngularDriveMode;
	AngularOrientationTarget: Rotator;
	AngularVelocityTarget: Vector;
	AngularDriveSpring: number;
	AngularDriveDamping: number;
	AngularDriveForceLimit: number;
}

declare class PhysicsConstraintTemplate extends UObject { 
	JointName: string;
	ConstraintBone1: string;
	ConstraintBone2: string;
	Pos1: Vector;
	PriAxis1: Vector;
	SecAxis1: Vector;
	Pos2: Vector;
	PriAxis2: Vector;
	SecAxis2: Vector;
	bEnableProjection: boolean;
	ProjectionLinearTolerance: number;
	ProjectionAngularTolerance: number;
	LinearXMotion: ELinearConstraintMotion;
	LinearYMotion: ELinearConstraintMotion;
	LinearZMotion: ELinearConstraintMotion;
	LinearLimitSize: number;
	bLinearLimitSoft: boolean;
	LinearLimitStiffness: number;
	LinearLimitDamping: number;
	bLinearBreakable: boolean;
	LinearBreakThreshold: number;
	AngularSwing1Motion: EAngularConstraintMotion;
	AngularSwing2Motion: EAngularConstraintMotion;
	AngularTwistMotion: EAngularConstraintMotion;
	bSwingLimitSoft: boolean;
	bTwistLimitSoft: boolean;
	Swing1LimitAngle: number;
	Swing2LimitAngle: number;
	TwistLimitAngle: number;
	SwingLimitStiffness: number;
	SwingLimitDamping: number;
	TwistLimitStiffness: number;
	TwistLimitDamping: number;
	bAngularBreakable: boolean;
	AngularBreakThreshold: number;
	DefaultInstance: ConstraintInstance;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PhysicsConstraintTemplate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PhysicsConstraintTemplate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsConstraintTemplate;
	static C(Other: UObject): PhysicsConstraintTemplate;
}

declare class PhysicsAsset extends UObject { 
	DefaultSkelMesh: SkeletalMesh;
	PreviewSkeletalMesh: any;
	BodySetup: BodySetup[];
	BoundsBodies: number[];
	ConstraintSetup: PhysicsConstraintTemplate[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PhysicsAsset;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PhysicsAsset;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsAsset;
	static C(Other: UObject): PhysicsAsset;
}

declare class VertexAnimBase extends UObject { 
	BaseSkelMesh: SkeletalMesh;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VertexAnimBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VertexAnimBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VertexAnimBase;
	static C(Other: UObject): VertexAnimBase;
}

declare class MorphTarget extends VertexAnimBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MorphTarget;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MorphTarget;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MorphTarget;
	static C(Other: UObject): MorphTarget;
}

declare class ClothPhysicsProperties { 
	BendResistance: number;
	ShearResistance: number;
	StretchLimit: number;
	Friction: number;
	Damping: number;
	Drag: number;
	GravityScale: number;
	InertiaBlend: number;
	SelfCollisionThickness: number;
}

declare class ClothingAssetData { 
	AssetName: string;
	ApexFileName: string;
	bClothPropertiesChanged: boolean;
	PhysicsProperties: ClothPhysicsProperties;
}

declare class SkeletalMesh extends UObject { 
	Skeleton: Skeleton;
	Bounds: BoxSphereBounds;
	Materials: SkeletalMaterial[];
	SkelMirrorTable: BoneMirrorInfo[];
	SkelMirrorAxis: EAxis;
	SkelMirrorFlipAxis: EAxis;
	LODInfo: SkeletalMeshLODInfo[];
	bUseFullPrecisionUVs: boolean;
	bHasBeenSimplified: boolean;
	bHasVertexColors: boolean;
	bEnablePerPolyCollision: boolean;
	BodySetup: BodySetup;
	PhysicsAsset: PhysicsAsset;
	AssetImportData: AssetImportData;
	SourceFilePath: string;
	SourceFileTimestamp: string;
	ThumbnailInfo: ThumbnailInfo;
	OptimizationSettings: SkeletalMeshOptimizationSettings[];
	PreviewAttachedAssetContainer: PreviewAssetAttachContainer;
	StreamingDistanceMultiplier: number;
	MorphTargets: MorphTarget[];
	SelectedEditorSection: number;
	SelectedClothingSection: number;
	FloorOffset: number;
	RetargetBasePose: Transform[];
	ClothingAssets: ClothingAssetData[];
	AssetUserData: AssetUserData[];
	Sockets: SkeletalMeshSocket[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SkeletalMesh;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SkeletalMesh;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMesh;
	static C(Other: UObject): SkeletalMesh;
	IsSectionUsingCloth(InSectionIndex: number,bCheckCorrespondingSections: boolean): boolean;
	FindSocket(InSocketName: string): SkeletalMeshSocket;
}

declare class ActiveVertexAnim { 
	VertAnim: VertexAnimBase;
	Weight: number;
	Time: number;
}

declare class SkelMeshComponentLODInfo { 
	HiddenMaterials: boolean[];
}

declare type EMeshComponentUpdateFlag = string;
declare type EPhysBodyOp = string;
declare class SkinnedMeshComponent extends MeshComponent { 
	SkeletalMesh: SkeletalMesh;
	MasterPoseComponent: any;
	bUseBoundsFromMasterPoseComponent: boolean;
	ActiveVertexAnims: ActiveVertexAnim[];
	ChunkIndexPreview: number;
	SectionIndexPreview: number;
	PhysicsAssetOverride: PhysicsAsset;
	ForcedLodModel: number;
	MinLodModel: number;
	PredictedLODLevel: number;
	OldPredictedLODLevel: number;
	MaxDistanceFactor: number;
	LODInfo: SkelMeshComponentLODInfo[];
	StreamingDistanceMultiplier: number;
	WireframeColor: Color;
	bForceWireframe: boolean;
	bDisplayBones: boolean;
	bDisableMorphTarget: boolean;
	bHideSkin: boolean;
	bPerBoneMotionBlur: boolean;
	bComponentUseFixedSkelBounds: boolean;
	bConsiderAllBodiesForBounds: boolean;
	MeshComponentUpdateFlag: EMeshComponentUpdateFlag;
	bForceMeshObjectUpdate: boolean;
	bCanHighlightSelectedSections: boolean;
	bRecentlyRendered: boolean;
	ProgressiveDrawingFraction: number;
	CustomSortAlternateIndexMode: number;
	CachedLocalBounds: BoxSphereBounds;
	bCachedLocalBoundsUpToDate: boolean;
	bEnableUpdateRateOptimizations: boolean;
	bDisplayDebugUpdateRateOptimizations: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SkinnedMeshComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SkinnedMeshComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkinnedMeshComponent;
	static C(Other: UObject): SkinnedMeshComponent;
	UnHideBoneByName(BoneName: string): void;
	TransformToBoneSpace(BoneName: string,InPosition: Vector,InRotation: Rotator,OutPosition?: Vector,OutRotation?: Rotator): {OutPosition: Vector, OutRotation: Rotator};
	TransformFromBoneSpace(BoneName: string,InPosition: Vector,InRotation: Rotator,OutPosition?: Vector,OutRotation?: Rotator): {OutPosition: Vector, OutRotation: Rotator};
	SetSkeletalMesh(NewMesh: SkeletalMesh): void;
	SetPhysicsAsset(NewPhysicsAsset: PhysicsAsset,bForceReInit: boolean): void;
	SetMasterPoseComponent(NewMasterBoneComponent: SkinnedMeshComponent): void;
	IsBoneHiddenByName(BoneName: string): boolean;
	HideBoneByName(BoneName: string,PhysBodyOption: EPhysBodyOp): void;
	GetSocketBoneName(InSocketName: string): string;
	GetParentBone(BoneName: string): string;
	GetBoneName(BoneIndex: number): string;
	GetBoneIndex(BoneName: string): number;
	BoneIsChildOf(BoneName: string,ParentBoneName: string): boolean;
}

declare type EAnimationMode = string;
declare class AnimGroupInfo { 
	Name: string;
	Color: LinearColor;
}

declare class AnimMetaData extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimMetaData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimMetaData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimMetaData;
	static C(Other: UObject): AnimMetaData;
}

declare class AnimationAsset extends UObject { 
	Skeleton: Skeleton;
	MetaData: AnimMetaData[];
	ThumbnailInfo: ThumbnailInfo;
	PreviewSkeletalMesh: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimationAsset;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimationAsset;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationAsset;
	static C(Other: UObject): AnimationAsset;
}

declare class AnimParentNodeAssetOverride { 
	NewAsset: AnimationAsset;
	ParentNodeGuid: Guid;
}

declare class AnimBlueprint extends Blueprint { 
	TargetSkeleton: Skeleton;
	Groups: AnimGroupInfo[];
	ParentAssetOverrides: AnimParentNodeAssetOverride[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimBlueprint;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimBlueprint;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprint;
	static C(Other: UObject): AnimBlueprint;
}

declare class AnimTickRecord { 
	SourceAsset: AnimationAsset;
}

declare class AnimGroupInstance { 
}

declare type ERootMotionMode = string;
declare type EAnimLinkMethod = string;
declare class AnimLinkableElement { 
	LinkedMontage: AnimMontage;
	SlotIndex: number;
	SegmentIndex: number;
	LinkMethod: EAnimLinkMethod;
	CachedLinkMethod: EAnimLinkMethod;
	SegmentBeginTime: number;
	SegmentLength: number;
	LinkValue: number;
	LinkedSequence: AnimSequenceBase;
}

declare class AnimNotify extends UObject { 
	NotifyColor: Color;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimNotify;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimNotify;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotify;
	static C(Other: UObject): AnimNotify;
	Received_Notify(MeshComp: SkeletalMeshComponent,Animation: AnimSequenceBase): boolean;
	GetNotifyName(): string;
}

declare class AnimNotifyState extends UObject { 
	NotifyColor: Color;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimNotifyState;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimNotifyState;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotifyState;
	static C(Other: UObject): AnimNotifyState;
	Received_NotifyTick(MeshComp: SkeletalMeshComponent,Animation: AnimSequenceBase,FrameDeltaTime: number): boolean;
	Received_NotifyEnd(MeshComp: SkeletalMeshComponent,Animation: AnimSequenceBase): boolean;
	Received_NotifyBegin(MeshComp: SkeletalMeshComponent,Animation: AnimSequenceBase,TotalDuration: number): boolean;
	GetNotifyName(): string;
}

declare type EMontageNotifyTickType = string;
declare type ENotifyFilterType = string;
declare class AnimNotifyEvent extends AnimLinkableElement { 
	DisplayTime: number;
	TriggerTimeOffset: number;
	EndTriggerTimeOffset: number;
	TriggerWeightThreshold: number;
	NotifyName: string;
	Notify: AnimNotify;
	NotifyStateClass: AnimNotifyState;
	Duration: number;
	EndLink: AnimLinkableElement;
	bConvertedFromBranchingPoint: boolean;
	MontageTickType: EMontageNotifyTickType;
	NotifyTriggerChance: number;
	NotifyFilterType: ENotifyFilterType;
	NotifyFilterLOD: number;
	bTriggerOnDedicatedServer: boolean;
	NotifyColor: Color;
	TrackIndex: number;
}

declare class AnimCurveBase { 
	LastObservedName: string;
	CurveTypeFlags: number;
}

declare class FloatCurve extends AnimCurveBase { 
	FloatCurve: RichCurve;
}

declare class VectorCurve extends AnimCurveBase { 
	FloatCurves: RichCurve;
}

declare class TransformCurve extends AnimCurveBase { 
	TranslationCurve: VectorCurve;
	RotationCurve: VectorCurve;
	ScaleCurve: VectorCurve;
}

declare class RawCurveTracks { 
	FloatCurves: FloatCurve[];
	VectorCurves: VectorCurve[];
	TransformCurves: TransformCurve[];
}

declare class AnimNotifyTrack { 
	TrackName: string;
	TrackColor: LinearColor;
}

declare class AnimSequenceBase extends AnimationAsset { 
	Notifies: AnimNotifyEvent[];
	SequenceLength: number;
	RateScale: number;
	RawCurveData: RawCurveTracks;
	AnimNotifyTracks: AnimNotifyTrack[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimSequenceBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimSequenceBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSequenceBase;
	static C(Other: UObject): AnimSequenceBase;
	GetPlayLength(): number;
}

declare class AnimCompositeBase extends AnimSequenceBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimCompositeBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimCompositeBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCompositeBase;
	static C(Other: UObject): AnimCompositeBase;
}

declare class CompositeSection extends AnimLinkableElement { 
	SectionName: string;
	StartTime: number;
	NextSectionName: string;
	MetaData: AnimMetaData[];
}

declare class AnimSegment { 
	AnimReference: AnimSequenceBase;
	StartPos: number;
	AnimStartTime: number;
	AnimEndTime: number;
	AnimPlayRate: number;
	LoopingCount: number;
}

declare class AnimTrack { 
	AnimSegments: AnimSegment[];
}

declare class SlotAnimationTrack { 
	SlotName: string;
	AnimTrack: AnimTrack;
}

declare class BranchingPoint extends AnimLinkableElement { 
	EventName: string;
	DisplayTime: number;
	TriggerTimeOffset: number;
}

declare type ERootMotionRootLock = string;
declare class TrackToSkeletonMap { 
	SkeletonIndex: number;
	BoneTreeIndex: number;
}

declare class TranslationTrack { 
	PosKeys: Vector[];
	Times: number[];
}

declare class RotationTrack { 
	RotKeys: Quat[];
	Times: number[];
}

declare class ScaleTrack { 
	ScaleKeys: Vector[];
	Times: number[];
}

declare type AnimationCompressionFormat = string;
declare class AnimCompress extends UObject { 
	Description: string;
	bNeedsSkeleton: boolean;
	TranslationCompressionFormat: AnimationCompressionFormat;
	RotationCompressionFormat: AnimationCompressionFormat;
	ScaleCompressionFormat: AnimationCompressionFormat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimCompress;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimCompress;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCompress;
	static C(Other: UObject): AnimCompress;
}

declare class CompressedOffsetData { 
	OffsetData: number[];
	StripSize: number;
}

declare type AnimationKeyFormat = string;
declare type EAdditiveAnimationType = string;
declare type EAdditiveBasePoseType = string;
declare class AnimSequence extends AnimSequenceBase { 
	NumFrames: number;
	TrackToSkeletonMapTable: TrackToSkeletonMap[];
	AnimationTrackNames: string[];
	TranslationData: TranslationTrack[];
	RotationData: RotationTrack[];
	ScaleData: ScaleTrack[];
	CompressionScheme: AnimCompress;
	TranslationCompressionFormat: AnimationCompressionFormat;
	RotationCompressionFormat: AnimationCompressionFormat;
	ScaleCompressionFormat: AnimationCompressionFormat;
	CompressedTrackOffsets: number[];
	CompressedScaleOffsets: CompressedOffsetData;
	KeyEncodingFormat: AnimationKeyFormat;
	AdditiveAnimType: EAdditiveAnimationType;
	RefPoseType: EAdditiveBasePoseType;
	RefPoseSeq: AnimSequence;
	RefFrameIndex: number;
	EncodingPkgVersion: number;
	RetargetSource: string;
	bEnableRootMotion: boolean;
	RootMotionRootLock: ERootMotionRootLock;
	bRootMotionSettingsCopiedFromMontage: boolean;
	CompressCommandletVersion: number;
	bDoNotOverrideCompression: boolean;
	bWasCompressedWithoutTranslations: boolean;
	AssetImportData: AssetImportData;
	SourceFilePath: string;
	SourceFileTimestamp: string;
	bNeedsRebake: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimSequence;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimSequence;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSequence;
	static C(Other: UObject): AnimSequence;
}

declare type EAnimNotifyEventType = string;
declare class BranchingPointMarker { 
	NotifyIndex: number;
	TriggerTime: number;
	NotifyEventType: EAnimNotifyEventType;
}

declare class AnimMontage extends AnimCompositeBase { 
	BlendInTime: number;
	BlendOutTime: number;
	BlendOutTriggerTime: number;
	CompositeSections: CompositeSection[];
	SlotAnimTracks: SlotAnimationTrack[];
	BranchingPoints: BranchingPoint[];
	bEnableRootMotionTranslation: boolean;
	bEnableRootMotionRotation: boolean;
	RootMotionRootLock: ERootMotionRootLock;
	PreviewBasePose: AnimSequence;
	BranchingPointMarkers: BranchingPointMarker[];
	bAnimBranchingPointNeedsSort: boolean;
	BranchingPointStateNotifyIndices: number[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimMontage;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimMontage;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimMontage;
	static C(Other: UObject): AnimMontage;
}

declare class AnimInstance extends UObject { 
	DeltaTime: number;
	CurrentSkeleton: Skeleton;
	UngroupedActivePlayers: AnimTickRecord[];
	SyncGroups: AnimGroupInstance[];
	VertexAnims: ActiveVertexAnim[];
	RootMotionMode: ERootMotionMode;
	OnMontageBlendingOut: UnrealEngineMulticastDelegate<(Montage: AnimMontage, bInterrupted: boolean) => void>;
	OnMontageStarted: UnrealEngineMulticastDelegate<(Montage: AnimMontage) => void>;
	OnMontageEnded: UnrealEngineMulticastDelegate<(Montage: AnimMontage, bInterrupted: boolean) => void>;
	bQueueMontageEvents: boolean;
	ActiveAnimNotifyState: AnimNotifyEvent[];
	SlotNodeInitializationCounter: any;
	GraphTraversalCounter: any;
	bBoneCachesInvalidated: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimInstance;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimInstance;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimInstance;
	static C(Other: UObject): AnimInstance;
	LockAIResourcesWithAnimation(bLockMovement: boolean,LockAILogic: boolean): void;
	UnlockAIResourcesWithAnimation(bUnlockMovement: boolean,UnlockAILogic: boolean): void;
	UnlockAIResources(bUnlockMovement: boolean,UnlockAILogic: boolean): void;
	TryGetPawnOwner(): Pawn;
	StopSlotAnimation(InBlendOutTime: number,SlotNodeName: string): void;
	SetMorphTarget(MorphTargetName: string,Value: number): void;
	PlaySlotAnimationAsDynamicMontage(Asset: AnimSequenceBase,SlotNodeName: string,BlendInTime: number,BlendOutTime: number,InPlayRate: number,LoopCount: number,BlendOutTriggerTime: number): AnimMontage;
	PlaySlotAnimation(Asset: AnimSequenceBase,SlotNodeName: string,BlendInTime: number,BlendOutTime: number,InPlayRate: number,LoopCount: number): number;
	Montage_Stop(InBlendOutTime: number,Montage: AnimMontage): void;
	Montage_SetPlayRate(Montage: AnimMontage,NewPlayRate: number): void;
	Montage_SetNextSection(SectionNameToChange: string,NextSection: string,Montage: AnimMontage): void;
	Montage_Play(MontageToPlay: AnimMontage,InPlayRate: number): number;
	Montage_Pause(Montage: AnimMontage): void;
	Montage_JumpToSectionsEnd(SectionName: string,Montage: AnimMontage): void;
	Montage_JumpToSection(SectionName: string,Montage: AnimMontage): void;
	Montage_IsPlaying(Montage: AnimMontage): boolean;
	Montage_IsActive(Montage: AnimMontage): boolean;
	Montage_GetCurrentSection(Montage: AnimMontage): string;
	LockAIResources(bLockMovement: boolean,LockAILogic: boolean): void;
	IsPlayingSlotAnimation(Asset: AnimSequenceBase,SlotNodeName: string): boolean;
	GetStateWeight(MachineIndex: number,StateIndex: number): number;
	GetRelevantAnimTimeRemainingFraction(MachineIndex: number,StateIndex: number): number;
	GetRelevantAnimTimeRemaining(MachineIndex: number,StateIndex: number): number;
	GetRelevantAnimTimeFraction(MachineIndex: number,StateIndex: number): number;
	GetRelevantAnimTime(MachineIndex: number,StateIndex: number): number;
	GetRelevantAnimLength(MachineIndex: number,StateIndex: number): number;
	GetOwningComponent(): SkeletalMeshComponent;
	GetOwningActor(): Actor;
	GetTransitionTimeElapsed(MachineIndex: number,TransitionIndex: number): number;
	GetTransitionTimeElapsed(MachineIndex: number,TransitionIndex: number): number;
	GetTransitionCrossfadeDuration(MachineIndex: number,TransitionIndex: number): number;
	StateWeight(MachineIndex: number,StateIndex: number): number;
	CurrentStateTime(MachineIndex: number): number;
	TimeRemaining(AssetPlayerIndex: number): number;
	TimeRemaining(AssetPlayerIndex: number): number;
	CurrentTime(AssetPlayerIndex: number): number;
	CurrentTime(AssetPlayerIndex: number): number;
	Length(AssetPlayerIndex: number): number;
	GetCurveValue(CurveName: string): number;
	GetCurrentStateName(MachineIndex: number): string;
	GetCurrentStateElapsedTime(MachineIndex: number): number;
	static GetAnimAssetPlayerTimeFromEndFraction(AnimAsset: AnimationAsset,CurrentTime: number): number;
	GetAnimAssetPlayerTimeFromEnd(AnimAsset: AnimationAsset,CurrentTime: number): number;
	static GetAnimAssetPlayerTimeFraction(AnimAsset: AnimationAsset,CurrentTime: number): number;
	static GetAnimAssetPlayerLength(AnimAsset: AnimationAsset): number;
	ClearMorphTargets(): void;
	CalculateDirection(Velocity: Vector,BaseRotation: Rotator): number;
	BlueprintUpdateAnimation(DeltaTimeX: number): void;
	BlueprintPostEvaluateAnimation(): void;
	BlueprintInitializeAnimation(): void;
	AnimNotify_Sound(Notify: AnimNotify): void;
}

declare class VertexAnimation extends VertexAnimBase { 
	NumAnimatedVerts: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VertexAnimation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VertexAnimation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VertexAnimation;
	static C(Other: UObject): VertexAnimation;
}

declare class SingleAnimationPlayData { 
	AnimToPlay: AnimationAsset;
	VertexAnimToPlay: VertexAnimation;
	bSavedLooping: boolean;
	bSavedPlaying: boolean;
	SavedPosition: number;
	SavedPlayRate: number;
}

declare type EKinematicBonesUpdateToPhysics = string;
declare class SkeletalMeshComponent extends SkinnedMeshComponent { 
	AnimationMode: EAnimationMode;
	AnimationBlueprint: AnimBlueprint;
	AnimBlueprintGeneratedClass: UnrealEngineClass;
	AnimScriptInstance: AnimInstance;
	AnimationData: SingleAnimationPlayData;
	CachedLocalAtoms: Transform[];
	CachedSpaceBases: Transform[];
	GlobalAnimRateScale: number;
	bHasValidBodies: boolean;
	KinematicBonesUpdateType: EKinematicBonesUpdateToPhysics;
	bBlendPhysics: boolean;
	bEnablePhysicsOnDedicatedServer: boolean;
	bUpdateJointsFromAnimation: boolean;
	bDisableClothSimulation: boolean;
	bCollideWithEnvironment: boolean;
	bCollideWithAttachedChildren: boolean;
	bLocalSpaceSimulation: boolean;
	bClothMorphTarget: boolean;
	bResetAfterTeleport: boolean;
	TeleportDistanceThreshold: number;
	TeleportRotationThreshold: number;
	ClothBlendWeight: number;
	RootBoneTranslation: Vector;
	bNoSkeletonUpdate: boolean;
	bPauseAnims: boolean;
	bEnablePerPolyCollision: boolean;
	BodySetup: BodySetup;
	bAutonomousTickPose: boolean;
	bForceRefpose: boolean;
	bOldForceRefPose: boolean;
	bShowPrePhysBones: boolean;
	bRequiredBonesUpToDate: boolean;
	bAnimTreeInitialised: boolean;
	bEnableLineCheckWithBounds: boolean;
	LineCheckBoundsScale: Vector;
	RagdollAggregateThreshold: number;
	OnConstraintBroken: UnrealEngineMulticastDelegate<(ConstraintIndex: number) => void>;
	SequenceToPlay: AnimSequence;
	AnimToPlay: AnimationAsset;
	bDefaultLooping: boolean;
	bDefaultPlaying: boolean;
	DefaultPosition: number;
	DefaultPlayRate: number;
	LastPoseTickTime: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SkeletalMeshComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SkeletalMeshComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMeshComponent;
	static C(Other: UObject): SkeletalMeshComponent;
	UnbindClothFromMasterPoseComponent(bRestoreSimulationSpace: boolean): void;
	Stop(): void;
	SetPosition(InPos: number,bFireNotifies: boolean): void;
	SetPlayRate(Rate: number): void;
	SetPhysicsBlendWeight(PhysicsBlendWeight: number): void;
	SetMorphTarget(MorphTargetName: string,Value: number,bRemoveZeroWeight: boolean): void;
	SetEnablePhysicsBlending(bNewBlendPhysics: boolean): void;
	SetClothMaxDistanceScale(Scale: number): void;
	SetAnimInstanceClass(NewClass: UnrealEngineClass): void;
	SetAnimationMode(InAnimationMode: EAnimationMode): void;
	SetAnimation(NewAnimToPlay: AnimationAsset): void;
	SetAllMotorsAngularVelocityDrive(bEnableSwingDrive: boolean,bEnableTwistDrive: boolean,bSkipCustomPhysicsType: boolean): void;
	SetAllMotorsAngularPositionDrive(bEnableSwingDrive: boolean,bEnableTwistDrive: boolean,bSkipCustomPhysicsType: boolean): void;
	SetAllMotorsAngularDriveParams(InSpring: number,InDamping: number,InForceLimit: number,bSkipCustomPhysicsType: boolean): void;
	SetAllBodiesSimulatePhysics(bNewSimulate: boolean): void;
	SetAllBodiesPhysicsBlendWeight(PhysicsBlendWeight: number,bSkipCustomPhysicsType: boolean): void;
	SetAllBodiesBelowSimulatePhysics(InBoneName: string,bNewSimulate: boolean): void;
	SetAllBodiesBelowPhysicsBlendWeight(InBoneName: string,PhysicsBlendWeight: number,bSkipCustomPhysicsType: boolean): void;
	ResetClothTeleportMode(): void;
	ResetAllBodiesSimulatePhysics(): void;
	PlayAnimation(NewAnimToPlay: AnimationAsset,bLooping: boolean): void;
	Play(bLooping: boolean): void;
	IsPlaying(): boolean;
	GetPosition(): number;
	GetPlayRate(): number;
	GetMorphTarget(MorphTargetName: string): number;
	GetClothMaxDistanceScale(): number;
	GetAnimInstance(): AnimInstance;
	GetAnimationMode(): EAnimationMode;
	ForceClothNextUpdateTeleportAndReset(): void;
	ForceClothNextUpdateTeleport(): void;
	ClearMorphTargets(): void;
	BindClothToMasterPoseComponent(): void;
	AccumulateAllBodiesBelowPhysicsBlendWeight(InBoneName: string,AddPhysicsBlendWeight: number,bSkipCustomPhysicsType: boolean): void;
}

declare type EParticleSysParamType = string;
declare class ParticleSysParam { 
	Name: string;
	ParamType: EParticleSysParamType;
	Scalar: number;
	Scalar_Low: number;
	Vector: Vector;
	Vector_Low: Vector;
	Color: Color;
	Actor: Actor;
	Material: MaterialInterface;
}

declare class MaterialRelevance { 
	bOpaque: boolean;
	bMasked: boolean;
	bDistortion: boolean;
	bSeparateTranslucency: boolean;
	bNormalTranslucency: boolean;
	bDisableDepthTest: boolean;
	bOutputsVelocityInBasePass: boolean;
	bUsesGlobalDistanceField: boolean;
	ShadingModelMask: any;
}

declare class ParticleSystemReplay extends UObject { 
	ClipIDNumber: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleSystemReplay;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleSystemReplay;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleSystemReplay;
	static C(Other: UObject): ParticleSystemReplay;
}

declare type ETrailWidthMode = string;
declare class ParticleSystemComponent extends PrimitiveComponent { 
	Template: ParticleSystem;
	EmitterMaterials: MaterialInterface[];
	SkelMeshComponents: SkeletalMeshComponent[];
	bResetOnDetach: boolean;
	bUpdateOnDedicatedServer: boolean;
	InstanceParameters: ParticleSysParam[];
	OnParticleSpawn: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, Location: Vector, Velocity: Vector) => void>;
	OnParticleBurst: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleCount: number) => void>;
	OnParticleDeath: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector) => void>;
	OnParticleCollide: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector, Normal: Vector, BoneName: string) => void>;
	OldPosition: Vector;
	PartSysVelocity: Vector;
	WarmupTime: number;
	WarmupTickRate: number;
	bWarmingUp: boolean;
	SecondsBeforeInactive: number;
	MaxTimeBeforeForceUpdateTransform: number;
	EditorLODLevel: number;
	EditorDetailMode: number;
	bOverrideLODMethod: boolean;
	LODMethod: ParticleSystemLODMethod;
	bSkipUpdateDynamicDataDuringTick: boolean;
	CachedViewRelevanceFlags: MaterialRelevance[];
	ReplayClips: ParticleSystemReplay[];
	CustomTimeDilation: number;
	OnSystemFinished: UnrealEngineMulticastDelegate<(PSystem: ParticleSystemComponent) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleSystemComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleSystemComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleSystemComponent;
	static C(Other: UObject): ParticleSystemComponent;
	SetVectorParameter(ParameterName: string,Param: Vector): void;
	SetTrailSourceData(InFirstSocketName: string,InSecondSocketName: string,InWidthMode: ETrailWidthMode,InWidth: number): void;
	SetTemplate(NewTemplate: ParticleSystem): void;
	SetMaterialParameter(ParameterName: string,Param: MaterialInterface): void;
	SetFloatParameter(ParameterName: string,Param: number): void;
	SetEmitterEnable(EmitterName: string,bNewEnableState: boolean): void;
	SetColorParameter(ParameterName: string,Param: LinearColor): void;
	SetBeamTargetTangent(EmitterIndex: number,NewTangentPoint: Vector,TargetIndex: number): void;
	SetBeamTargetStrength(EmitterIndex: number,NewTargetStrength: number,TargetIndex: number): void;
	SetBeamTargetPoint(EmitterIndex: number,NewTargetPoint: Vector,TargetIndex: number): void;
	SetBeamSourceTangent(EmitterIndex: number,NewTangentPoint: Vector,SourceIndex: number): void;
	SetBeamSourceStrength(EmitterIndex: number,NewSourceStrength: number,SourceIndex: number): void;
	SetBeamSourcePoint(EmitterIndex: number,NewSourcePoint: Vector,SourceIndex: number): void;
	SetBeamEndPoint(EmitterIndex: number,NewEndPoint: Vector): void;
	SetActorParameter(ParameterName: string,Param: Actor): void;
	GetNumActiveParticles(): number;
	GetNamedMaterial(InName: string): MaterialInterface;
	GenerateParticleEvent(InEventName: string,InEmitterTime: number,InLocation: Vector,InDirection: Vector,InVelocity: Vector): void;
	EndTrails(): void;
	CreateNamedDynamicMaterialInstance(InName: string,SourceMaterial: MaterialInterface): MaterialInstanceDynamic;
	BeginTrails(InFirstSocketName: string,InSecondSocketName: string,InWidthMode: ETrailWidthMode,InWidth: number): void;
}

declare class ArrowComponent extends PrimitiveComponent { 
	ArrowColor: Color;
	ArrowSize: number;
	bIsScreenSizeScaled: boolean;
	ScreenSize: number;
	bTreatAsASprite: boolean;
	SpriteCategoryName: string;
	SpriteInfo: SpriteCategoryInfo;
	bLightAttachment: boolean;
	bUseInEditorScaling: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ArrowComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ArrowComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ArrowComponent;
	static C(Other: UObject): ArrowComponent;
	SetArrowColor(NewColor: LinearColor): void;
	SetArrowColor_DEPRECATED(NewColor: Color): void;
}

declare class Emitter extends Actor { 
	ParticleSystemComponent: ParticleSystemComponent;
	bDestroyOnSystemFinish: boolean;
	bPostUpdateTickGroup: boolean;
	bCurrentlyActive: boolean;
	OnParticleSpawn: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, Location: Vector, Velocity: Vector) => void>;
	OnParticleBurst: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleCount: number) => void>;
	OnParticleDeath: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector) => void>;
	OnParticleCollide: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector, Normal: Vector, BoneName: string) => void>;
	SpriteComponent: BillboardComponent;
	ArrowComponent: ArrowComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Emitter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Emitter;
	static C(Other: UObject): Emitter;
	ToggleActive(): void;
	SetVectorParameter(ParameterName: string,Param: Vector): void;
	SetTemplate(NewTemplate: ParticleSystem): void;
	SetMaterialParameter(ParameterName: string,Param: MaterialInterface): void;
	SetFloatParameter(ParameterName: string,Param: number): void;
	SetColorParameter(ParameterName: string,Param: LinearColor): void;
	SetActorParameter(ParameterName: string,Param: Actor): void;
	OnRep_bCurrentlyActive(): void;
	OnParticleSystemFinished(FinishedComponent: ParticleSystemComponent): void;
	IsActive(): boolean;
	Deactivate(): void;
	Activate(): void;
}

declare class EmitterCameraLensEffectBase extends Emitter { 
	PS_CameraEffect: ParticleSystem;
	PS_CameraEffectNonExtremeContent: ParticleSystem;
	BaseFOV: number;
	DistFromCamera: number;
	bAllowMultipleInstances: boolean;
	EmittersToTreatAsSame: UnrealEngineClass[];
	BaseCamera: PlayerCameraManager;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EmitterCameraLensEffectBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EmitterCameraLensEffectBase;
	static C(Other: UObject): EmitterCameraLensEffectBase;
}

declare type EInitialOscillatorOffset = string;
declare class FOscillator { 
	Amplitude: number;
	Frequency: number;
	InitialOffset: EInitialOscillatorOffset;
}

declare class ROscillator { 
	Pitch: FOscillator;
	Yaw: FOscillator;
	Roll: FOscillator;
}

declare class VOscillator { 
	X: FOscillator;
	Y: FOscillator;
	Z: FOscillator;
}

declare class SubTrackGroup { 
	GroupName: string;
	TrackIndices: number[];
	bIsCollapsed: boolean;
	bIsSelected: boolean;
}

declare class SupportedSubTrackInfo { 
	SupportedClass: UnrealEngineClass;
	SubTrackName: string;
	GroupIndex: number;
}

declare class InterpTrackInst extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInst;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInst;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInst;
	static C(Other: UObject): InterpTrackInst;
}

declare type ETrackActiveCondition = string;
declare class InterpTrack extends UObject { 
	SubTracks: InterpTrack[];
	SubTrackGroups: SubTrackGroup[];
	SupportedSubTracks: SupportedSubTrackInfo[];
	TrackInstClass: UnrealEngineClass;
	ActiveCondition: ETrackActiveCondition;
	TrackTitle: string;
	bOnePerGroup: boolean;
	bDirGroupOnly: boolean;
	bDisableTrack: boolean;
	bIsSelected: boolean;
	TrackIcon: Texture2D;
	bIsAnimControlTrack: boolean;
	bSubTrackOnly: boolean;
	bVisible: boolean;
	bIsRecording: boolean;
	bIsCollapsed: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrack;
	static C(Other: UObject): InterpTrack;
}

declare class InterpGroup extends UObject { 
	InterpTracks: InterpTrack[];
	GroupName: string;
	GroupColor: Color;
	bCollapsed: boolean;
	bVisible: boolean;
	bIsFolder: boolean;
	bIsParented: boolean;
	bIsSelected: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpGroup;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpGroup;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpGroup;
	static C(Other: UObject): InterpGroup;
}

declare class CameraAnim extends UObject { 
	CameraInterpGroup: InterpGroup;
	PreviewInterpGroup: InterpGroup;
	AnimLength: number;
	BoundingBox: Box;
	bRelativeToInitialTransform: boolean;
	BaseFOV: number;
	BasePostProcessSettings: PostProcessSettings;
	BasePostProcessBlendWeight: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CameraAnim;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CameraAnim;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraAnim;
	static C(Other: UObject): CameraAnim;
}

declare class InterpGroupInst extends UObject { 
	Group: InterpGroup;
	GroupActor: Actor;
	TrackInst: InterpTrackInst[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpGroupInst;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpGroupInst;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpGroupInst;
	static C(Other: UObject): InterpGroupInst;
}

declare type EInterpCurveMode = string;
declare class InterpCurvePointVector { 
	InVal: number;
	OutVal: Vector;
	ArriveTangent: Vector;
	LeaveTangent: Vector;
	InterpMode: EInterpCurveMode;
}

declare class InterpCurveVector { 
	Points: InterpCurvePointVector[];
	bIsLooped: boolean;
	LoopKeyOffset: number;
}

declare class InterpLookupPoint { 
	GroupName: string;
	Time: number;
}

declare class InterpLookupTrack { 
	Points: InterpLookupPoint[];
}

declare type EInterpTrackMoveRotMode = string;
declare class InterpTrackMove extends InterpTrack { 
	PosTrack: InterpCurveVector;
	EulerTrack: InterpCurveVector;
	LookupTrack: InterpLookupTrack;
	LookAtGroupName: string;
	LinCurveTension: number;
	AngCurveTension: number;
	bUseQuatInterpolation: boolean;
	bShowArrowAtKeys: boolean;
	bDisableMovement: boolean;
	bShowTranslationOnCurveEd: boolean;
	bShowRotationOnCurveEd: boolean;
	bHide3DTrack: boolean;
	RotMode: EInterpTrackMoveRotMode;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackMove;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackMove;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackMove;
	static C(Other: UObject): InterpTrackMove;
}

declare class InterpTrackInstMove extends InterpTrackInst { 
	ResetLocation: Vector;
	ResetRotation: Rotator;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstMove;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstMove;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstMove;
	static C(Other: UObject): InterpTrackInstMove;
}

declare type ECameraAnimPlaySpace = string;
declare class CameraAnimInst extends UObject { 
	CamAnim: CameraAnim;
	InterpGroupInst: InterpGroupInst;
	PlayRate: number;
	MoveTrack: InterpTrackMove;
	MoveInst: InterpTrackInstMove;
	PlaySpace: ECameraAnimPlaySpace;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CameraAnimInst;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CameraAnimInst;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraAnimInst;
	static C(Other: UObject): CameraAnimInst;
	Stop(bImmediate: boolean): void;
	SetScale(NewDuration: number): void;
	SetDuration(NewDuration: number): void;
}

declare class CameraShake extends UObject { 
	bSingleInstance: boolean;
	OscillationDuration: number;
	OscillationBlendInTime: number;
	OscillationBlendOutTime: number;
	RotOscillation: ROscillator;
	LocOscillation: VOscillator;
	FOVOscillation: FOscillator;
	AnimPlayRate: number;
	AnimScale: number;
	AnimBlendInTime: number;
	AnimBlendOutTime: number;
	RandomAnimSegmentDuration: number;
	Anim: CameraAnim;
	bRandomAnimSegment: boolean;
	CameraOwner: PlayerCameraManager;
	ShakeScale: number;
	OscillatorTimeRemaining: number;
	AnimInst: CameraAnimInst;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CameraShake;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CameraShake;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraShake;
	static C(Other: UObject): CameraShake;
	ReceiveStopShake(): void;
	ReceivePlayShake(Scale: number): void;
	ReceiveIsFinished(): boolean;
	BlueprintUpdateCameraShake(DeltaTime: number,Alpha: number,POV: MinimalViewInfo,ModifiedPOV?: MinimalViewInfo): {ModifiedPOV: MinimalViewInfo};
}

declare class CameraModifier_CameraShake extends CameraModifier { 
	ActiveShakes: CameraShake[];
	SplitScreenShakeScale: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CameraModifier_CameraShake;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CameraModifier_CameraShake;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraModifier_CameraShake;
	static C(Other: UObject): CameraModifier_CameraShake;
}

declare class DrawFrustumComponent extends PrimitiveComponent { 
	FrustumColor: Color;
	FrustumAngle: number;
	FrustumAspectRatio: number;
	FrustumStartDist: number;
	FrustumEndDist: number;
	Texture: Texture;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DrawFrustumComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DrawFrustumComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DrawFrustumComponent;
	static C(Other: UObject): DrawFrustumComponent;
}

declare class CameraComponent extends SceneComponent { 
	FieldOfView: number;
	OrthoWidth: number;
	OrthoNearClipPlane: number;
	OrthoFarClipPlane: number;
	AspectRatio: number;
	bConstrainAspectRatio: boolean;
	bUseFieldOfViewForLOD: boolean;
	bUsePawnControlRotation: boolean;
	ProjectionMode: ECameraProjectionMode;
	PostProcessBlendWeight: number;
	PostProcessSettings: PostProcessSettings;
	DrawFrustum: DrawFrustumComponent;
	CameraMesh: StaticMesh;
	ProxyMeshComponent: StaticMeshComponent;
	bUseControllerViewRotation: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CameraComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CameraComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraComponent;
	static C(Other: UObject): CameraComponent;
	GetCameraView(DeltaTime: number,DesiredView?: MinimalViewInfo): {DesiredView: MinimalViewInfo};
}

declare class CameraActor extends Actor { 
	AutoActivateForPlayer: EAutoReceiveInput;
	CameraComponent: CameraComponent;
	bConstrainAspectRatio: boolean;
	AspectRatio: number;
	FOVAngle: number;
	PostProcessBlendWeight: number;
	PostProcessSettings: PostProcessSettings;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CameraActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraActor;
	static C(Other: UObject): CameraActor;
	DrawDebugCamera(CameraColor: LinearColor,Duration: number): void;
	GetAutoActivatePlayerIndex(): number;
}

declare class PlayerCameraManager extends Actor { 
	PCOwner: PlayerController;
	TransformComponent: SceneComponent;
	DefaultFOV: number;
	DefaultOrthoWidth: number;
	DefaultAspectRatio: number;
	CameraCache: CameraCacheEntry;
	LastFrameCameraCache: CameraCacheEntry;
	ViewTarget: TViewTarget;
	PendingViewTarget: TViewTarget;
	ModifierList: CameraModifier[];
	DefaultModifiers: UnrealEngineClass[];
	FreeCamDistance: number;
	FreeCamOffset: Vector;
	ViewTargetOffset: Vector;
	CameraLensEffects: EmitterCameraLensEffectBase[];
	CachedCameraShakeMod: CameraModifier_CameraShake;
	AnimInstPool: CameraAnimInst;
	PostProcessBlendCache: PostProcessSettings[];
	ActiveAnims: CameraAnimInst[];
	FreeAnims: CameraAnimInst[];
	AnimCameraActor: CameraActor;
	bIsOrthographic: boolean;
	bUseClientSideCameraUpdates: boolean;
	bFollowHmdOrientation: boolean;
	ViewPitchMin: number;
	ViewPitchMax: number;
	ViewYawMin: number;
	ViewYawMax: number;
	ViewRollMin: number;
	ViewRollMax: number;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PlayerCameraManager;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerCameraManager;
	static C(Other: UObject): PlayerCameraManager;
	StopCameraShake(ShakeInstance: CameraShake): void;
	StopCameraFade(): void;
	StopCameraAnimInst(AnimInst: CameraAnimInst,bImmediate: boolean): void;
	StopAllInstancesOfCameraShake(Shake: UnrealEngineClass): void;
	StopAllInstancesOfCameraAnim(Anim: CameraAnim,bImmediate: boolean): void;
	StopAllCameraShakes(): void;
	StopAllCameraAnims(bImmediate: boolean): void;
	StartCameraFade(FromAlpha: number,ToAlpha: number,Duration: number,Color: LinearColor,bShouldFadeAudio: boolean,bHoldWhenFinished: boolean): void;
	SetManualCameraFade(InFadeAmount: number,Color: LinearColor,bInFadeAudio: boolean): void;
	RemoveCameraModifier(ModifierToRemove: CameraModifier): boolean;
	RemoveCameraLensEffect(Emitter: EmitterCameraLensEffectBase): void;
	PlayCameraShake(ShakeClass: UnrealEngineClass,Scale: number,PlaySpace: ECameraAnimPlaySpace,UserPlaySpaceRot: Rotator): CameraShake;
	PlayCameraAnim(Anim: CameraAnim,Rate: number,Scale: number,BlendInTime: number,BlendOutTime: number,bLoop: boolean,bRandomStartTime: boolean,Duration: number,PlaySpace: ECameraAnimPlaySpace,UserPlaySpaceRot: Rotator): CameraAnimInst;
	GetOwningPlayerController(): PlayerController;
	GetFOVAngle(): number;
	GetCameraRotation(): Rotator;
	GetCameraLocation(): Vector;
	FindCameraModifierByClass(ModifierClass: UnrealEngineClass): CameraModifier;
	ClearCameraLensEffects(): void;
	BlueprintUpdateCamera(CameraTarget: Actor,NewCameraLocation?: Vector,NewCameraRotation?: Rotator,NewCameraFOV?: number): {NewCameraLocation: Vector, NewCameraRotation: Rotator, NewCameraFOV: number, $: boolean};
	AddNewCameraModifier(ModifierClass: UnrealEngineClass): CameraModifier;
	AddCameraLensEffect(LensEffectEmitterClass: UnrealEngineClass): EmitterCameraLensEffectBase;
}

declare type EMovementMode = string;
declare class FindFloorResult { 
	bBlockingHit: boolean;
	bWalkableFloor: boolean;
	bLineTrace: boolean;
	FloorDist: number;
	LineDist: number;
	HitResult: HitResult;
}

declare class NavAvoidanceMask { 
	bGroup0: boolean;
	bGroup1: boolean;
	bGroup2: boolean;
	bGroup3: boolean;
	bGroup4: boolean;
	bGroup5: boolean;
	bGroup6: boolean;
	bGroup7: boolean;
	bGroup8: boolean;
	bGroup9: boolean;
	bGroup10: boolean;
	bGroup11: boolean;
	bGroup12: boolean;
	bGroup13: boolean;
	bGroup14: boolean;
	bGroup15: boolean;
	bGroup16: boolean;
	bGroup17: boolean;
	bGroup18: boolean;
	bGroup19: boolean;
	bGroup20: boolean;
	bGroup21: boolean;
	bGroup22: boolean;
	bGroup23: boolean;
	bGroup24: boolean;
	bGroup25: boolean;
	bGroup26: boolean;
	bGroup27: boolean;
	bGroup28: boolean;
	bGroup29: boolean;
	bGroup30: boolean;
	bGroup31: boolean;
}

declare class CharacterMovementComponentPreClothTickFunction extends TickFunction { 
}

declare class RootMotionMovementParams { 
	bHasRootMotion: boolean;
	BlendWeight: number;
	RootMotionTransform: Transform;
}

declare class Vector_NetQuantize10 extends Vector { 
}

declare class CharacterMovementComponent extends PawnMovementComponent { 
	CharacterOwner: Character;
	GravityScale: number;
	MaxStepHeight: number;
	JumpZVelocity: number;
	JumpOffJumpZFactor: number;
	WalkableFloorAngle: number;
	WalkableFloorZ: number;
	MovementMode: EMovementMode;
	CustomMovementMode: number;
	GroundFriction: number;
	MaxWalkSpeed: number;
	MaxWalkSpeedCrouched: number;
	MaxSwimSpeed: number;
	MaxFlySpeed: number;
	MaxCustomMovementSpeed: number;
	MaxAcceleration: number;
	BrakingFrictionFactor: number;
	BrakingFriction: number;
	bUseSeparateBrakingFriction: boolean;
	BrakingDecelerationWalking: number;
	BrakingDecelerationFalling: number;
	BrakingDecelerationSwimming: number;
	BrakingDecelerationFlying: number;
	AirControl: number;
	AirControlBoostMultiplier: number;
	AirControlBoostVelocityThreshold: number;
	FallingLateralFriction: number;
	CrouchedHalfHeight: number;
	Buoyancy: number;
	PerchRadiusThreshold: number;
	PerchAdditionalHeight: number;
	RotationRate: Rotator;
	bUseControllerDesiredRotation: boolean;
	bOrientRotationToMovement: boolean;
	bMovementInProgress: boolean;
	bEnableScopedMovementUpdates: boolean;
	bForceMaxAccel: boolean;
	bRunPhysicsWithNoController: boolean;
	bForceNextFloorCheck: boolean;
	bShrinkProxyCapsule: boolean;
	bCanWalkOffLedges: boolean;
	bCanWalkOffLedgesWhenCrouching: boolean;
	bDeferUpdateMoveComponent: boolean;
	DeferredUpdatedMoveComponent: SceneComponent;
	MaxOutOfWaterStepHeight: number;
	OutofWaterZ: number;
	Mass: number;
	bEnablePhysicsInteraction: boolean;
	bTouchForceScaledToMass: boolean;
	bPushForceScaledToMass: boolean;
	bScalePushForceToVelocity: boolean;
	StandingDownwardForceScale: number;
	InitialPushForceFactor: number;
	PushForceFactor: number;
	PushForcePointZOffsetFactor: number;
	TouchForceFactor: number;
	MinTouchForce: number;
	MaxTouchForce: number;
	RepulsionForce: number;
	bForceBraking: boolean;
	CrouchedSpeedMultiplier: number;
	UpperImpactNormalScale: number;
	Acceleration: Vector;
	LastUpdateLocation: Vector;
	PendingImpulseToApply: Vector;
	PendingForceToApply: Vector;
	AnalogInputModifier: number;
	MaxSimulationTimeStep: number;
	MaxSimulationIterations: number;
	NetworkSimulatedSmoothLocationTime: number;
	NetworkSimulatedSmoothRotationTime: number;
	LedgeCheckThreshold: number;
	JumpOutOfWaterPitch: number;
	CurrentFloor: FindFloorResult;
	DefaultLandMovementMode: EMovementMode;
	DefaultWaterMovementMode: EMovementMode;
	GroundMovementMode: EMovementMode;
	bMaintainHorizontalGroundVelocity: boolean;
	bImpartBaseVelocityX: boolean;
	bImpartBaseVelocityY: boolean;
	bImpartBaseVelocityZ: boolean;
	bImpartBaseAngularVelocity: boolean;
	bJustTeleported: boolean;
	bNetworkUpdateReceived: boolean;
	bNetworkMovementModeChanged: boolean;
	bNotifyApex: boolean;
	bCheatFlying: boolean;
	bWantsToCrouch: boolean;
	bCrouchMaintainsBaseLocation: boolean;
	bIgnoreBaseRotation: boolean;
	bFastAttachedMove: boolean;
	bAlwaysCheckFloor: boolean;
	bUseFlatBaseForFloorChecks: boolean;
	bPerformingJumpOff: boolean;
	bWantsToLeaveNavWalking: boolean;
	bUseRVOAvoidance: boolean;
	bRequestedMoveUseAcceleration: boolean;
	bHasRequestedVelocity: boolean;
	bRequestedMoveWithMaxSpeed: boolean;
	bWasAvoidanceUpdated: boolean;
	bProjectNavMeshWalking: boolean;
	AvoidanceConsiderationRadius: number;
	RequestedVelocity: Vector;
	AvoidanceUID: number;
	AvoidanceGroup: NavAvoidanceMask;
	GroupsToAvoid: NavAvoidanceMask;
	GroupsToIgnore: NavAvoidanceMask;
	AvoidanceWeight: number;
	PendingLaunchVelocity: Vector;
	NavMeshProjectionInterval: number;
	NavMeshProjectionTimer: number;
	NavMeshProjectionInterpSpeed: number;
	NavMeshProjectionHeightScaleUp: number;
	NavMeshProjectionHeightScaleDown: number;
	PreClothComponentTick: CharacterMovementComponentPreClothTickFunction;
	MinTimeBetweenTimeStampResets: number;
	RootMotionParams: RootMotionMovementParams;
	bWasSimulatingRootMotion: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CharacterMovementComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CharacterMovementComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CharacterMovementComponent;
	static C(Other: UObject): CharacterMovementComponent;
	SetWalkableFloorZ(InWalkableFloorZ: number): void;
	SetWalkableFloorAngle(InWalkableFloorAngle: number): void;
	SetMovementMode(NewMovementMode: EMovementMode,NewCustomMode: number): void;
	SetGroupsToIgnore(GroupFlags: number): void;
	SetGroupsToAvoid(GroupFlags: number): void;
	SetAvoidanceGroup(GroupFlags: number): void;
	SetAvoidanceEnabled(bEnable: boolean): void;
	ServerMoveOld(OldTimeStamp: number,OldAccel: Vector_NetQuantize10,OldMoveFlags: number): void;
	ServerMoveDualHybridRootMotion(TimeStamp0: number,InAccel0: Vector_NetQuantize10,PendingFlags: number,View0: any,TimeStamp: number,InAccel: Vector_NetQuantize10,ClientLoc: Vector_NetQuantize100,NewFlags: number,ClientRoll: number,View: any,ClientMovementBase: PrimitiveComponent,ClientBaseBoneName: string,ClientMovementMode: number): void;
	ServerMoveDual(TimeStamp0: number,InAccel0: Vector_NetQuantize10,PendingFlags: number,View0: any,TimeStamp: number,InAccel: Vector_NetQuantize10,ClientLoc: Vector_NetQuantize100,NewFlags: number,ClientRoll: number,View: any,ClientMovementBase: PrimitiveComponent,ClientBaseBoneName: string,ClientMovementMode: number): void;
	ServerMove(TimeStamp: number,InAccel: Vector_NetQuantize10,ClientLoc: Vector_NetQuantize100,CompressedMoveFlags: number,ClientRoll: number,View: any,ClientMovementBase: PrimitiveComponent,ClientBaseBoneName: string,ClientMovementMode: number): void;
	GetWalkableFloorZ(): number;
	GetWalkableFloorAngle(): number;
	GetModifiedMaxAcceleration(): number;
	IsWalking(): boolean;
	IsWalkable(Hit: HitResult): boolean;
	GetValidPerchRadius(): number;
	GetPerchRadiusThreshold(): number;
	GetMovementBase(): PrimitiveComponent;
	GetMaxJumpHeight(): number;
	GetMaxAcceleration(): number;
	GetImpartedMovementBaseVelocity(): Vector;
	GetCurrentAcceleration(): Vector;
	GetCharacterOwner(): Character;
	GetAnalogInputModifier(): number;
	DisableMovement(): void;
	ClientVeryShortAdjustPosition(TimeStamp: number,NewLoc: Vector,NewBase: PrimitiveComponent,NewBaseBoneName: string,bHasBase: boolean,bBaseRelativePosition: boolean,ServerMovementMode: number): void;
	ClientAdjustRootMotionPosition(TimeStamp: number,ServerMontageTrackPosition: number,ServerLoc: Vector,ServerRotation: Vector_NetQuantizeNormal,ServerVelZ: number,ServerBase: PrimitiveComponent,ServerBoneName: string,bHasBase: boolean,bBaseRelativePosition: boolean,ServerMovementMode: number): void;
	ClientAdjustPosition(TimeStamp: number,NewLoc: Vector,NewVel: Vector,NewBase: PrimitiveComponent,NewBaseBoneName: string,bHasBase: boolean,bBaseRelativePosition: boolean,ServerMovementMode: number): void;
	ClientAckGoodMove(TimeStamp: number): void;
	CapsuleTouched(Other: Actor,OtherComp: PrimitiveComponent,OtherBodyIndex: number,bFromSweep: boolean,SweepResult: HitResult): void;
	CalcVelocity(DeltaTime: number,Friction: number,bFluid: boolean,BrakingDeceleration: number): void;
	AddImpulse(Impulse: Vector,bVelocityChange: boolean): void;
	AddForce(Force: Vector): void;
}

declare class BasedMovementInfo { 
	MovementBase: PrimitiveComponent;
	BoneName: string;
	Location: Vector_NetQuantize100;
	Rotation: Rotator;
	bServerHasBaseComponent: boolean;
	bRelativeRotation: boolean;
	bServerHasVelocity: boolean;
}

declare class RepRootMotionMontage { 
	AnimMontage: AnimMontage;
	Position: number;
	Location: Vector_NetQuantize10;
	Rotation: Rotator;
	MovementBase: PrimitiveComponent;
	MovementBaseBoneName: string;
	bRelativePosition: boolean;
	bRelativeRotation: boolean;
}

declare class SimulatedRootMotionReplicatedMove { 
	Time: number;
	RootMotion: RepRootMotionMontage;
}

declare class Character extends Pawn { 
	Mesh: SkeletalMeshComponent;
	ArrowComponent: ArrowComponent;
	CharacterMovement: CharacterMovementComponent;
	CapsuleComponent: CapsuleComponent;
	BasedMovement: BasedMovementInfo;
	ReplicatedBasedMovement: BasedMovementInfo;
	BaseTranslationOffset: Vector;
	BaseRotationOffset: Quat;
	ReplicatedMovementMode: number;
	bInBaseReplication: boolean;
	CrouchedEyeHeight: number;
	bIsCrouched: boolean;
	bPressedJump: boolean;
	bClientUpdating: boolean;
	bClientWasFalling: boolean;
	bClientResimulateRootMotion: boolean;
	bSimGravityDisabled: boolean;
	bServerMoveIgnoreRootMotion: boolean;
	JumpKeyHoldTime: number;
	JumpMaxHoldTime: number;
	OnReachedJumpApex: UnrealEngineMulticastDelegate<() => void>;
	OnCharacterMovementUpdated: UnrealEngineMulticastDelegate<(DeltaSeconds: number, OldLocation: Vector, OldVelocity: Vector) => void>;
	ClientRootMotionParams: RootMotionMovementParams;
	RootMotionRepMoves: SimulatedRootMotionReplicatedMove[];
	RepRootMotion: RepRootMotionMontage;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Character;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Character;
	static C(Other: UObject): Character;
	UnCrouch(bClientSimulation: boolean): void;
	StopJumping(): void;
	StopAnimMontage(AnimMontage: AnimMontage): void;
	SetReplicateMovement(bInReplicateMovement: boolean): void;
	PlayAnimMontage(AnimMontage: AnimMontage,InPlayRate: number,StartSectionName: string): number;
	OnWalkingOffLedge(PreviousFloorImpactNormal: Vector,PreviousFloorContactNormal: Vector,PreviousLocation: Vector,TimeDelta: number): void;
	OnRep_RootMotion(): void;
	OnRep_ReplicatedBasedMovement(): void;
	OnRep_IsCrouched(): void;
	OnLaunched(LaunchVelocity: Vector,bXYOverride: boolean,bZOverride: boolean): void;
	OnLanded(Hit: HitResult): void;
	OnJumped(): void;
	LaunchCharacter(LaunchVelocity: Vector,bXYOverride: boolean,bZOverride: boolean): void;
	UpdateCustomMovement(DeltaTime: number): void;
	OnStartCrouch(HalfHeightAdjust: number,ScaledHalfHeightAdjust: number): void;
	OnMovementModeChanged(PrevMovementMode: EMovementMode,NewMovementMode: EMovementMode,PrevCustomMode: number,NewCustomMode: number): void;
	OnEndCrouch(HalfHeightAdjust: number,ScaledHalfHeightAdjust: number): void;
	Jump(): void;
	IsPlayingRootMotion(): boolean;
	IsPlayingNetworkedRootMotionMontage(): boolean;
	IsJumpProvidingForce(): boolean;
	GetCurrentMontage(): AnimMontage;
	Crouch(bClientSimulation: boolean): void;
	ClientCheatWalk(): void;
	ClientCheatGhost(): void;
	ClientCheatFly(): void;
	CanJump(): boolean;
	CanJump(): boolean;
}

declare type EGrammaticalGender = string;
declare type EGrammaticalNumber = string;
declare class DialogueVoice extends UObject { 
	Gender: EGrammaticalGender;
	Plurality: EGrammaticalNumber;
	LocalizationGUID: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DialogueVoice;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DialogueVoice;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DialogueVoice;
	static C(Other: UObject): DialogueVoice;
}

declare class DialogueContext { 
	Speaker: DialogueVoice;
	Targets: DialogueVoice[];
}

declare class DialogueSoundWaveProxy extends SoundBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DialogueSoundWaveProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DialogueSoundWaveProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DialogueSoundWaveProxy;
	static C(Other: UObject): DialogueSoundWaveProxy;
}

declare class DialogueContextMapping { 
	Context: DialogueContext;
	SoundWave: SoundWave;
	Proxy: DialogueSoundWaveProxy;
}

declare class DialogueWave extends UObject { 
	bMature: boolean;
	SpokenText: string;
	VoiceActorDirection: string;
	ContextMappings: DialogueContextMapping[];
	LocalizationGUID: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DialogueWave;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DialogueWave;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DialogueWave;
	static C(Other: UObject): DialogueWave;
	SpawnDialogueAttached(Context: DialogueContext,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bStopWhenAttachedToDestroyed: boolean,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation): AudioComponent;
}

declare type EPathFollowingResult = string;
declare class AIRequestID { 
	RequestID: any;
}

declare class AIAsyncTaskBlueprintProxy extends UObject { 
	OnSuccess: UnrealEngineMulticastDelegate<(MovementResult: EPathFollowingResult) => void>;
	OnFail: UnrealEngineMulticastDelegate<(MovementResult: EPathFollowingResult) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AIAsyncTaskBlueprintProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AIAsyncTaskBlueprintProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIAsyncTaskBlueprintProxy;
	static C(Other: UObject): AIAsyncTaskBlueprintProxy;
	OnMoveCompleted(RequestID: AIRequestID,MovementResult: EPathFollowingResult): void;
}

declare class BlackboardKeyType extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlackboardKeyType;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlackboardKeyType;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType;
	static C(Other: UObject): BlackboardKeyType;
}

declare class BlackboardKeySelector { 
	AllowedTypes: BlackboardKeyType[];
	SelectedKeyName: string;
	SelectedKeyType: UnrealEngineClass;
	SelectedKeyID: number;
	bNoneIsAllowedValue: boolean;
}

declare class BlackboardEntry { 
	EntryName: string;
	EntryDescription: string;
	KeyType: BlackboardKeyType;
	bInstanceSynced: boolean;
}

declare class BlackboardData extends DataAsset { 
	Parent: BlackboardData;
	ParentKeys: BlackboardEntry[];
	Keys: BlackboardEntry[];
	bHasSynchronizedKeys: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlackboardData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlackboardData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardData;
	static C(Other: UObject): BlackboardData;
}

declare class BlackboardComponent extends ActorComponent { 
	BrainComp: BrainComponent;
	BlackboardAsset: BlackboardData;
	KeyInstances: BlackboardKeyType[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlackboardComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlackboardComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardComponent;
	static C(Other: UObject): BlackboardComponent;
	SetValueAsVector(KeyName: string,VectorValue: Vector): void;
	SetValueAsString(KeyName: string,StringValue: string): void;
	SetValueAsRotator(KeyName: string,VectorValue: Rotator): void;
	SetValueAsObject(KeyName: string,ObjectValue: UObject): void;
	SetValueAsName(KeyName: string,NameValue: string): void;
	SetValueAsInt(KeyName: string,IntValue: number): void;
	SetValueAsFloat(KeyName: string,FloatValue: number): void;
	SetValueAsEnum(KeyName: string,EnumValue: number): void;
	SetValueAsClass(KeyName: string,ClassValue: UnrealEngineClass): void;
	SetValueAsBool(KeyName: string,BoolValue: boolean): void;
	IsVectorValueSet(KeyName: string): boolean;
	GetValueAsVector(KeyName: string): Vector;
	GetValueAsString(KeyName: string): string;
	GetValueAsRotator(KeyName: string): Rotator;
	GetValueAsObject(KeyName: string): UObject;
	GetValueAsName(KeyName: string): string;
	GetValueAsInt(KeyName: string): number;
	GetValueAsFloat(KeyName: string): number;
	GetValueAsEnum(KeyName: string): number;
	GetValueAsClass(KeyName: string): UnrealEngineClass;
	GetValueAsBool(KeyName: string): boolean;
	GetRotationFromEntry(KeyName: string,ResultRotation?: Rotator): {ResultRotation: Rotator, $: boolean};
	GetLocationFromEntry(KeyName: string,ResultLocation?: Vector): {ResultLocation: Vector, $: boolean};
	ClearValueAsVector(KeyName: string): void;
	ClearValueAsRotator(KeyName: string): void;
	ClearValue(KeyName: string): void;
}

declare type EPathFollowingAction = string;
declare class PathFollowingComponent extends ActorComponent { 
	MovementComp: NavMovementComponent;
	MyNavData: NavigationData;
	bUseVisibilityTestsSimplification: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PathFollowingComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PathFollowingComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PathFollowingComponent;
	static C(Other: UObject): PathFollowingComponent;
	OnActorBump(SelfActor: Actor,OtherActor: Actor,NormalImpulse: Vector,Hit: HitResult): void;
	GetPathDestination(): Vector;
	GetPathActionType(): EPathFollowingAction;
}

declare class AISenseConfig extends UObject { 
	MaxAge: number;
	bStartsEnabled: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISenseConfig;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISenseConfig;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig;
	static C(Other: UObject): AISenseConfig;
}

declare type EAISenseNotifyType = string;
declare class AISenseEvent extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISenseEvent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISenseEvent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseEvent;
	static C(Other: UObject): AISenseEvent;
}

declare class AIStimulus { 
	Age: number;
	ExpirationAge: number;
	Strength: number;
	StimulusLocation: Vector;
	ReceiverLocation: Vector;
	Tag: string;
	bSuccessfullySensed: boolean;
}

declare class AIPerceptionSystem extends UObject { 
	Senses: AISense[];
	PerceptionAgingRate: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AIPerceptionSystem;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AIPerceptionSystem;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIPerceptionSystem;
	static C(Other: UObject): AIPerceptionSystem;
	static ReportPerceptionEvent(WorldContext: UObject,PerceptionEvent: AISenseEvent): void;
	ReportEvent(PerceptionEvent: AISenseEvent): void;
	static RegisterPerceptionStimuliSource(WorldContext: UObject,Sense: UnrealEngineClass,Target: Actor): boolean;
	OnPerceptionStimuliSourceEndPlay(EndPlayReason: EEndPlayReason): void;
	static GetSenseClassForStimulus(WorldContext: UObject,Stimulus: AIStimulus): UnrealEngineClass;
}

declare class AISense extends UObject { 
	DebugDrawColor: Color;
	DebugName: string;
	DefaultExpirationAge: number;
	NotifyType: EAISenseNotifyType;
	bWantsNewPawnNotification: boolean;
	bAutoRegisterAllPawnsAsSources: boolean;
	PerceptionSystemInstance: AIPerceptionSystem;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISense;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISense;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense;
	static C(Other: UObject): AISense;
}

declare class ActorPerceptionBlueprintInfo { 
	Target: Actor;
	LastSensedStimuli: AIStimulus[];
	bIsHostile: boolean;
}

declare class AIPerceptionComponent extends ActorComponent { 
	HearingRange: number;
	LoSHearingRange: number;
	SightRadius: number;
	LoseSightRadius: number;
	PeripheralVisionAngle: number;
	SensesConfig: AISenseConfig[];
	DominantSense: UnrealEngineClass;
	AIOwner: AIController;
	OnPerceptionUpdated: UnrealEngineMulticastDelegate<(UpdatedActors: Actor[]) => void>;
	OnTargetPerceptionUpdated: UnrealEngineMulticastDelegate<(Actor: Actor, Stimulus: AIStimulus) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AIPerceptionComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AIPerceptionComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIPerceptionComponent;
	static C(Other: UObject): AIPerceptionComponent;
	RequestStimuliListenerUpdate(): void;
	OnOwnerEndPlay(EndPlayReason: EEndPlayReason): void;
	GetPerceivedHostileActors(OutActors?: Actor[]): {OutActors: Actor[]};
	GetPerceivedActors(SenseToUse: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	GetActorsPerception(Actor: Actor,Info?: ActorPerceptionBlueprintInfo): {Info: ActorPerceptionBlueprintInfo, $: boolean};
}

declare type EAIRequestPriority = string;
declare type EPawnActionResult = string;
declare class PawnAction extends UObject { 
	ChildAction: PawnAction;
	ParentAction: PawnAction;
	OwnerComponent: PawnActionsComponent;
	Instigator: UObject;
	BrainComp: BrainComponent;
	bAllowNewSameClassInstance: boolean;
	bReplaceActiveSameClassInstance: boolean;
	bShouldPauseMovement: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PawnAction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PawnAction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction;
	static C(Other: UObject): PawnAction;
	GetActionPriority(): EAIRequestPriority;
	Finish(WithResult: EPawnActionResult): void;
	static CreateActionInstance(WorldContextObject: UObject,ActionClass: UnrealEngineClass): PawnAction;
}

declare class PawnActionStack { 
	TopAction: PawnAction;
}

declare class PawnActionEvent { 
	Action: PawnAction;
}

declare type EPawnActionAbortState = string;
declare class PawnActionsComponent extends ActorComponent { 
	ControlledPawn: Pawn;
	ActionStacks: PawnActionStack[];
	ActionEvents: PawnActionEvent[];
	CurrentAction: PawnAction;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PawnActionsComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PawnActionsComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnActionsComponent;
	static C(Other: UObject): PawnActionsComponent;
	PushAction(NewAction: PawnAction,Priority: EAIRequestPriority,Instigator: UObject): boolean;
	static PerformAction(Pawn: Pawn,Action: PawnAction,Priority: EAIRequestPriority): boolean;
	ForceAbortAction(ActionToAbort: PawnAction): EPawnActionAbortState;
	AbortAction(ActionToAbort: PawnAction): EPawnActionAbortState;
}

declare class GameplayTask extends UObject { 
	InstanceName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTask;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTask;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTask;
	static C(Other: UObject): GameplayTask;
	ReadyForActivation(): void;
	EndTask(): void;
}

declare class GameplayResourceSet { 
}

declare class GameplayTasksComponent extends ActorComponent { 
	SimulatedTasks: GameplayTask[];
	TaskPriorityQueue: GameplayTask[];
	OnClaimedResourcesChange: UnrealEngineMulticastDelegate<(NewlyClaimed: GameplayResourceSet, FreshlyReleased: GameplayResourceSet) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTasksComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTasksComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTasksComponent;
	static C(Other: UObject): GameplayTasksComponent;
	OnRep_SimulatedTasks(): void;
}

declare type EPathFollowingRequestResult = string;
declare type EPathFollowingStatus = string;
declare class AIController extends Controller { 
	bLOSflag: boolean;
	bSkipExtraLOSChecks: boolean;
	bAllowStrafe: boolean;
	bWantsPlayerState: boolean;
	PathFollowingComponent: PathFollowingComponent;
	BrainComponent: BrainComponent;
	PerceptionComponent: AIPerceptionComponent;
	ActionsComp: PawnActionsComponent;
	Blackboard: BlackboardComponent;
	CachedGameplayTasksComponent: GameplayTasksComponent;
	ReceiveMoveCompleted: UnrealEngineMulticastDelegate<(RequestID: AIRequestID, Result: EPathFollowingResult) => void>;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AIController;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIController;
	static C(Other: UObject): AIController;
	UseBlackboard(BlackboardAsset: BlackboardData,BlackboardComponent?: BlackboardComponent): {BlackboardComponent: BlackboardComponent, $: boolean};
	SetMoveBlockDetection(bEnable: boolean): void;
	RunBehaviorTree(BTAsset: BehaviorTree): boolean;
	OnUsingBlackBoard(BlackboardComp: BlackboardComponent,BlackboardAsset: BlackboardData): void;
	OnPossess(PossessedPawn: Pawn): void;
	OnGameplayTaskResourcesClaimed(NewlyClaimed: GameplayResourceSet,FreshlyReleased: GameplayResourceSet): void;
	MoveToLocation(Dest: Vector,AcceptanceRadius: number,bStopOnOverlap: boolean,bUsePathfinding: boolean,bProjectDestinationToNavigation: boolean,bCanStrafe: boolean,FilterClass: UnrealEngineClass,bAllowPartialPath: boolean): EPathFollowingRequestResult;
	MoveToActor(Goal: Actor,AcceptanceRadius: number,bStopOnOverlap: boolean,bUsePathfinding: boolean,bCanStrafe: boolean,FilterClass: UnrealEngineClass,bAllowPartialPath: boolean): EPathFollowingRequestResult;
	SetFocus(NewFocus: Actor): void;
	SetFocalPoint(FP: Vector): void;
	ClearFocus(): void;
	HasPartialPath(): boolean;
	GetPathFollowingComponent(): PathFollowingComponent;
	GetMoveStatus(): EPathFollowingStatus;
	GetImmediateMoveDestination(): Vector;
	GetFocusActor(): Actor;
	GetFocalPointOnActor(Actor: Actor): Vector;
	GetFocalPoint(): Vector;
	GetAIPerceptionComponent(): AIPerceptionComponent;
}

declare class BrainComponent extends ActorComponent { 
	BlackboardComp: BlackboardComponent;
	AIOwner: AIController;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BrainComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BrainComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrainComponent;
	static C(Other: UObject): BrainComponent;
	StopLogic(Reason: string): void;
	RestartLogic(): void;
}

declare class GameplayTag { 
	TagName: string;
}

declare class BehaviorTreeComponent extends BrainComponent { 
	NodeInstances: BTNode[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeComponent;
	static C(Other: UObject): BehaviorTreeComponent;
	SetDynamicSubtree(InjectTag: GameplayTag,BehaviorAsset: BehaviorTree): void;
	GetTagCooldownEndTime(CooldownTag: GameplayTag): number;
	AddCooldownTagDuration(CooldownTag: GameplayTag,CooldownDuration: number,bAddToExistingDuration: boolean): void;
}

declare class BTNode extends UObject { 
	NodeName: string;
	TreeAsset: BehaviorTree;
	ParentNode: BTCompositeNode;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTNode;
	static C(Other: UObject): BTNode;
	ClearBlackboardValue(Key: BlackboardKeySelector): void;
	ClearBlackboardValueAsVector(Key: BlackboardKeySelector): void;
	GetBlackboardValueAsActor(Key: BlackboardKeySelector): Actor;
	GetBlackboardValueAsBool(Key: BlackboardKeySelector): boolean;
	GetBlackboardValueAsClass(Key: BlackboardKeySelector): UnrealEngineClass;
	GetBlackboardValueAsEnum(Key: BlackboardKeySelector): number;
	GetBlackboardValueAsFloat(Key: BlackboardKeySelector): number;
	GetBlackboardValueAsInt(Key: BlackboardKeySelector): number;
	GetBlackboardValueAsName(Key: BlackboardKeySelector): string;
	GetBlackboardValueAsObject(Key: BlackboardKeySelector): UObject;
	GetBlackboardValueAsRotator(Key: BlackboardKeySelector): Rotator;
	GetBlackboardValueAsString(Key: BlackboardKeySelector): string;
	GetBlackboardValueAsVector(Key: BlackboardKeySelector): Vector;
	GetOwnerComponent(): BehaviorTreeComponent;
	GetOwnersBlackboard(): BlackboardComponent;
	SetBlackboardValueAsBool(Key: BlackboardKeySelector,Value: boolean): void;
	SetBlackboardValueAsClass(Key: BlackboardKeySelector,Value: UnrealEngineClass): void;
	SetBlackboardValueAsEnum(Key: BlackboardKeySelector,Value: number): void;
	SetBlackboardValueAsFloat(Key: BlackboardKeySelector,Value: number): void;
	SetBlackboardValueAsInt(Key: BlackboardKeySelector,Value: number): void;
	SetBlackboardValueAsName(Key: BlackboardKeySelector,Value: string): void;
	SetBlackboardValueAsObject(Key: BlackboardKeySelector,Value: UObject): void;
	SetBlackboardValueAsRotator(Key: BlackboardKeySelector,Value: Rotator): void;
	SetBlackboardValueAsString(Key: BlackboardKeySelector,Value: string): void;
	SetBlackboardValueAsVector(Key: BlackboardKeySelector,Value: Vector): void;
	StartUsingExternalEvent(OwningActor: Actor): void;
	StopUsingExternalEvent(): void;
}

declare class BTTaskNode extends BTNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTTaskNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTTaskNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTaskNode;
	static C(Other: UObject): BTTaskNode;
}

declare class BTAuxiliaryNode extends BTNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTAuxiliaryNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTAuxiliaryNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTAuxiliaryNode;
	static C(Other: UObject): BTAuxiliaryNode;
}

declare type EBTFlowAbortMode = string;
declare class BTDecorator extends BTAuxiliaryNode { 
	bInverseCondition: boolean;
	FlowAbortMode: EBTFlowAbortMode;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator;
	static C(Other: UObject): BTDecorator;
}

declare type EBTDecoratorLogic = string;
declare class BTDecoratorLogic { 
	Operation: EBTDecoratorLogic;
	Number: any;
}

declare class BTCompositeChild { 
	ChildComposite: BTCompositeNode;
	ChildTask: BTTaskNode;
	Decorators: BTDecorator[];
	DecoratorOps: BTDecoratorLogic[];
}

declare class BTService extends BTAuxiliaryNode { 
	Interval: number;
	RandomDeviation: number;
	bCallTickOnSearchStart: boolean;
	bRestartTimerOnEachActivation: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTService;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTService;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTService;
	static C(Other: UObject): BTService;
}

declare class BTCompositeNode extends BTNode { 
	Children: BTCompositeChild[];
	Services: BTService[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTCompositeNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTCompositeNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTCompositeNode;
	static C(Other: UObject): BTCompositeNode;
}

declare class BehaviorTree extends UObject { 
	RootNode: BTCompositeNode;
	BTGraph: EdGraph;
	LastEditedDocuments: EditedDocumentInfo[];
	BlackboardAsset: BlackboardData;
	RootDecorators: BTDecorator[];
	RootDecoratorOps: BTDecoratorLogic[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTree;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTree;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTree;
	static C(Other: UObject): BehaviorTree;
}

declare type ENiagaraDataType = string;
declare class NiagaraVariableInfo { 
	Name: string;
	Type: ENiagaraDataType;
}

declare class Vector4 { 
	X: number;
	Y: number;
	Z: number;
	W: number;
}

declare class DeprecatedNiagaraConstants { 
	ScalarConstantsInfo: NiagaraVariableInfo[];
	VectorConstantsInfo: NiagaraVariableInfo[];
	MatrixConstantsInfo: NiagaraVariableInfo[];
	ScalarConstants: number[];
	VectorConstants: Vector4[];
	MatrixConstants: Matrix[];
}

declare class NiagaraConstantBase { 
	Name: string;
}

declare class NiagaraConstants_Float extends NiagaraConstantBase { 
	Value: number;
}

declare class NiagaraConstants_Vector extends NiagaraConstantBase { 
	Value: Vector4;
}

declare class NiagaraConstants_Matrix extends NiagaraConstantBase { 
	Value: Matrix;
}

declare class NiagaraDataObject extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraDataObject;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraDataObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataObject;
	static C(Other: UObject): NiagaraDataObject;
}

declare class NiagaraConstants_DataObject extends NiagaraConstantBase { 
	Value: NiagaraDataObject;
}

declare class NiagaraConstants { 
	ScalarConstants: NiagaraConstants_Float[];
	VectorConstants: NiagaraConstants_Vector[];
	MatrixConstants: NiagaraConstants_Matrix[];
	DataObjectConstants: NiagaraConstants_DataObject[];
}

declare class NiagaraScriptConstantData { 
	ExternalConstants: DeprecatedNiagaraConstants;
	InternalConstants: DeprecatedNiagaraConstants;
	ExternalConstantsNew: NiagaraConstants;
	InternalConstantsNew: NiagaraConstants;
}

declare class NiagaraScriptSourceBase extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraScriptSourceBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraScriptSourceBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraScriptSourceBase;
	static C(Other: UObject): NiagaraScriptSourceBase;
}

declare class NiagaraScript extends UObject { 
	ByteCode: number[];
	ConstantData: NiagaraScriptConstantData;
	Attributes: NiagaraVariableInfo[];
	Source: NiagaraScriptSourceBase;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraScript;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraScript;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraScript;
	static C(Other: UObject): NiagaraScript;
}

declare type EEmitterRenderModuleType = string;
declare class NiagaraEffectRendererProperties extends UObject { 
	dummy: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraEffectRendererProperties;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraEffectRendererProperties;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraEffectRendererProperties;
	static C(Other: UObject): NiagaraEffectRendererProperties;
}

declare class NiagaraConstantMap { 
}

declare class DeprecatedNiagaraEmitterProperties { 
	Name: string;
	bIsEnabled: boolean;
	SpawnRate: number;
	UpdateScript: NiagaraScript;
	SpawnScript: NiagaraScript;
	Material: Material;
	RenderModuleType: EEmitterRenderModuleType;
	StartTime: number;
	EndTime: number;
	RendererProperties: NiagaraEffectRendererProperties;
	ExternalConstants: NiagaraConstantMap;
	ExternalSpawnConstants: NiagaraConstantMap;
	NumLoops: number;
}

declare class NiagaraEmitterScriptProperties { 
	Script: NiagaraScript;
	ExternalConstants: NiagaraConstants;
}

declare class NiagaraEmitterProperties extends UObject { 
	EmitterName: string;
	bIsEnabled: boolean;
	SpawnRate: number;
	Material: Material;
	RenderModuleType: EEmitterRenderModuleType;
	StartTime: number;
	EndTime: number;
	RendererProperties: NiagaraEffectRendererProperties;
	NumLoops: number;
	UpdateScriptProps: NiagaraEmitterScriptProperties;
	SpawnScriptProps: NiagaraEmitterScriptProperties;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraEmitterProperties;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraEmitterProperties;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraEmitterProperties;
	static C(Other: UObject): NiagaraEmitterProperties;
}

declare class NiagaraComponent extends PrimitiveComponent { 
	Asset: NiagaraEffect;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraComponent;
	static C(Other: UObject): NiagaraComponent;
	SetUpdateScriptConstant(EmitterName: string,ConstantName: string,Value: Vector): void;
}

declare class NiagaraEffect extends UObject { 
	EmitterPropsSerialized: DeprecatedNiagaraEmitterProperties[];
	EmitterProps: NiagaraEmitterProperties[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraEffect;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraEffect;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraEffect;
	static C(Other: UObject): NiagaraEffect;
	SpawnEffectAttached(AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bAutoDestroy: boolean): NiagaraComponent;
}

declare class WidgetTree extends UObject { 
	RootWidget: Widget;
	AllWidgets: Widget[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WidgetTree;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WidgetTree;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetTree;
	static C(Other: UObject): WidgetTree;
}

declare class MovieSceneSequence extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneSequence;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneSequence;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSequence;
	static C(Other: UObject): MovieSceneSequence;
}

declare class MovieSceneSpawnable { 
	Guid: Guid;
	Name: string;
	GeneratedClass: UnrealEngineClass;
}

declare class MovieScenePossessable { 
	Guid: Guid;
	Name: string;
	PossessedObjectClass: UnrealEngineClass;
}

declare class MovieSceneTrack extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneTrack;
	static C(Other: UObject): MovieSceneTrack;
}

declare class MovieSceneBinding { 
	ObjectGuid: Guid;
	BindingName: string;
	Tracks: MovieSceneTrack[];
}

declare class MovieSceneEditorData { 
	ExpansionStates: any;
}

declare class MovieScene extends UObject { 
	Spawnables: MovieSceneSpawnable[];
	Possessables: MovieScenePossessable[];
	ObjectBindings: MovieSceneBinding[];
	MasterTracks: MovieSceneTrack[];
	ShotTrack: MovieSceneTrack;
	EditorData: MovieSceneEditorData;
	InTime: number;
	OutTime: number;
	StartTime: number;
	EndTime: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieScene;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieScene;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene;
	static C(Other: UObject): MovieScene;
}

declare class WidgetAnimationBinding { 
	WidgetName: string;
	SlotWidgetName: string;
	AnimationGuid: Guid;
}

declare class WidgetAnimation extends MovieSceneSequence { 
	MovieScene: MovieScene;
	AnimationBindings: WidgetAnimationBinding[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WidgetAnimation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WidgetAnimation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetAnimation;
	static C(Other: UObject): WidgetAnimation;
	GetStartTime(): number;
	GetEndTime(): number;
}

declare class UMGSequencePlayer extends UObject { 
	Animation: WidgetAnimation;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UMGSequencePlayer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UMGSequencePlayer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UMGSequencePlayer;
	static C(Other: UObject): UMGSequencePlayer;
}

declare class NamedSlotBinding { 
	Name: string;
	Content: Widget;
}

declare type EDesignPreviewSizeMode = string;
declare class Geometry { 
}

declare type EUMGSequencePlayMode = string;
declare class InputEvent { 
}

declare class UPointerEvent extends InputEvent { 
}

declare class EventReply { 
}

declare class KeyEvent extends InputEvent { 
}

declare class PaintContext { 
}

declare class MotionEvent extends InputEvent { 
}

declare class CharacterEvent extends InputEvent { 
}

declare class UFocusEvent { 
}

declare class ControllerEvent extends InputEvent { 
}

declare class AnalogInputEvent extends KeyEvent { 
}

declare class UserWidget extends Widget { 
	ColorAndOpacity: LinearColor;
	ColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	ForegroundColor: SlateColor;
	ForegroundColorDelegate: UnrealEngineDelegate<() => SlateColor>;
	bSupportsKeyboardFocus: boolean;
	WidgetTree: WidgetTree;
	ActiveSequencePlayers: UMGSequencePlayer[];
	StoppedSequencePlayers: UMGSequencePlayer[];
	NamedSlotBindings: NamedSlotBinding[];
	DesignTimeSize: Vector2D;
	bUseDesignTimeSize: boolean;
	bUseDesiredSizeAtDesignTime: boolean;
	DesignSizeMode: EDesignPreviewSizeMode;
	PaletteCategory: string;
	PreviewBackground: Texture2D;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UserWidget;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UserWidget;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserWidget;
	static C(Other: UObject): UserWidget;
	Tick(MyGeometry: Geometry,InDeltaTime: number): void;
	StopAnimation(InAnimation: WidgetAnimation): void;
	SetPositionInViewport(Position: Vector2D,bRemoveDPIScale: boolean): void;
	SetOwningLocalPlayer(LocalPlayer: LocalPlayer): void;
	SetForegroundColor(InForegroundColor: SlateColor): void;
	SetDesiredSizeInViewport(Size: Vector2D): void;
	SetColorAndOpacity(InColorAndOpacity: LinearColor): void;
	SetAnchorsInViewport(Anchors: Anchors): void;
	SetAlignmentInViewport(Alignment: Vector2D): void;
	RemoveFromViewport(): void;
	PlaySound(SoundToPlay: SoundBase): void;
	PlayAnimation(InAnimation: WidgetAnimation,StartAtTime: number,NumLoopsToPlay: number,PlayMode: EUMGSequencePlayMode): void;
	PauseAnimation(InAnimation: WidgetAnimation): number;
	OnTouchStarted(MyGeometry: Geometry,InTouchEvent: UPointerEvent): EventReply;
	OnTouchMoved(MyGeometry: Geometry,InTouchEvent: UPointerEvent): EventReply;
	OnTouchGesture(MyGeometry: Geometry,GestureEvent: UPointerEvent): EventReply;
	OnTouchEnded(MyGeometry: Geometry,InTouchEvent: UPointerEvent): EventReply;
	OnPreviewMouseButtonDown(MyGeometry: Geometry,MouseEvent: UPointerEvent): EventReply;
	OnPreviewKeyDown(MyGeometry: Geometry,InKeyEvent: KeyEvent): EventReply;
	OnPaint(Context?: PaintContext): {Context: PaintContext};
	OnMouseWheel(MyGeometry: Geometry,MouseEvent: UPointerEvent): EventReply;
	OnMouseMove(MyGeometry: Geometry,MouseEvent: UPointerEvent): EventReply;
	OnMouseLeave(MouseEvent: UPointerEvent): void;
	OnMouseEnter(MyGeometry: Geometry,MouseEvent: UPointerEvent): void;
	OnMouseButtonUp(MyGeometry: Geometry,MouseEvent: UPointerEvent): EventReply;
	OnMouseButtonDown(MyGeometry: Geometry,MouseEvent: UPointerEvent): EventReply;
	OnMouseButtonDoubleClick(InMyGeometry: Geometry,InMouseEvent: UPointerEvent): EventReply;
	OnMotionDetected(MyGeometry: Geometry,InMotionEvent: MotionEvent): EventReply;
	OnKeyUp(MyGeometry: Geometry,InKeyEvent: KeyEvent): EventReply;
	OnKeyDown(MyGeometry: Geometry,InKeyEvent: KeyEvent): EventReply;
	OnKeyChar(MyGeometry: Geometry,InCharacterEvent: CharacterEvent): EventReply;
	OnFocusReceived(MyGeometry: Geometry,InFocusEvent: UFocusEvent): EventReply;
	OnFocusLost(InFocusEvent: UFocusEvent): void;
	OnDrop(MyGeometry: Geometry,UPointerEvent: UPointerEvent,Operation: DragDropOperation): boolean;
	OnDragOver(MyGeometry: Geometry,UPointerEvent: UPointerEvent,Operation: DragDropOperation): boolean;
	OnDragLeave(UPointerEvent: UPointerEvent,Operation: DragDropOperation): void;
	OnDragEnter(MyGeometry: Geometry,UPointerEvent: UPointerEvent,Operation: DragDropOperation): void;
	OnDragDetected(MyGeometry: Geometry,UPointerEvent: UPointerEvent,Operation?: DragDropOperation): {Operation: DragDropOperation};
	OnDragCancelled(UPointerEvent: UPointerEvent,Operation: DragDropOperation): void;
	OnControllerButtonReleased(MyGeometry: Geometry,ControllerEvent: ControllerEvent): EventReply;
	OnControllerButtonPressed(MyGeometry: Geometry,ControllerEvent: ControllerEvent): EventReply;
	OnControllerAnalogValueChanged(MyGeometry: Geometry,ControllerEvent: ControllerEvent): EventReply;
	OnAnimationStarted(Animation: WidgetAnimation): void;
	OnAnimationFinished(Animation: WidgetAnimation): void;
	OnAnalogValueChanged(MyGeometry: Geometry,InAnalogInputEvent: AnalogInputEvent): EventReply;
	IsInViewport(): boolean;
	IsInteractable(): boolean;
	GetOwningPlayerPawn(): Pawn;
	GetOwningPlayer(): PlayerController;
	GetOwningLocalPlayer(): LocalPlayer;
	GetIsVisible(): boolean;
	Destruct(): void;
	Construct(): void;
	AddToViewport(ZOrder: number): void;
	AddToPlayerScreen(ZOrder: number): boolean;
}

declare class World extends UObject { 
	Layers: Layer[];
	ActiveGroupActors: Actor[];
	ThumbnailInfo: ThumbnailInfo;
	PersistentLevel: Level;
	NetDriver: NetDriver;
	LineBatcher: LineBatchComponent;
	PersistentLineBatcher: LineBatchComponent;
	ForegroundLineBatcher: LineBatchComponent;
	GameState: GameState;
	NetworkManager: GameNetworkManager;
	PhysicsCollisionHandler: PhysicsCollisionHandler;
	ExtraReferencedObjects: UObject[];
	PerModuleDataObjects: UObject[];
	StreamingLevels: LevelStreaming[];
	StreamingLevelsPrefix: string;
	CurrentLevelPendingVisibility: Level;
	DemoNetDriver: DemoNetDriver;
	MyParticleEventManager: ParticleEventManager;
	DefaultPhysicsVolume: PhysicsVolume;
	NavigationSystem: NavigationSystem;
	AuthorityGameMode: GameMode;
	AISystem: AISystemBase;
	AvoidanceManager: AvoidanceManager;
	Levels: Level[];
	CurrentLevel: Level;
	OwningGameInstance: GameInstance;
	ParameterCollectionInstances: MaterialParameterCollectionInstance[];
	EditorViews: LevelViewportInfo[];
	SelectedLevels: Level[];
	WorldComposition: WorldComposition;
	bAreConstraintsDirty: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): World;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): World;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): World;
	static C(Other: UObject): World;
	IsGameWorld(): boolean;
	IsPlayInEditor(): boolean;
	IsPlayInPreview(): boolean;
	RunAllFunctionalTests(bNewLog: boolean,bRunLooped: boolean,bWaitForNavigationBuildFinish: boolean,FailedTestsReproString: string): boolean;
	GetIsMyTurn(PlayerController: PlayerController,MatchID: string,bIsMyTurn?: boolean): {bIsMyTurn: boolean};
	GetMyPlayerIndex(PlayerController: PlayerController,MatchID: string,PlayerIndex?: number): {PlayerIndex: number};
	GetPlayerDisplayName(PlayerController: PlayerController,MatchID: string,PlayerIndex: number,PlayerDisplayName?: string): {PlayerDisplayName: string};
	RegisterTurnBasedMatchInterfaceObject(PlayerController: PlayerController,UObject: UObject): void;
	GetCachedAchievementDescription(PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Title?: string,LockedDescription?: string,UnlockedDescription?: string,bHidden?: boolean): {bFoundID: boolean, Title: string, LockedDescription: string, UnlockedDescription: string, bHidden: boolean};
	GetCachedAchievementProgress(PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Progress?: number): {bFoundID: boolean, Progress: number};
	LogBoxShape(BoxShape: Box,Text: string,ObjectColor: LinearColor,LogCategory: string): void;
	LogLocation(Location: Vector,Text: string,ObjectColor: LinearColor,Radius: number,LogCategory: string): void;
	LogText(Text: string,LogCategory: string): void;
	BoxOverlapActors_DEPRECATED(BoxPos: Vector,BoxExtent: Vector,Filter: EOverlapFilterOption,ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	BoxOverlapActors(BoxPos: Vector,BoxExtent: Vector,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	BoxOverlapComponents_DEPRECATED(BoxPos: Vector,Extent: Vector,Filter: EOverlapFilterOption,ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	BoxOverlapComponents(BoxPos: Vector,Extent: Vector,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	MultiBoxTraceByChannel(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean): {OutHits: HitResult[], $: boolean};
	MultiBoxTraceForObjects(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean): {OutHits: HitResult[], $: boolean};
	BoxTraceByChannel(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean): {OutHit: HitResult, $: boolean};
	BoxTraceForObjects(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean): {OutHit: HitResult, $: boolean};
	CapsuleOverlapActors_DEPRECATED(CapsulePos: Vector,Radius: number,HalfHeight: number,Filter: EOverlapFilterOption,ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	CapsuleOverlapActors(CapsulePos: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	CapsuleOverlapComponents_DEPRECATED(CapsulePos: Vector,Radius: number,HalfHeight: number,Filter: EOverlapFilterOption,ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	CapsuleOverlapComponents(CapsulePos: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	MultiCapsuleTraceByChannelDeprecated(Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ECollisionChannel,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean): {OutHits: HitResult[], $: boolean};
	MultiCapsuleTraceByChannel(Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean): {OutHits: HitResult[], $: boolean};
	MultiCapsuleTraceByObjectDeprecated(Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectsToTrace: ECollisionChannel[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean): {OutHits: HitResult[], $: boolean};
	MultiCapsuleTraceForObjects(Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean): {OutHits: HitResult[], $: boolean};
	SingleCapsuleTraceByChannelDeprecated(Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ECollisionChannel,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean): {OutHit: HitResult, $: boolean};
	CapsuleTraceByChannel(Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean): {OutHit: HitResult, $: boolean};
	SingleCapsuleTraceByObjectDeprecated(Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectsToTrace: ECollisionChannel[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean): {OutHit: HitResult, $: boolean};
	CapsuleTraceForObjects(Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean): {OutHit: HitResult, $: boolean};
	Delay(Duration: number,LatentInfo: LatentActionInfo): void;
	DrawDebugArrow(LineStart: Vector,LineEnd: Vector,ArrowSize: number,LineColor: LinearColor,Duration: number): void;
	DrawDebugBox(Center: Vector,Extent: Vector,LineColor: LinearColor,Rotation: Rotator,Duration: number): void;
	DrawDebugCapsule(Center: Vector,HalfHeight: number,Radius: number,Rotation: Rotator,LineColor: LinearColor,Duration: number): void;
	DrawDebugCircle(Center: Vector,Radius: number,NumSegments: number,LineColor: LinearColor,Duration: number,Thickness: number,YAxis: Vector,ZAxis: Vector,bDrawAxis: boolean): void;
	DrawDebugCone(Origin: Vector,Direction: Vector,Length: number,AngleWidth: number,AngleHeight: number,NumSides: number,LineColor: LinearColor): void;
	DrawDebugCone(Origin: Vector,Direction: Vector,Length: number,AngleWidth: number,AngleHeight: number,NumSides: number,LineColor: LinearColor,Duration: number): void;
	DrawDebugCoordinateSystem(AxisLoc: Vector,AxisRot: Rotator,Scale: number,Duration: number): void;
	DrawDebugCylinder(Start: Vector,End: Vector,Radius: number,Segments: number,LineColor: LinearColor,Duration: number): void;
	DrawDebugFloatHistoryLocation(FloatHistory: DebugFloatHistory,DrawLocation: Vector,DrawSize: Vector2D,DrawColor: LinearColor,Duration: number): void;
	DrawDebugFloatHistoryTransform(FloatHistory: DebugFloatHistory,DrawTransform: Transform,DrawSize: Vector2D,DrawColor: LinearColor,Duration: number): void;
	DrawDebugFrustum(FrustumTransform: Transform,FrustumColor: LinearColor,Duration: number): void;
	DrawDebugLine(LineStart: Vector,LineEnd: Vector,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugPlane(PlaneCoordinates: Plane,Location: Vector,Size: number,PlaneColor: LinearColor,Duration: number): void;
	DrawDebugPoint(Position: Vector,Size: number,PointColor: LinearColor,Duration: number): void;
	DrawDebugSphere(Center: Vector,Radius: number,Segments: number,LineColor: LinearColor,Duration: number): void;
	DrawDebugString(TextLocation: Vector,Text: string,TestBaseActor: Actor,TextColor: LinearColor,Duration: number): void;
	ExecuteConsoleCommand(Command: string,SpecificPlayer: PlayerController): void;
	FlushDebugStrings(): void;
	FlushPersistentDebugLines(): void;
	GetGameTimeInSeconds(): number;
	IsDedicatedServer(): boolean;
	IsServer(): boolean;
	ClearTimerbyHandle(Handle: TimerHandle): void;
	GetTimerElapsedTimebyHandle(Handle: TimerHandle): number;
	GetTimerRemainingTimebyHandle(Handle: TimerHandle): number;
	IsTimerActivebyHandle(Handle: TimerHandle): boolean;
	IsTimerPausedbyHandle(Handle: TimerHandle): boolean;
	PauseTimerbyHandle(Handle: TimerHandle): void;
	DoesTimerExistbyHandle(Handle: TimerHandle): boolean;
	UnpauseTimerbyHandle(Handle: TimerHandle): void;
	MultiLineTraceByChannelDeprecated(Start: Vector,End: Vector,TraceChannel: ECollisionChannel,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean): {OutHits: HitResult[], $: boolean};
	MultiLineTraceByChannel(Start: Vector,End: Vector,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean): {OutHits: HitResult[], $: boolean};
	MultiLineTraceByObjectDeprecated(Start: Vector,End: Vector,ObjectsToTrace: ECollisionChannel[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean): {OutHits: HitResult[], $: boolean};
	MultiLineTraceForObjects(Start: Vector,End: Vector,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean): {OutHits: HitResult[], $: boolean};
	SingleLineTraceByChannelDeprecated(Start: Vector,End: Vector,TraceChannel: ECollisionChannel,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean): {OutHit: HitResult, $: boolean};
	LineTraceByChannel(Start: Vector,End: Vector,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean): {OutHit: HitResult, $: boolean};
	SingleLineTraceByObjectDeprecated(Start: Vector,End: Vector,ObjectsToTrace: ECollisionChannel[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean): {OutHit: HitResult, $: boolean};
	LineTraceForObjects(Start: Vector,End: Vector,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean): {OutHit: HitResult, $: boolean};
	LoadAsset(Asset: any,OnLoaded: UnrealEngineDelegate<(Loaded: UObject) => void>,LatentInfo: LatentActionInfo): void;
	LoadAssetClass(AssetClass: any,OnLoaded: UnrealEngineDelegate<(Loaded: UnrealEngineClass) => void>,LatentInfo: LatentActionInfo): void;
	PrintString(InString: string,bPrintToScreen: boolean,bPrintToLog: boolean,TextColor: LinearColor,Duration: number): void;
	PrintText(InText: string,bPrintToScreen: boolean,bPrintToLog: boolean,TextColor: LinearColor,Duration: number): void;
	QuitGame(SpecificPlayer: PlayerController,QuitPreference: EQuitPreference): void;
	RetriggerableDelay(Duration: number,LatentInfo: LatentActionInfo): void;
	SetSupressViewportTransitionMessage(bState: boolean): void;
	SphereOverlapActors_DEPRECATED(SpherePos: Vector,SphereRadius: number,Filter: EOverlapFilterOption,ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	SphereOverlapActors(SpherePos: Vector,SphereRadius: number,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	SphereOverlapComponents_DEPRECATED(SpherePos: Vector,SphereRadius: number,Filter: EOverlapFilterOption,ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	SphereOverlapComponents(SpherePos: Vector,SphereRadius: number,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	MultiSphereTraceByChannelDeprecated(Start: Vector,End: Vector,Radius: number,TraceChannel: ECollisionChannel,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean): {OutHits: HitResult[], $: boolean};
	MultiSphereTraceByChannel(Start: Vector,End: Vector,Radius: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean): {OutHits: HitResult[], $: boolean};
	MultiSphereTraceByObjectDeprecated(Start: Vector,End: Vector,Radius: number,ObjectsToTrace: ECollisionChannel[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean): {OutHits: HitResult[], $: boolean};
	MultiSphereTraceForObjects(Start: Vector,End: Vector,Radius: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean): {OutHits: HitResult[], $: boolean};
	SingleSphereTraceByChannelDeprecated(Start: Vector,End: Vector,Radius: number,TraceChannel: ECollisionChannel,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean): {OutHit: HitResult, $: boolean};
	SphereTraceByChannel(Start: Vector,End: Vector,Radius: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean): {OutHit: HitResult, $: boolean};
	SingleSphereTraceByObjectDeprecated(Start: Vector,End: Vector,Radius: number,ObjectsToTrace: ECollisionChannel[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean): {OutHit: HitResult, $: boolean};
	SphereTraceForObjects(Start: Vector,End: Vector,Radius: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean): {OutHit: HitResult, $: boolean};
	MinimumAreaRectangle(InVerts: Vector[],SampleSurfaceNormal: Vector,OutRectCenter?: Vector,OutRectRotation?: Rotator,OutSideLengthX?: number,OutSideLengthY?: number,bDebugDraw?: boolean): {OutRectCenter: Vector, OutRectRotation: Rotator, OutSideLengthX: number, OutSideLengthY: number};
	CreateDynamicMaterialInstance(Parent: MaterialInterface): MaterialInstanceDynamic;
	GetScalarParameterValue(Collection: MaterialParameterCollection,ParameterName: string): number;
	GetVectorParameterValue(Collection: MaterialParameterCollection,ParameterName: string): LinearColor;
	SetScalarParameterValue(Collection: MaterialParameterCollection,ParameterName: string,ParameterValue: number): void;
	SetVectorParameterValue(Collection: MaterialParameterCollection,ParameterName: string,ParameterValue: LinearColor): void;
	GetWorldToMetersScale(): number;
	SetWorldToMetersScale(NewScale: number): void;
	ActivateReverbEffect(ReverbEffect: ReverbEffect,TagName: string,Priority: number,Volume: number,FadeTime: number): void;
	ApplyRadialDamage(BaseDamage: number,Origin: Vector,DamageRadius: number,DamageTypeClass: UnrealEngineClass,IgnoreActors: Actor[],DamageCauser: Actor,InstigatedByController: Controller,bDoFullDamage: boolean,DamagePreventionChannel: ECollisionChannel): boolean;
	ApplyRadialDamageWithFalloff(BaseDamage: number,MinimumDamage: number,Origin: Vector,DamageInnerRadius: number,DamageOuterRadius: number,DamageFalloff: number,DamageTypeClass: UnrealEngineClass,IgnoreActors: Actor[],DamageCauser: Actor,InstigatedByController: Controller,DamagePreventionChannel: ECollisionChannel): boolean;
	AreAnyListenersWithinRange(Location: Vector,MaximumRange: number): boolean;
	BeginDeferredActorSpawnFromClass(ActorClass: UnrealEngineClass,SpawnTransform: Transform,CollisionHandlingOverride: ESpawnActorCollisionHandlingMethod,Owner: Actor): Actor;
	BeginSpawningActorFromBlueprint(Blueprint: Blueprint,SpawnTransform: Transform,bNoCollisionFail: boolean): Actor;
	BeginSpawningActorFromClass(ActorClass: UnrealEngineClass,SpawnTransform: Transform,bNoCollisionFail: boolean,Owner: Actor): Actor;
	SuggestProjectileVelocity(TossVelocity?: Vector,StartLocation?: Vector,EndLocation?: Vector,LaunchSpeed?: number,OverrideGravityZ?: number,TraceOption?: ESuggestProjVelocityTraceOption,CollisionRadius?: number,bFavorHighArc?: boolean,bDrawDebug?: boolean): {TossVelocity: Vector, $: boolean};
	ClearSoundMixModifiers(): void;
	CreatePlayer(ControllerId: number,bSpawnPawn: boolean): PlayerController;
	DeactivateReverbEffect(TagName: string): void;
	FlushLevelStreaming(): void;
	GetAccurateRealTime(Seconds?: number,PartialSeconds?: number): {Seconds: number, PartialSeconds: number};
	GetAllActorsOfClass(ActorClass: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	GetAllActorsWithInterface(Interface: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	GetAudioTimeSeconds(): number;
	GetCurrentLevelName(bRemovePrefixString: boolean): string;
	GetGameInstance(): GameInstance;
	GetGameMode(): GameMode;
	GetGameState(): GameState;
	GetGlobalTimeDilation(): number;
	GetPlayerCameraManager(PlayerIndex: number): PlayerCameraManager;
	GetPlayerCharacter(PlayerIndex: number): Character;
	GetPlayerController(PlayerIndex: number): PlayerController;
	GetPlayerPawn(PlayerIndex: number): Pawn;
	GetRealTimeSeconds(): number;
	GetStreamingLevel(PackageName: string): LevelStreaming;
	GetWorldDeltaSeconds(): number;
	GetWorldOriginLocation(): IntVector;
	GrassOverlappingSphereCount(StaticMesh: StaticMesh,CenterPosition: Vector,Radius: number): number;
	IsGamePaused(): boolean;
	LoadStreamLevel(LevelName: string,bMakeVisibleAfterLoad: boolean,bShouldBlockOnLoad: boolean,LatentInfo: LatentActionInfo): void;
	OpenLevel(LevelName: string,bAbsolute: boolean,Options: string): void;
	PlayDialogue2D(Dialogue: DialogueWave,Context: DialogueContext,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number): void;
	PlayDialogueAtLocation(Dialogue: DialogueWave,Context: DialogueContext,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation): void;
	PlaySound2D(Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number): void;
	PlaySoundAtLocation(Sound: SoundBase,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation): void;
	PlayWorldCameraShake(Shake: UnrealEngineClass,Epicenter: Vector,InnerRadius: number,OuterRadius: number,Falloff: number,bOrientShakeTowardsEpicenter: boolean): void;
	PopSoundMixModifier(InSoundMixModifier: SoundMix): void;
	PushSoundMixModifier(InSoundMixModifier: SoundMix): void;
	SetBaseSoundMix(InSoundMix: SoundMix): void;
	SetGamePaused(bPaused: boolean): boolean;
	SetGlobalTimeDilation(TimeDilation: number): void;
	SetWorldOriginLocation(NewLocation: IntVector): void;
	SpawnDecalAtLocation(DecalMaterial: MaterialInterface,DecalSize: Vector,Location: Vector,Rotation: Rotator,LifeSpan: number): DecalComponent;
	SpawnDialogue2D(Dialogue: DialogueWave,Context: DialogueContext,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number): AudioComponent;
	SpawnDialogueAtLocation(Dialogue: DialogueWave,Context: DialogueContext,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation): AudioComponent;
	SpawnEmitterAtLocation(EmitterTemplate: ParticleSystem,Location: Vector,Rotation: Rotator,bAutoDestroy: boolean): ParticleSystemComponent;
	SpawnSound2D(Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number): AudioComponent;
	SpawnSoundAtLocation(Sound: SoundBase,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation): AudioComponent;
	UnloadStreamLevel(LevelName: string,LatentInfo: LatentActionInfo): void;
	FindPathToActorSynchronously(PathStart: Vector,GoalActor: Actor,TetherDistance: number,PathfindingContext: Actor,FilterClass: UnrealEngineClass): NavigationPath;
	FindPathToLocationSynchronously(PathStart: Vector,PathEnd: Vector,PathfindingContext: Actor,FilterClass: UnrealEngineClass): NavigationPath;
	GetNavigationSystem(): NavigationSystem;
	GetPathCost(PathStart: Vector,PathEnd: Vector,PathCost?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {PathCost: number, $: ENavigationQueryResult};
	GetPathLength(PathStart: Vector,PathEnd: Vector,PathLength?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {PathLength: number, $: ENavigationQueryResult};
	GetRandomPoint(NavData: NavigationData,FilterClass: UnrealEngineClass): Vector;
	GetRandomPointInNavigableRadius(Origin: Vector,Radius: number,NavData: NavigationData,FilterClass: UnrealEngineClass): Vector;
	GetRandomPointInRadius(Origin: Vector,Radius: number,NavData: NavigationData,FilterClass: UnrealEngineClass): Vector;
	GetRandomReachablePointInRadius(Origin: Vector,Radius: number,NavData: NavigationData,FilterClass: UnrealEngineClass): Vector;
	IsNavigationBeingBuilt(): boolean;
	NavigationRaycast(RayStart: Vector,RayEnd: Vector,HitLocation?: Vector,FilterClass?: UnrealEngineClass,Querier?: Controller): {HitLocation: Vector, $: boolean};
	ProjectPointToNavigation(Point: Vector,NavData: NavigationData,FilterClass: UnrealEngineClass,QueryExtent: Vector): Vector;
	FoliageOverlappingBoxCount(StaticMesh: StaticMesh,Box: Box): number;
	FoliageOverlappingSphereCount(StaticMesh: StaticMesh,CenterPosition: Vector,Radius: number): number;
	CreateMoveToProxyObject(Pawn: Pawn,Destination: Vector,TargetActor: Actor,AcceptanceRadius: number,bStopOnOverlap: boolean): AIAsyncTaskBlueprintProxy;
	SpawnAIFromClass(PawnClass: UnrealEngineClass,BehaviorTree: BehaviorTree,Location: Vector,Rotation: Rotator,bNoCollisionFail: boolean): Pawn;
	SpawnEffectAtLocation(EffectTemplate: NiagaraEffect,Location: Vector,Rotation: Rotator,bAutoDestroy: boolean): NiagaraComponent;
	GetViewportScale(): number;
	GetViewportSize(): Vector2D;
	RemoveAllWidgets(): void;
	CreateWidget(WidgetType: UnrealEngineClass,OwningPlayer: PlayerController): UserWidget;
	GetAllWidgetsOfClass(FoundWidgets?: UserWidget[],WidgetClass?: UnrealEngineClass,TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	GetAllWidgetsWithInterface(Interface: UnrealEngineClass,FoundWidgets?: UserWidget[],TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	AbsoluteToViewport(AbsoluteDesktopCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
	LocalToViewport(Geometry: Geometry,LocalCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
}

declare class Info extends Actor { 
	SpriteComponent: BillboardComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Info;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Info;
	static C(Other: UObject): Info;
}

declare class UniqueNetIdRepl { 
}

declare class PlayerState extends Info { 
	Score: number;
	Ping: number;
	PlayerName: string;
	PlayerId: number;
	bIsSpectator: boolean;
	bOnlySpectator: boolean;
	bIsABot: boolean;
	bIsInactive: boolean;
	bFromPreviousLevel: boolean;
	StartTime: number;
	EngineMessageClass: UnrealEngineClass;
	UniqueId: UniqueNetIdRepl;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PlayerState;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerState;
	static C(Other: UObject): PlayerState;
	OnRep_UniqueId(): void;
	OnRep_Score(): void;
	OnRep_PlayerName(): void;
	OnRep_bIsInactive(): void;
}

declare class Pawn extends Actor { 
	bUseControllerRotationPitch: boolean;
	bUseControllerRotationYaw: boolean;
	bUseControllerRotationRoll: boolean;
	bCanAffectNavigationGeneration: boolean;
	BaseEyeHeight: number;
	AutoPossessPlayer: EAutoReceiveInput;
	AutoPossessAI: EAutoPossessAI;
	AIControllerClass: UnrealEngineClass;
	PlayerState: PlayerState;
	RemoteViewPitch: number;
	LastHitBy: Controller;
	Controller: Controller;
	ControlInputVector: Vector;
	LastControlInputVector: Vector;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Pawn;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Pawn;
	static C(Other: UObject): Pawn;
	SendAIMessage(Message: string,MessageSource: UObject,bSuccess: boolean): void;
	SpawnDefaultController(): void;
	SetCanAffectNavigationGeneration(bNewValue: boolean): void;
	Unpossessed(OldController: Controller): void;
	Possessed(NewController: Controller): void;
	PawnMakeNoise(Loudness: number,NoiseLocation: Vector,bUseNoiseMakerLocation: boolean,NoiseMaker: Actor): void;
	OnRep_PlayerState(): void;
	OnRep_Controller(): void;
	LaunchPawn(LaunchVelocity: Vector,bXYOverride: boolean,bZOverride: boolean): void;
	GetMovementInputVector(): Vector;
	IsMoveInputIgnored(): boolean;
	IsLocallyControlled(): boolean;
	IsControlled(): boolean;
	GetPendingMovementInputVector(): Vector;
	GetNavAgentLocation(): Vector;
	GetMovementComponent(): PawnMovementComponent;
	static GetMovementBaseActor(Pawn: Pawn): Actor;
	GetLastMovementInputVector(): Vector;
	GetControlRotation(): Rotator;
	GetController(): Controller;
	GetBaseAimRotation(): Rotator;
	DetachFromControllerPendingDestroy(): void;
	ConsumeMovementInputVector(): Vector;
	AddMovementInput(WorldDirection: Vector,ScaleValue: number,bForce: boolean): void;
	AddControllerYawInput(Val: number): void;
	AddControllerRollInput(Val: number): void;
	AddControllerPitchInput(Val: number): void;
}

declare type ERadialImpulseFalloff = string;
declare class PrimitiveComponent extends SceneComponent { 
	MinDrawDistance: number;
	LDMaxDrawDistance: number;
	CachedMaxDrawDistance: number;
	DepthPriorityGroup: ESceneDepthPriorityGroup;
	ViewOwnerDepthPriorityGroup: ESceneDepthPriorityGroup;
	bAlwaysCreatePhysicsState: boolean;
	bGenerateOverlapEvents: boolean;
	bMultiBodyOverlap: boolean;
	bCheckAsyncSceneOnMove: boolean;
	bTraceComplexOnMove: boolean;
	bReturnMaterialOnMove: boolean;
	bUseViewOwnerDepthPriorityGroup: boolean;
	bAllowCullDistanceVolume: boolean;
	bHasMotionBlurVelocityMeshes: boolean;
	bRenderInMainPass: boolean;
	bReceivesDecals: boolean;
	bOwnerNoSee: boolean;
	bOnlyOwnerSee: boolean;
	bTreatAsBackgroundForOcclusion: boolean;
	bUseAsOccluder: boolean;
	bSelectable: boolean;
	bForceMipStreaming: boolean;
	bHasPerInstanceHitProxies: boolean;
	CastShadow: boolean;
	bAffectDynamicIndirectLighting: boolean;
	bAffectDistanceFieldLighting: boolean;
	bCastDynamicShadow: boolean;
	bCastStaticShadow: boolean;
	bCastVolumetricTranslucentShadow: boolean;
	bSelfShadowOnly: boolean;
	bCastFarShadow: boolean;
	bCastInsetShadow: boolean;
	bCastCinematicShadow: boolean;
	bCastHiddenShadow: boolean;
	bCastShadowAsTwoSided: boolean;
	bLightAsIfStatic: boolean;
	bLightAttachmentsAsGroup: boolean;
	IndirectLightingCacheQuality: EIndirectLightingCacheQuality;
	bHasCachedStaticLighting: boolean;
	bStaticLightingBuildEnqueued: boolean;
	bIgnoreRadialImpulse: boolean;
	bIgnoreRadialForce: boolean;
	AlwaysLoadOnClient: boolean;
	AlwaysLoadOnServer: boolean;
	bUseEditorCompositing: boolean;
	bRenderCustomDepth: boolean;
	CustomDepthStencilValue: number;
	TranslucencySortPriority: number;
	VisibilityId: number;
	LpvBiasMultiplier: number;
	BodyInstance: BodyInstance;
	bCanEverAffectNavigation: boolean;
	bHasCustomNavigableGeometry: EHasCustomNavigableGeometry;
	BoundsScale: number;
	LastSubmitTime: number;
	LastRenderTime: number;
	CanBeCharacterBase: ECanBeCharacterBase;
	CanCharacterStepUpOn: ECanBeCharacterBase;
	OnComponentHit: UnrealEngineMulticastDelegate<(OtherActor: Actor, OtherComp: PrimitiveComponent, NormalImpulse: Vector, Hit: HitResult) => void>;
	OnComponentBeginOverlap: UnrealEngineMulticastDelegate<(OtherActor: Actor, OtherComp: PrimitiveComponent, OtherBodyIndex: number, bFromSweep: boolean, SweepResult: HitResult) => void>;
	OnComponentEndOverlap: UnrealEngineMulticastDelegate<(OtherActor: Actor, OtherComp: PrimitiveComponent, OtherBodyIndex: number) => void>;
	OnComponentWake: UnrealEngineMulticastDelegate<(BoneName: string) => void>;
	OnComponentSleep: UnrealEngineMulticastDelegate<(BoneName: string) => void>;
	OnBeginCursorOver: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent) => void>;
	OnEndCursorOver: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent) => void>;
	OnClicked: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent) => void>;
	OnReleased: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent) => void>;
	OnInputTouchBegin: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	OnInputTouchEnd: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	OnInputTouchEnter: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	OnInputTouchLeave: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	LODParentPrimitive: PrimitiveComponent;
	PostPhysicsComponentTick: PrimitiveComponentPostPhysicsTickFunction;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PrimitiveComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PrimitiveComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveComponent;
	static C(Other: UObject): PrimitiveComponent;
	ComponentOverlapActors_DEPRECATED(ComponentTransform: Transform,Filter: EOverlapFilterOption,ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	ComponentOverlapActors(ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	ComponentOverlapComponents_DEPRECATED(ComponentTransform: Transform,Filter: EOverlapFilterOption,ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	ComponentOverlapComponents(ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	WakeRigidBody(BoneName: string): void;
	WakeAllRigidBodies(): void;
	SetWalkableSlopeOverride(NewOverride: WalkableSlopeOverride): void;
	SetTranslucentSortPriority(NewTranslucentSortPriority: number): void;
	SetSimulatePhysics(bSimulate: boolean): void;
	SetRenderInMainPass(bValue: boolean): void;
	SetRenderCustomDepth(bValue: boolean): void;
	SetPhysicalMaterialOverride(NewPhysMaterial: PhysicalMaterial): void;
	SetPhysicsMaxAngularVelocity(NewMaxAngVel: number,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsLinearVelocity(NewVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsAngularVelocity(NewAngVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	SetOwnerNoSee(bNewOwnerNoSee: boolean): void;
	SetOnlyOwnerSee(bNewOnlyOwnerSee: boolean): void;
	SetNotifyRigidBodyCollision(bNewNotifyRigidBodyCollision: boolean): void;
	SetMaterial(ElementIndex: number,Material: MaterialInterface): void;
	SetMassScale(BoneName: string,InMassScale: number): void;
	SetMassOverrideInKg(BoneName: string,MassInKg: number,bOverrideMass: boolean): void;
	SetLockedAxis(LockedAxis: EDOFMode): void;
	SetLinearDamping(InDamping: number): void;
	SetEnableGravity(bGravityEnabled: boolean): void;
	SetCustomDepthStencilValue(Value: number): void;
	SetMaxDrawDistance(NewCullDistance: number): void;
	SetConstraintMode(ConstraintMode: EDOFMode): void;
	SetCollisionResponseToChannel(Channel: ECollisionChannel,NewResponse: ECollisionResponse): void;
	SetCollisionResponseToAllChannels(NewResponse: ECollisionResponse): void;
	SetCollisionProfileName(InCollisionProfileName: string): void;
	SetCollisionObjectType(Channel: ECollisionChannel): void;
	SetCollisionEnabled(NewType: ECollisionEnabled): void;
	SetCenterOfMass(CenterOfMassOffset: Vector,BoneName: string): void;
	SetCastShadow(NewCastShadow: boolean): void;
	SetAngularDamping(InDamping: number): void;
	SetAllPhysicsLinearVelocity(NewVel: Vector,bAddToCurrent: boolean): void;
	SetAllMassScale(InMassScale: number): void;
	ScaleByMomentOfInertia(InputVector: Vector,BoneName: string): Vector;
	PutRigidBodyToSleep(BoneName: string): void;
	LineTraceComponent(TraceStart: Vector,TraceEnd: Vector,bTraceComplex: boolean,bShowTrace: boolean,HitLocation?: Vector,HitNormal?: Vector,BoneName?: string): {HitLocation: Vector, HitNormal: Vector, BoneName: string, $: boolean};
	IsOverlappingComponent(OtherComp: PrimitiveComponent): boolean;
	IsOverlappingActor(Other: Actor): boolean;
	IsGravityEnabled(): boolean;
	IgnoreActorWhenMoving(Actor: Actor,bShouldIgnore: boolean): void;
	GetWalkableSlopeOverride(): WalkableSlopeOverride;
	GetPhysicsLinearVelocityAtPoint(Point: Vector,BoneName: string): Vector;
	GetPhysicsLinearVelocity(BoneName: string): Vector;
	GetPhysicsAngularVelocity(BoneName: string): Vector;
	GetOverlappingComponents(InOverlappingComponents?: PrimitiveComponent[]): {InOverlappingComponents: PrimitiveComponent[]};
	GetOverlappingActors(OverlappingActors?: Actor[],ClassFilter?: UnrealEngineClass): {OverlappingActors: Actor[]};
	GetOverlapInfos(): OverlapInfo[];
	GetNumMaterials(): number;
	GetMaterial(ElementIndex: number): MaterialInterface;
	GetMassScale(BoneName: string): number;
	GetMass(): number;
	GetLinearDamping(): number;
	GetInertiaTensor(BoneName: string): Vector;
	GetCollisionResponseToChannel(Channel: ECollisionChannel): ECollisionResponse;
	GetCollisionProfileName(): string;
	GetCollisionObjectType(): ECollisionChannel;
	GetClosestPointOnCollision(Point: Vector,OutPointOnBody?: Vector,BoneName?: string): {OutPointOnBody: Vector, $: number};
	GetCenterOfMass(BoneName: string): Vector;
	GetAngularDamping(): number;
	CreateDynamicMaterialInstance(ElementIndex: number,SourceMaterial: MaterialInterface): MaterialInstanceDynamic;
	CreateMIDForElementFromMaterial(ElementIndex: number,Parent: MaterialInterface): MaterialInstanceDynamic;
	CreateMIDForElement(ElementIndex: number): MaterialInstanceDynamic;
	GetMoveIgnoreActors(): Actor[];
	ClearMoveIgnoreActors(): void;
	CanCharacterStepUp(Pawn: Pawn): boolean;
	AddTorque(Torque: Vector,BoneName: string,bAccelChange: boolean): void;
	AddRadialImpulse(Origin: Vector,Radius: number,Strength: number,Falloff: ERadialImpulseFalloff,bVelChange: boolean): void;
	AddRadialForce(Origin: Vector,Radius: number,Strength: number,Falloff: ERadialImpulseFalloff,bAccelChange: boolean): void;
	AddImpulseAtLocation(Impulse: Vector,Location: Vector,BoneName: string): void;
	AddImpulse(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
	AddForceAtLocation(Force: Vector,Location: Vector,BoneName: string): void;
	AddForce(Force: Vector,BoneName: string,bAccelChange: boolean): void;
	AddAngularImpulse(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
}

declare class BrushComponent extends PrimitiveComponent { 
	Brush: Model;
	BrushBodySetup: BodySetup;
	PrePivot: Vector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BrushComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BrushComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushComponent;
	static C(Other: UObject): BrushComponent;
}

declare class BuilderPoly { 
	VertexIndices: number[];
	Direction: number;
	ItemName: string;
	PolyFlags: number;
}

declare class BrushBuilder extends UObject { 
	BitmapFilename: string;
	ToolTip: string;
	NotifyBadParams: boolean;
	Vertices: Vector[];
	Polys: BuilderPoly[];
	Layer: string;
	MergeCoplanars: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BrushBuilder;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BrushBuilder;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushBuilder;
	static C(Other: UObject): BrushBuilder;
}

declare class GeomSelection { 
	Type: number;
	Index: number;
	SelectionIndex: number;
}

declare class Brush extends Actor { 
	BrushType: EBrushType;
	BrushColor: Color;
	PolyFlags: number;
	bColored: boolean;
	bSolidWhenSelected: boolean;
	bPlaceableFromClassBrowser: boolean;
	bNotForClientOrServer: boolean;
	Brush: Model;
	BrushComponent: BrushComponent;
	BrushBuilder: BrushBuilder;
	bInManipulation: boolean;
	SavedSelections: GeomSelection[];
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Brush;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Brush;
	static C(Other: UObject): Brush;
}

declare class Volume extends Brush { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Volume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Volume;
	static C(Other: UObject): Volume;
}

declare class PhysicsVolume extends Volume { 
	TerminalVelocity: number;
	Priority: number;
	FluidFriction: number;
	bWaterVolume: boolean;
	bPhysicsOnContact: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PhysicsVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsVolume;
	static C(Other: UObject): PhysicsVolume;
}

declare type EMoveComponentAction = string;
declare type ERelativeTransformSpace = string;
declare class SceneComponent extends ActorComponent { 
	AttachParent: SceneComponent;
	AttachChildren: SceneComponent[];
	AttachSocketName: string;
	bRequiresCustomLocation: boolean;
	bAbsoluteLocation: boolean;
	bAbsoluteTranslation: boolean;
	bAbsoluteRotation: boolean;
	bAbsoluteScale: boolean;
	bVisible: boolean;
	bHiddenInGame: boolean;
	bShouldUpdatePhysicsVolume: boolean;
	bBoundsChangeTriggersStreamingDataRebuild: boolean;
	bUseAttachParentBound: boolean;
	bWorldToComponentUpdated: boolean;
	PhysicsVolume: any;
	RelativeLocation: Vector;
	RelativeRotation: Rotator;
	RelativeScale3D: Vector;
	RelativeTranslation: Vector;
	Mobility: EComponentMobility;
	DetailMode: EDetailMode;
	ComponentVelocity: Vector;
	PhysicsVolumeChangedDelegate: UnrealEngineMulticastDelegate<(NewVolume: PhysicsVolume) => void>;
	bVisualizeComponent: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SceneComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SceneComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneComponent;
	static C(Other: UObject): SceneComponent;
	SetMobile(): void;
	SetMobility(Type: EComponentMobility): void;
	GetComponentBounds(Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	MoveComponentTo(TargetRelativeLocation: Vector,TargetRelativeRotation: Rotator,bEaseOut: boolean,bEaseIn: boolean,OverTime: number,MoveAction: EMoveComponentAction,LatentInfo: LatentActionInfo): void;
	ToggleVisibility(bPropagateToChildren: boolean): void;
	SnapTo(InParent: SceneComponent,InSocketName: string): void;
	SetWorldScale3D(NewScale: Vector): void;
	SetVisibility(bNewVisibility: boolean,bPropagateToChildren: boolean): void;
	SetRelativeScale3D(NewScale3D: Vector): void;
	SetHiddenInGame(NewHidden: boolean,bPropagateToChildren: boolean): void;
	SetAbsolute(bNewAbsoluteLocation: boolean,bNewAbsoluteRotation: boolean,bNewAbsoluteScale: boolean): void;
	ResetRelativeTransform(): void;
	OnRep_Visibility(OldValue: boolean): void;
	OnRep_Transform(): void;
	SetWorldTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	SetWorldRotation(NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	SetWorldLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	SetWorldLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	SetRelativeTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	SetRelativeRotation(NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	SetRelativeLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	SetRelativeLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	GetWorldTransform(): Transform;
	GetWorldScale(): Vector;
	GetWorldRotation(): Rotator;
	GetWorldLocation(): Vector;
	AttachTo(InParent: SceneComponent,InSocketName: string,AttachType: EAttachLocation,bWeldSimulatedBodies: boolean): void;
	AddWorldTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	AddWorldRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	AddWorldOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	AddRelativeRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	AddRelativeLocation(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	AddLocalTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	AddLocalRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	AddLocalOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	IsVisible(): boolean;
	IsSimulatingPhysics(BoneName: string): boolean;
	IsAnySimulatingPhysics(): boolean;
	GetUpVector(): Vector;
	GetSocketTransform(InSocketName: string,TransformSpace: ERelativeTransformSpace): Transform;
	GetSocketRotation(InSocketName: string): Rotator;
	GetSocketQuaternion(InSocketName: string): Quat;
	GetSocketLocation(InSocketName: string): Vector;
	GetRightVector(): Vector;
	GetRelativeTransform(): Transform;
	GetPhysicsVolume(): PhysicsVolume;
	GetParentComponents(Parents?: SceneComponent[]): {Parents: SceneComponent[]};
	GetNumChildrenComponents(): number;
	GetForwardVector(): Vector;
	GetComponentVelocity(): Vector;
	GetChildrenComponents(bIncludeAllDescendants: boolean,Children?: SceneComponent[]): {Children: SceneComponent[]};
	GetChildComponent(ChildIndex: number): SceneComponent;
	GetAttachParent(): SceneComponent;
	GetAllSocketNames(): string[];
	DoesSocketExist(InSocketName: string): boolean;
	DetachFromParent(bMaintainWorldPosition: boolean,bCallModify: boolean): void;
}

declare class RepAttachment { 
	AttachParent: Actor;
	LocationOffset: Vector_NetQuantize100;
	RelativeScale3D: Vector_NetQuantize100;
	RotationOffset: Rotator;
	AttachSocket: string;
	AttachComponent: SceneComponent;
}

declare class Key { 
	KeyName: string;
}

declare type EControllerAnalogStick = string;
declare class InputComponent extends ActorComponent { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InputComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InputComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputComponent;
	static C(Other: UObject): InputComponent;
	WasControllerKeyJustReleased(Key: Key): boolean;
	WasControllerKeyJustPressed(Key: Key): boolean;
	IsControllerKeyDown(Key: Key): boolean;
	GetTouchState(FingerIndex: number,LocationX?: number,LocationY?: number,bIsCurrentlyPressed?: boolean): {LocationX: number, LocationY: number, bIsCurrentlyPressed: boolean};
	GetControllerVectorKeyState(Key: Key): Vector;
	GetControllerMouseDelta(DeltaX?: number,DeltaY?: number): {DeltaX: number, DeltaY: number};
	GetControllerKeyTimeDown(Key: Key): number;
	GetControllerAnalogStickState(WhichStick: EControllerAnalogStick,StickX?: number,StickY?: number): {StickX: number, StickY: number};
	GetControllerAnalogKeyState(Key: Key): number;
}

declare type EInputConsumeOptions = string;
declare class InterpFilter extends UObject { 
	Caption: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpFilter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpFilter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpFilter;
	static C(Other: UObject): InterpFilter;
}

declare class InterpGroupDirector extends InterpGroup { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpGroupDirector;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpGroupDirector;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpGroupDirector;
	static C(Other: UObject): InterpGroupDirector;
}

declare class InterpData extends UObject { 
	InterpLength: number;
	PathBuildTime: number;
	InterpGroups: InterpGroup[];
	CurveEdSetup: InterpCurveEdSetup;
	InterpFilters: InterpFilter[];
	SelectedFilter: InterpFilter;
	DefaultFilters: InterpFilter[];
	EdSectionStart: number;
	EdSectionEnd: number;
	bShouldBakeAndPrune: boolean;
	CachedDirectorGroup: InterpGroupDirector;
	AllEventNames: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpData;
	static C(Other: UObject): InterpData;
}

declare class InterpGroupActorInfo { 
	ObjectName: string;
	Actors: Actor[];
}

declare class CameraCutInfo { 
	Location: Vector;
	TimeStamp: number;
}

declare class MatineeActor extends Actor { 
	MatineeData: InterpData;
	MatineeControllerName: string;
	PlayRate: number;
	bPlayOnLevelLoad: boolean;
	bForceStartPos: boolean;
	ForceStartPosition: number;
	bLooping: boolean;
	bRewindOnPlay: boolean;
	bNoResetOnRewind: boolean;
	bRewindIfAlreadyPlaying: boolean;
	bDisableRadioFilter: boolean;
	bClientSideOnly: boolean;
	bSkipUpdateIfNotVisible: boolean;
	bIsSkippable: boolean;
	PreferredSplitScreenNum: number;
	bDisableMovementInput: boolean;
	bDisableLookAtInput: boolean;
	bHidePlayer: boolean;
	bHideHud: boolean;
	GroupActorInfos: InterpGroupActorInfo[];
	bShouldShowGore: boolean;
	GroupInst: InterpGroupInst[];
	CameraCuts: CameraCutInfo[];
	SpriteComponent: BillboardComponent;
	bIsBeingEdited: boolean;
	bIsScrubbing: boolean;
	bIsPlaying: boolean;
	bReversePlayback: boolean;
	bPaused: boolean;
	bPendingStop: boolean;
	InterpPosition: number;
	ReplicationForceIsPlaying: number;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MatineeActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MatineeActor;
	static C(Other: UObject): MatineeActor;
	Stop(): void;
	SetPosition(NewPosition: number,bJump: boolean): void;
	SetLoopingState(bNewLooping: boolean): void;
	Reverse(): void;
	Play(): void;
	Pause(): void;
	ChangePlaybackDirection(): void;
}

declare class Actor extends UObject { 
	PrimaryActorTick: ActorTickFunction;
	CustomTimeDilation: number;
	bHidden: boolean;
	bNetTemporary: boolean;
	bNetStartup: boolean;
	bOnlyRelevantToOwner: boolean;
	bAlwaysRelevant: boolean;
	bReplicateMovement: boolean;
	bTearOff: boolean;
	bExchangedRoles: boolean;
	bPendingNetUpdate: boolean;
	bNetLoadOnClient: boolean;
	bNetUseOwnerRelevancy: boolean;
	bBlockInput: boolean;
	bActorEnableCollision: boolean;
	bReplicates: boolean;
	RemoteRole: ENetRole;
	Owner: Actor;
	ReplicatedMovement: RepMovement;
	AttachmentReplication: RepAttachment;
	Role: ENetRole;
	AutoReceiveInput: EAutoReceiveInput;
	InputPriority: number;
	InputComponent: InputComponent;
	InputConsumeOption: EInputConsumeOptions;
	NetCullDistanceSquared: number;
	NetTag: number;
	NetUpdateTime: number;
	NetUpdateFrequency: number;
	NetPriority: number;
	LastNetUpdateTime: number;
	NetDriverName: string;
	bAutoDestroyWhenFinished: boolean;
	bCanBeDamaged: boolean;
	bActorIsBeingDestroyed: boolean;
	bCollideWhenPlacing: boolean;
	bFindCameraComponentWhenViewTarget: boolean;
	bRelevantForNetworkReplays: boolean;
	SpawnCollisionHandlingMethod: ESpawnActorCollisionHandlingMethod;
	Instigator: Pawn;
	Children: Actor[];
	RootComponent: SceneComponent;
	PivotOffset: Vector;
	ControllingMatineeActors: MatineeActor[];
	InitialLifeSpan: number;
	bAllowReceiveTickEventOnDedicatedServer: boolean;
	Layers: string[];
	bActorLabelEditable: boolean;
	ActorLabel: string;
	FolderPath: string;
	bHiddenEd: boolean;
	bEditable: boolean;
	bListedInSceneOutliner: boolean;
	bHiddenEdLayer: boolean;
	bHiddenEdTemporary: boolean;
	bHiddenEdLevel: boolean;
	bLockLocation: boolean;
	GroupActor: Actor;
	SpriteScale: number;
	ParentComponentActor: any;
	bActorSeamlessTraveled: boolean;
	bIgnoresOriginShifting: boolean;
	bEnableAutoLODGeneration: boolean;
	Tags: string[];
	HiddenEditorViews: any;
	OnTakeAnyDamage: UnrealEngineMulticastDelegate<(Damage: number, DamageType: DamageType, InstigatedBy: Controller, DamageCauser: Actor) => void>;
	OnTakePointDamage: UnrealEngineMulticastDelegate<(Damage: number, InstigatedBy: Controller, HitLocation: Vector, FHitComponent: PrimitiveComponent, BoneName: string, ShotFromDirection: Vector, DamageType: DamageType, DamageCauser: Actor) => void>;
	OnActorBeginOverlap: UnrealEngineMulticastDelegate<(OtherActor: Actor) => void>;
	OnActorEndOverlap: UnrealEngineMulticastDelegate<(OtherActor: Actor) => void>;
	OnBeginCursorOver: UnrealEngineMulticastDelegate<() => void>;
	OnEndCursorOver: UnrealEngineMulticastDelegate<() => void>;
	OnClicked: UnrealEngineMulticastDelegate<() => void>;
	OnReleased: UnrealEngineMulticastDelegate<() => void>;
	OnInputTouchBegin: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex) => void>;
	OnInputTouchEnd: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex) => void>;
	OnInputTouchEnter: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex) => void>;
	OnInputTouchLeave: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex) => void>;
	OnActorHit: UnrealEngineMulticastDelegate<(SelfActor: Actor, OtherActor: Actor, NormalImpulse: Vector, Hit: HitResult) => void>;
	OnDestroyed: UnrealEngineMulticastDelegate<() => void>;
	OnEndPlay: UnrealEngineMulticastDelegate<(EndPlayReason: EEndPlayReason) => void>;
	BlueprintCreatedComponents: ActorComponent[];
	InstanceComponents: ActorComponent[];
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Actor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Actor;
	static C(Other: UObject): Actor;
	Actor_GetWorld(): World;
	SetRootComponent(Component: SceneComponent): void;
	GetActorBounds(Origin?: Vector,BoxExtent?: Vector): {Origin: Vector, BoxExtent: Vector};
	ApplyDamage(BaseDamage: number,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): void;
	ApplyPointDamage(BaseDamage: number,HitFromDirection: Vector,HitInfo: HitResult,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): void;
	FinishSpawningActor(SpawnTransform: Transform): Actor;
	GetAIController(): AIController;
	GetBlackboard(): BlackboardComponent;
	ConstructionScript(): void;
	TearOff(): void;
	SnapActorTo(InParentActor: Actor,InSocketName: string): void;
	SetTickGroup(NewTickGroup: ETickingGroup): void;
	SetTickableWhenPaused(bTickableWhenPaused: boolean): void;
	SetReplicates(bInReplicates: boolean): void;
	SetReplicateMovement(bInReplicateMovement: boolean): void;
	SetOwner(NewOwner: Actor): void;
	SetLifeSpan(InLifespan: number): void;
	SetActorTickEnabled(bEnabled: boolean): void;
	SetActorScale3D(NewScale3D: Vector): void;
	SetActorRotation(NewRotation: Rotator): boolean;
	SetActorRelativeScale3D(NewRelativeScale: Vector): void;
	SetActorHiddenInGame(bNewHidden: boolean): void;
	SetActorEnableCollision(bNewActorEnableCollision: boolean): void;
	RemoveTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	RemoveTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	Tick(DeltaSeconds: number): void;
	RadialDamage(DamageReceived: number,DamageType: DamageType,Origin: Vector,HitInfo: HitResult,InstigatedBy: Controller,DamageCauser: Actor): void;
	PointDamage(Damage: number,DamageType: DamageType,HitLocation: Vector,HitNormal: Vector,HitComponent: PrimitiveComponent,BoneName: string,ShotFromDirection: Vector,InstigatedBy: Controller,DamageCauser: Actor): void;
	Hit(MyComp: PrimitiveComponent,Other: Actor,OtherComp: PrimitiveComponent,bSelfMoved: boolean,HitLocation: Vector,HitNormal: Vector,NormalImpulse: Vector,Hit: HitResult): void;
	EndPlay(EndPlayReason: EEndPlayReason): void;
	Destroyed(): void;
	BeginPlay(): void;
	AnyDamage(Damage: number,DamageType: DamageType,InstigatedBy: Controller,DamageCauser: Actor): void;
	ActorOnReleased(): void;
	TouchLeave(FingerIndex: ETouchIndex): void;
	TouchEnter(FingerIndex: ETouchIndex): void;
	EndInputTouch(FingerIndex: ETouchIndex): void;
	BeginInputTouch(FingerIndex: ETouchIndex): void;
	ActorOnClicked(): void;
	ActorEndOverlap(OtherActor: Actor): void;
	ActorEndCursorOver(): void;
	ActorBeginOverlap(OtherActor: Actor): void;
	ActorBeginCursorOver(): void;
	OnRep_ReplicateMovement(): void;
	OnRep_ReplicatedMovement(): void;
	OnRep_Instigator(): void;
	OnRep_AttachmentReplication(): void;
	MakeNoise(Loudness: number,NoiseInstigator: Pawn,NoiseLocation: Vector,MaxRange: number,Tag: string): void;
	MakeMIDForMaterial(Parent: MaterialInterface): MaterialInstanceDynamic;
	Teleport(DestLocation: Vector,DestRotation: Rotator): boolean;
	SetActorTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	SetActorRelativeTransform(NewRelativeTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	SetActorRelativeRotation(NewRelativeRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	SetActorRelativeLocation(NewRelativeLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	SetActorLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	SetActorLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	OnReset(): void;
	OnEndViewTarget(PC: PlayerController): void;
	OnBecomeViewTarget(PC: PlayerController): void;
	GetRootComponent(): SceneComponent;
	GetActorRotation(): Rotator;
	GetActorLocation(): Vector;
	DestroyComponent(Component: ActorComponent): void;
	DestroyActor(): void;
	AttachActorToActor(InParentActor: Actor,InSocketName: string,AttachLocationType: EAttachLocation,bWeldSimulatedBodies: boolean): void;
	AttachActorToComponent(InParent: SceneComponent,InSocketName: string,AttachLocationType: EAttachLocation,bWeldSimulatedBodies: boolean): void;
	AddActorWorldTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	AddActorWorldRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	AddActorWorldOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	AddActorLocalTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	AddActorLocalRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	AddActorLocalOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	IsOverlappingActor(Other: Actor): boolean;
	IsActorTickEnabled(): boolean;
	IsActorBeingDestroyed(): boolean;
	HasAuthority(): boolean;
	GetVerticalDistanceTo(OtherActor: Actor): number;
	GetVelocity(): Vector;
	GetActorTransform(): Transform;
	GetTickableWhenPaused(): boolean;
	GetOwner(): Actor;
	GetOverlappingComponents(OverlappingComponents?: PrimitiveComponent[]): {OverlappingComponents: PrimitiveComponent[]};
	GetOverlappingActors(OverlappingActors?: Actor[],ClassFilter?: UnrealEngineClass): {OverlappingActors: Actor[]};
	GetLifeSpan(): number;
	GetInstigatorController(): Controller;
	GetInstigator(): Pawn;
	GetInputVectorAxisValue(InputAxisKey: Key): Vector;
	GetInputAxisValue(InputAxisName: string): number;
	GetInputAxisKeyValue(InputAxisKey: Key): number;
	GetHorizontalDotProductTo(OtherActor: Actor): number;
	GetHorizontalDistanceTo(OtherActor: Actor): number;
	GetDotProductTo(OtherActor: Actor): number;
	GetDistanceTo(OtherActor: Actor): number;
	GetComponentsByTag(ComponentClass: UnrealEngineClass,Tag: string): ActorComponent[];
	GetComponentsByClass(ComponentClass: UnrealEngineClass): ActorComponent[];
	GetComponentByClass(ComponentClass: UnrealEngineClass): ActorComponent;
	GetActorUpVector(): Vector;
	GetActorTimeDilation(): number;
	GetActorScale3D(): Vector;
	GetActorRightVector(): Vector;
	GetActorRelativeScale3D(): Vector;
	GetActorForwardVector(): Vector;
	GetActorEyesViewPoint(OutLocation?: Vector,OutRotation?: Rotator): {OutLocation: Vector, OutRotation: Rotator};
	GetActorEnableCollision(): boolean;
	GetActorBounds(bOnlyCollidingComponents: boolean,Origin?: Vector,BoxExtent?: Vector): {Origin: Vector, BoxExtent: Vector};
	ForceNetUpdate(): void;
	FlushNetDormancy(): void;
	EnableInput(PlayerController: PlayerController): void;
	DisableInput(PlayerController: PlayerController): void;
	DetachActorFromActor(bMaintainWorldPosition: boolean): void;
	AddTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	AddTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	AddComponent(TemplateName: string,bManualAttachment: boolean,RelativeTransform: Transform,ComponentTemplateContext: UObject): ActorComponent;
	ActorHasTag(Tag: string): boolean;
}

declare class Controller extends Actor { 
	Pawn: Pawn;
	Character: Character;
	PlayerState: PlayerState;
	TransformComponent: SceneComponent;
	ControlRotation: Rotator;
	bAttachToPawn: boolean;
	StateName: string;
	OnInstigatedAnyDamage: UnrealEngineMulticastDelegate<(Damage: number, DamageType: DamageType, DamagedActor: Actor, DamageCauser: Actor) => void>;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Controller;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Controller;
	static C(Other: UObject): Controller;
	SimpleMoveToActor(Goal: Actor): void;
	SimpleMoveToLocation(Goal: Vector): void;
	UnPossess(): void;
	StopMovement(): void;
	SetInitialLocationAndRotation(NewLocation: Vector,NewRotation: Rotator): void;
	SetControlRotation(NewRotation: Rotator): void;
	ReceiveInstigatedAnyDamage(Damage: number,DamageType: DamageType,DamagedActor: Actor,DamageCauser: Actor): void;
	Possess(InPawn: Pawn): void;
	OnRep_PlayerState(): void;
	OnRep_Pawn(): void;
	LineOfSightTo(Other: Actor,ViewPoint: Vector,bAlternateChecks: boolean): boolean;
	GetControlledPawn(): Pawn;
	IsLocalPlayerController(): boolean;
	IsLocalController(): boolean;
	GetViewTarget(): Actor;
	GetDesiredRotation(): Rotator;
	GetControlRotation(): Rotator;
	ClientSetRotation(NewRotation: Rotator,bResetCamera: boolean): void;
	ClientSetLocation(NewLocation: Vector,NewRotation: Rotator): void;
	CastToPlayerController(): PlayerController;
}

declare class InterpTrackInstDirector extends InterpTrackInst { 
	OldViewTarget: Actor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstDirector;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstDirector;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstDirector;
	static C(Other: UObject): InterpTrackInstDirector;
}

declare class DebugCameraController extends PlayerController { 
	bShowSelectedInfo: boolean;
	bIsFrozenRendering: boolean;
	DrawFrustum: DrawFrustumComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DebugCameraController;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DebugCameraController;
	static C(Other: UObject): DebugCameraController;
	ShowDebugSelectedInfo(): void;
}

declare class CheatManager extends UObject { 
	DebugCameraControllerRef: DebugCameraController;
	DebugCameraControllerClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CheatManager;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CheatManager;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheatManager;
	static C(Other: UObject): CheatManager;
	WidgetReflector(): void;
	Walk(): void;
	ViewSelf(): void;
	ViewPlayer(S: string): void;
	ViewClass(DesiredClass: UnrealEngineClass): void;
	ViewActor(ActorName: string): void;
	ToggleDebugCamera(): void;
	ToggleAILogging(): void;
	TextureAtlasVisualizer(): void;
	TestCollisionDistance(): void;
	Teleport(): void;
	Summon(ClassName: string): void;
	StreamLevelOut(PackageName: string): void;
	StreamLevelIn(PackageName: string): void;
	Slomo(T: number): void;
	SetWorldOrigin(): void;
	SetNavDrawDistance(DrawDistance: number): void;
	SetMouseSensitivityToDefault(): void;
	ServerToggleAILogging(): void;
	RebuildNavigation(): void;
	PlayersOnly(): void;
	OnlyLoadLevel(PackageName: string): void;
	LogLoc(): void;
	InvertMouse(): void;
	God(): void;
	Ghost(): void;
	FreezeFrame(Delay: number): void;
	FontAtlasVisualizer(): void;
	Fly(): void;
	FlushLog(): void;
	DumpVoiceMutingState(): void;
	DumpPartyState(): void;
	DumpOnlineSessionState(): void;
	DestroyTarget(): void;
	DestroyPawns(aClass: UnrealEngineClass): void;
	DestroyAllPawnsExceptTarget(): void;
	DestroyAll(aClass: UnrealEngineClass): void;
	DebugCapsuleSweepSize(HalfHeight: number,Radius: number): void;
	DebugCapsuleSweepPawn(): void;
	DebugCapsuleSweepComplex(bTraceComplex: boolean): void;
	DebugCapsuleSweepClear(): void;
	DebugCapsuleSweepChannel(Channel: ECollisionChannel): void;
	DebugCapsuleSweepCapture(): void;
	DebugCapsuleSweep(): void;
	DamageTarget(DamageAmount: number): void;
	ChangeSize(F: number): void;
	BugItStringCreator(ViewLocation: Vector,ViewRotation: Rotator,GoString?: string,LocString?: string): {GoString: string, LocString: string};
	BugItGo(X: number,Y: number,Z: number,Pitch: number,Yaw: number,Roll: number): void;
	BugIt(ScreenShotDescription: string): void;
}

declare class KeyBind { 
	Key: Key;
	Command: string;
	Control: boolean;
	Shift: boolean;
	Alt: boolean;
	Cmd: boolean;
	bIgnoreCtrl: boolean;
	bIgnoreShift: boolean;
	bIgnoreAlt: boolean;
	bIgnoreCmd: boolean;
}

declare class PlayerInput extends UObject { 
	DebugExecBindings: KeyBind[];
	InvertedAxis: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PlayerInput;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PlayerInput;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerInput;
	static C(Other: UObject): PlayerInput;
	SetMouseSensitivity(Sensitivity: number): void;
	SetBind(BindName: string,Command: string): void;
	InvertAxisKey(AxisKey: Key): void;
	InvertAxis(AxisName: string): void;
	ClearSmoothing(): void;
}

declare class ForceFeedbackChannelDetails { 
	bAffectsLeftLarge: boolean;
	bAffectsLeftSmall: boolean;
	bAffectsRightLarge: boolean;
	bAffectsRightSmall: boolean;
	Curve: RuntimeFloatCurve;
}

declare class ForceFeedbackEffect extends UObject { 
	ChannelDetails: ForceFeedbackChannelDetails[];
	Duration: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ForceFeedbackEffect;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ForceFeedbackEffect;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ForceFeedbackEffect;
	static C(Other: UObject): ForceFeedbackEffect;
}

declare class ActiveForceFeedbackEffect { 
	ForceFeedbackEffect: ForceFeedbackEffect;
}

declare class TouchInputControl { 
	Image1: Texture2D;
	Image2: Texture2D;
	Center: Vector2D;
	VisualSize: Vector2D;
	ThumbSize: Vector2D;
	InteractionSize: Vector2D;
	InputScale: Vector2D;
	MainInputKey: Key;
	AltInputKey: Key;
}

declare class TouchInterface extends UObject { 
	Controls: TouchInputControl[];
	ActiveOpacity: number;
	InactiveOpacity: number;
	TimeUntilDeactive: number;
	TimeUntilReset: number;
	ActivationDelay: number;
	bPreventRecenter: boolean;
	StartupDelay: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TouchInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TouchInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TouchInterface;
	static C(Other: UObject): TouchInterface;
}

declare type EControllerHand = string;
declare type EViewTargetBlendFunction = string;
declare class ViewTargetTransitionParams { 
	BlendTime: number;
	BlendFunction: EViewTargetBlendFunction;
	BlendExp: number;
	bLockOutgoing: boolean;
}

declare class HapticFeedbackDetails { 
	Frequency: RuntimeFloatCurve;
	Amplitude: RuntimeFloatCurve;
}

declare class HapticFeedbackEffect extends UObject { 
	HapticDetails: HapticFeedbackDetails;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): HapticFeedbackEffect;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): HapticFeedbackEffect;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HapticFeedbackEffect;
	static C(Other: UObject): HapticFeedbackEffect;
}

declare type EDynamicForceFeedbackAction = string;
declare type ETravelType = string;
declare class PlayerController extends Controller { 
	Player: Player;
	AcknowledgedPawn: Pawn;
	ControllingDirTrackInst: InterpTrackInstDirector;
	MyHUD: HUD;
	PlayerCameraManager: PlayerCameraManager;
	PlayerCameraManagerClass: UnrealEngineClass;
	bAutoManageActiveCameraTarget: boolean;
	TargetViewRotation: Rotator;
	HiddenActors: Actor[];
	LastSpectatorStateSynchTime: number;
	LastSpectatorSyncLocation: Vector;
	LastSpectatorSyncRotation: Rotator;
	ClientCap: number;
	CheatManager: CheatManager;
	CheatClass: UnrealEngineClass;
	PlayerInput: PlayerInput;
	ActiveForceFeedbackEffects: ActiveForceFeedbackEffect[];
	bPlayerIsWaiting: boolean;
	NetPlayerIndex: number;
	PendingSwapConnection: NetConnection;
	NetConnection: NetConnection;
	InputYawScale: number;
	InputPitchScale: number;
	InputRollScale: number;
	bShowMouseCursor: boolean;
	bEnableClickEvents: boolean;
	bEnableTouchEvents: boolean;
	bEnableMouseOverEvents: boolean;
	bEnableTouchOverEvents: boolean;
	bForceFeedbackEnabled: boolean;
	DefaultMouseCursor: EMouseCursor;
	CurrentMouseCursor: EMouseCursor;
	DefaultClickTraceChannel: ECollisionChannel;
	CurrentClickTraceChannel: ECollisionChannel;
	HitResultTraceDistance: number;
	InactiveStateInputComponent: InputComponent;
	CurrentTouchInterface: TouchInterface;
	SpectatorPawn: SpectatorPawn;
	SpawnLocation: Vector;
	bIsLocalPlayerController: boolean;
	SeamlessTravelCount: any;
	LastCompletedSeamlessTravelCount: any;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PlayerController;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerController;
	static C(Other: UObject): PlayerController;
	WriteLeaderboardInteger(StatName: string,StatValue: number): boolean;
	IsLoggedIn(): boolean;
	ShowPlatformSpecificAchievementsScreen(): void;
	DeprojectScreenToWorld(ScreenPosition: Vector2D,WorldPosition?: Vector,WorldDirection?: Vector): {WorldPosition: Vector, WorldDirection: Vector, $: boolean};
	ProjectWorldToScreen(WorldPosition: Vector,ScreenPosition?: Vector2D): {ScreenPosition: Vector2D, $: boolean};
	RemovePlayer(bDestroyPawn: boolean): void;
	GetMousePositionScaledByDPI(LocationX?: number,LocationY?: number): {LocationX: number, LocationY: number, $: boolean};
	ProjectWorldLocationToWidgetPosition(WorldLocation: Vector,ScreenPosition?: Vector2D): {ScreenPosition: Vector2D, $: boolean};
	SetInputMode_GameAndUI(InWidgetToFocus: Widget,bLockMouseToViewport: boolean,bHideCursorDuringCapture: boolean): void;
	SetInputMode_GameOnly(): void;
	SetInputMode_UIOnly(InWidgetToFocus: Widget,bLockMouseToViewport: boolean): void;
	WasInputKeyJustReleased(Key: Key): boolean;
	WasInputKeyJustPressed(Key: Key): boolean;
	ToggleSpeaking(bInSpeaking: boolean): void;
	SwitchLevel(URL: string): void;
	StopHapticEffect(Hand: EControllerHand): void;
	StartFire(FireModeNum: number): void;
	SetVirtualJoystickVisibility(bVisible: boolean): void;
	SetViewTargetWithBlend(NewViewTarget: Actor,BlendTime: number,BlendFunc: EViewTargetBlendFunction,BlendExp: number,bLockOutgoing: boolean): void;
	SetName(S: string): void;
	SetIgnoreMoveInput(bNewMoveInput: boolean): void;
	SetIgnoreLookInput(bNewLookInput: boolean): void;
	SetHapticsByValue(Frequency: number,Amplitude: number,Hand: EControllerHand): void;
	SetCinematicMode(bInCinematicMode: boolean,bHidePlayer: boolean,bAffectsHUD: boolean,bAffectsMovement: boolean,bAffectsTurning: boolean): void;
	SetAudioListenerOverride(AttachToComponent: SceneComponent,Location: Vector,Rotation: Rotator): void;
	ServerViewSelf(TransitionParams: ViewTargetTransitionParams): void;
	ServerViewPrevPlayer(): void;
	ServerViewNextPlayer(): void;
	ServerVerifyViewTarget(): void;
	ServerUpdateLevelVisibility(PackageName: string,bIsVisible: boolean): void;
	ServerUpdateCamera(CamLoc: Vector_NetQuantize,CamPitchAndYaw: number): void;
	ServerUnmutePlayer(PlayerId: UniqueNetIdRepl): void;
	ServerToggleAILogging(): void;
	ServerShortTimeout(): void;
	ServerSetSpectatorWaiting(bWaiting: boolean): void;
	ServerSetSpectatorLocation(NewLoc: Vector,NewRot: Rotator): void;
	ServerRestartPlayer(): void;
	ServerPause(): void;
	ServerNotifyLoadedWorld(WorldPackageName: string): void;
	ServerMutePlayer(PlayerId: UniqueNetIdRepl): void;
	ServerCheckClientPossessionReliable(): void;
	ServerCheckClientPossession(): void;
	ServerChangeName(S: string): void;
	ServerCamera(NewMode: string): void;
	ServerAcknowledgePossession(P: Pawn): void;
	SendToConsole(Command: string): void;
	RestartLevel(): void;
	ResetIgnoreMoveInput(): void;
	ResetIgnoreLookInput(): void;
	ResetIgnoreInputFlags(): void;
	ConvertWorldLocationToScreenLocation(WorldLocation: Vector,ScreenLocation?: Vector2D): {ScreenLocation: Vector2D, $: boolean};
	PlayHapticEffect(HapticEffect: HapticFeedbackEffect,Hand: EControllerHand,Scale: number): void;
	PlayDynamicForceFeedback(Intensity: number,Duration: number,bAffectsLeftLarge: boolean,bAffectsLeftSmall: boolean,bAffectsRightLarge: boolean,bAffectsRightSmall: boolean,Action: EDynamicForceFeedbackAction,LatentInfo: LatentActionInfo): void;
	Pause(): void;
	OnServerStartedVisualLogger(bIsLogging: boolean): void;
	LocalTravel(URL: string): void;
	IsMoveInputIgnored(): boolean;
	IsLookInputIgnored(): boolean;
	IsInputKeyDown(Key: Key): boolean;
	GetViewportSize(SizeX?: number,SizeY?: number): {SizeX: number, SizeY: number};
	GetSpectatorPawn(): SpectatorPawn;
	GetMousePosition(LocationX?: number,LocationY?: number): {LocationX: number, LocationY: number, $: boolean};
	GetInputVectorKeyState(Key: Key): Vector;
	GetInputTouchState(FingerIndex: ETouchIndex,LocationX?: number,LocationY?: number,bIsCurrentlyPressed?: boolean): {LocationX: number, LocationY: number, bIsCurrentlyPressed: boolean};
	GetInputMouseDelta(DeltaX?: number,DeltaY?: number): {DeltaX: number, DeltaY: number};
	GetInputMotionState(Tilt?: Vector,RotationRate?: Vector,Gravity?: Vector,Acceleration?: Vector): {Tilt: Vector, RotationRate: Vector, Gravity: Vector, Acceleration: Vector};
	GetInputKeyTimeDown(Key: Key): number;
	GetInputAnalogStickState(WhichStick: EControllerAnalogStick,StickX?: number,StickY?: number): {StickX: number, StickY: number};
	GetInputAnalogKeyState(Key: Key): number;
	GetHUD(): HUD;
	GetHitResultUnderFingerForObjects(FingerIndex: ETouchIndex,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	GetHitResultUnderFingerByChannel(FingerIndex: ETouchIndex,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	GetHitResultUnderFinger(FingerIndex: ETouchIndex,TraceChannel: ECollisionChannel,bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	GetHitResultUnderCursorForObjects(ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	GetHitResultUnderCursorByChannel(TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	GetHitResultUnderCursor(TraceChannel: ECollisionChannel,bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	GetFocalLocation(): Vector;
	FOV(NewFOV: number): void;
	EnableCheats(): void;
	ConvertScreenLocationToWorldSpace(ScreenX: number,ScreenY: number,WorldLocation?: Vector,WorldDirection?: Vector): {WorldLocation: Vector, WorldDirection: Vector, $: boolean};
	ConvertMouseLocationToWorldSpace(WorldLocation?: Vector,WorldDirection?: Vector): {WorldLocation: Vector, WorldDirection: Vector, $: boolean};
	ConsoleKey(Key: Key): void;
	ClientWasKicked(KickReason: string): void;
	ClientVoiceHandshakeComplete(): void;
	ClientUpdateLevelStreamingStatus(PackageName: string,bNewShouldBeLoaded: boolean,bNewShouldBeVisible: boolean,bNewShouldBlockOnLoad: boolean,LODIndex: number): void;
	ClientUnmutePlayer(PlayerId: UniqueNetIdRepl): void;
	ClientTravelInternal(URL: string,TravelType: ETravelType,bSeamless: boolean,MapPackageGuid: Guid): void;
	ClientTravel(URL: string,TravelType: ETravelType,bSeamless: boolean,MapPackageGuid: Guid): void;
	ClientTeamMessage(SenderPlayerState: PlayerState,S: string,Type: string,MsgLifeTime: number): void;
	ClientStopForceFeedback(ForceFeedbackEffect: ForceFeedbackEffect,Tag: string): void;
	ClientStopCameraShake(Shake: UnrealEngineClass): void;
	ClientStopCameraAnim(AnimToStop: CameraAnim): void;
	ClientStartOnlineSession(): void;
	ClientSpawnCameraLensEffect(LensEffectEmitterClass: UnrealEngineClass): void;
	ClientSetViewTarget(A: Actor,TransitionParams: ViewTargetTransitionParams): void;
	ClientSetSpectatorWaiting(bWaiting: boolean): void;
	ClientSetHUD(NewHUDClass: UnrealEngineClass): void;
	ClientSetForceMipLevelsToBeResident(Material: MaterialInterface,ForceDuration: number,CinematicTextureGroups: number): void;
	ClientSetCinematicMode(bInCinematicMode: boolean,bAffectsMovement: boolean,bAffectsTurning: boolean,bAffectsHUD: boolean): void;
	ClientSetCameraMode(NewCamMode: string): void;
	ClientSetCameraFade(bEnableFading: boolean,FadeColor: Color,FadeAlpha: Vector2D,FadeTime: number,bFadeAudio: boolean): void;
	ClientSetBlockOnAsyncLoading(): void;
	ClientReturnToMainMenu(ReturnReason: string): void;
	ClientRetryClientRestart(NewPawn: Pawn): void;
	ClientRestart(NewPawn: Pawn): void;
	ClientReset(): void;
	ClientRepObjRef(UObject: UObject): void;
	ClientReceiveLocalizedMessage(Message: UnrealEngineClass,Switch: number,RelatedPlayerState_1: PlayerState,RelatedPlayerState_2: PlayerState,OptionalObject: UObject): void;
	ClientPrestreamTextures(ForcedActor: Actor,ForceDuration: number,bEnableStreaming: boolean,CinematicTextureGroups: number): void;
	ClientPrepareMapChange(LevelName: string,bFirst: boolean,bLast: boolean): void;
	ClientPlaySoundAtLocation(Sound: SoundBase,Location: Vector,VolumeMultiplier: number,PitchMultiplier: number): void;
	ClientPlaySound(Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number): void;
	ClientPlayForceFeedback(ForceFeedbackEffect: ForceFeedbackEffect,bLooping: boolean,Tag: string): void;
	ClientPlayCameraShake(Shake: UnrealEngineClass,Scale: number,PlaySpace: ECameraAnimPlaySpace,UserPlaySpaceRot: Rotator): void;
	ClientPlayCameraAnim(AnimToPlay: CameraAnim,Scale: number,Rate: number,BlendInTime: number,BlendOutTime: number,bLoop: boolean,bRandomStartTime: boolean,Space: ECameraAnimPlaySpace,CustomPlaySpace: Rotator): void;
	ClientMutePlayer(PlayerId: UniqueNetIdRepl): void;
	ClientMessage(S: string,Type: string,MsgLifeTime: number): void;
	ClientIgnoreMoveInput(bIgnore: boolean): void;
	ClientIgnoreLookInput(bIgnore: boolean): void;
	ClientGotoState(NewState: string): void;
	ClientGameEnded(EndGameFocus: Actor,bIsWinner: boolean): void;
	ClientForceGarbageCollection(): void;
	ClientFlushLevelStreaming(): void;
	ClientEndOnlineSession(): void;
	ClientEnableNetworkVoice(bEnable: boolean): void;
	ClientCommitMapChange(): void;
	ClientClearCameraLensEffects(): void;
	ClientCapBandwidth(Cap: number): void;
	ClientCancelPendingMapChange(): void;
	ClientAddTextureStreamingLoc(InLoc: Vector,Duration: number,bOverrideLocation: boolean): void;
	ClearAudioListenerOverride(): void;
	Camera(NewMode: string): void;
	AddYawInput(Val: number): void;
	AddRollInput(Val: number): void;
	AddPitchInput(Val: number): void;
	ActivateTouchInterface(NewTouchInterface: TouchInterface): void;
}

declare class Widget extends Visual { 
	bIsVariable: boolean;
	bCreatedByConstructionScript: boolean;
	Slot: PanelSlot;
	bIsEnabled: boolean;
	bIsEnabledDelegate: UnrealEngineDelegate<() => boolean>;
	ToolTipText: string;
	ToolTipTextDelegate: UnrealEngineDelegate<() => string>;
	ToolTipWidget: Widget;
	ToolTipWidgetDelegate: UnrealEngineDelegate<() => Widget>;
	Visiblity: ESlateVisibility;
	Visibility: ESlateVisibility;
	VisibilityDelegate: UnrealEngineDelegate<() => ESlateVisibility>;
	bOverride_Cursor: boolean;
	Cursor: EMouseCursor;
	bIsVolatile: boolean;
	RenderTransform: WidgetTransform;
	RenderTransformPivot: Vector2D;
	Navigation: WidgetNavigation;
	bHiddenInDesigner: boolean;
	bExpandedInDesigner: boolean;
	WidgetGeneratedBy: UObject;
	NativeBindings: PropertyBinding[];
	DesignerFlags: EWidgetDesignFlags;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Widget;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Widget;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Widget;
	static C(Other: UObject): Widget;
	SlotAsCanvasSlot(): CanvasPanelSlot;
	SlotAsGridSlot(): GridSlot;
	SlotAsHorizontalBoxSlot(): HorizontalBoxSlot;
	SlotAsOverlaySlot(): OverlaySlot;
	SlotAsUniformGridSlot(): UniformGridSlot;
	SlotAsVerticalBoxSlot(): VerticalBoxSlot;
	SetVisibility(InVisibility: ESlateVisibility): void;
	SetUserFocus(PlayerController: PlayerController): void;
	SetToolTipText(InToolTipText: string): void;
	SetToolTip(Widget: Widget): void;
	SetRenderTranslation(Translation: Vector2D): void;
	SetRenderTransformPivot(Pivot: Vector2D): void;
	SetRenderTransform(InTransform: WidgetTransform): void;
	SetRenderShear(Shear: Vector2D): void;
	SetRenderScale(Scale: Vector2D): void;
	SetRenderAngle(Angle: number): void;
	SetKeyboardFocus(): void;
	SetIsEnabled(bInIsEnabled: boolean): void;
	SetCursor(InCursor: EMouseCursor): void;
	ResetCursor(): void;
	RemoveFromParent(): void;
	IsVisible(): boolean;
	IsHovered(): boolean;
	InvalidateLayoutAndVolatility(): void;
	HasUserFocusedDescendants(PlayerController: PlayerController): boolean;
	HasUserFocus(PlayerController: PlayerController): boolean;
	HasMouseCapture(): boolean;
	HasKeyboardFocus(): boolean;
	HasAnyUserFocusedDescendants(): boolean;
	HasAnyUserFocus(): boolean;
	GetVisibility(): ESlateVisibility;
	GetParent(): PanelWidget;
	GetIsEnabled(): boolean;
	GetDesiredSize(): Vector2D;
	ForceVolatile(bForce: boolean): void;
	ForceLayoutPrepass(): void;
}

declare type EDragPivot = string;
declare class DragDropOperation extends UObject { 
	Tag: string;
	Payload: UObject;
	DefaultDragVisual: Widget;
	Pivot: EDragPivot;
	Offset: Vector2D;
	OnDrop: UnrealEngineMulticastDelegate<(Operation: DragDropOperation) => void>;
	OnDragCancelled: UnrealEngineMulticastDelegate<(Operation: DragDropOperation) => void>;
	OnDragged: UnrealEngineMulticastDelegate<(Operation: DragDropOperation) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DragDropOperation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DragDropOperation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DragDropOperation;
	static C(Other: UObject): DragDropOperation;
	Drop(UPointerEvent: UPointerEvent): void;
	Dragged(UPointerEvent: UPointerEvent): void;
	DragCancelled(UPointerEvent: UPointerEvent): void;
}

declare class Class extends Struct { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Class;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Class;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Class;
	static C(Other: UObject): Class;
	AddDynamicBinding(BindingObject: DynamicBlueprintBinding): void;
	GetDynamicBinding(BindingObjectClass: UnrealEngineClass): DynamicBlueprintBinding;
	Conv_AssetClassToClass(): UnrealEngineClass;
	GetDisplayName(): string;
	IsValidClass(): boolean;
	ClassIsChildOf(ParentClass: UnrealEngineClass): boolean;
	Equal(B: UnrealEngineClass): boolean;
	NotEqual(B: UnrealEngineClass): boolean;
	SelectClass(B: UnrealEngineClass,bSelectA: boolean): UnrealEngineClass;
	CreateSaveGameObject(): SaveGame;
	SpawnObject(Outer: UObject): UObject;
	CreateDragDropOperation(): DragDropOperation;
}

declare class UFunction extends Struct { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UFunction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UFunction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UFunction;
	static C(Other: UObject): UFunction;
}

declare class DelegateFunction extends UFunction { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DelegateFunction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DelegateFunction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DelegateFunction;
	static C(Other: UObject): DelegateFunction;
}

declare class Enum extends Field { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Enum;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Enum;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Enum;
	static C(Other: UObject): Enum;
	GetEnumeratorName(EnumeratorValue: number): string;
	GetEnumeratorUserFriendlyName(EnumeratorValue: number): string;
	GetValidIndex(EnumeratorIndex: number): number;
}

declare class LinkerPlaceholderClass extends Class { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LinkerPlaceholderClass;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LinkerPlaceholderClass;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkerPlaceholderClass;
	static C(Other: UObject): LinkerPlaceholderClass;
}

declare class LinkerPlaceholderExportObject extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LinkerPlaceholderExportObject;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LinkerPlaceholderExportObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkerPlaceholderExportObject;
	static C(Other: UObject): LinkerPlaceholderExportObject;
}

declare class LinkerPlaceholderFunction extends UFunction { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LinkerPlaceholderFunction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LinkerPlaceholderFunction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkerPlaceholderFunction;
	static C(Other: UObject): LinkerPlaceholderFunction;
}

declare class MetaData extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MetaData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MetaData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetaData;
	static C(Other: UObject): MetaData;
}

declare class ObjectRedirector extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ObjectRedirector;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ObjectRedirector;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectRedirector;
	static C(Other: UObject): ObjectRedirector;
}

declare class NumericProperty extends Property { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NumericProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NumericProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NumericProperty;
	static C(Other: UObject): NumericProperty;
}

declare class ArrayProperty extends Property { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ArrayProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ArrayProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ArrayProperty;
	static C(Other: UObject): ArrayProperty;
}

declare class ObjectPropertyBase extends Property { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ObjectPropertyBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ObjectPropertyBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectPropertyBase;
	static C(Other: UObject): ObjectPropertyBase;
}

declare class AssetObjectProperty extends ObjectPropertyBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AssetObjectProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AssetObjectProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetObjectProperty;
	static C(Other: UObject): AssetObjectProperty;
}

declare class AssetClassProperty extends AssetObjectProperty { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AssetClassProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AssetClassProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetClassProperty;
	static C(Other: UObject): AssetClassProperty;
}

declare class BoolProperty extends Property { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BoolProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BoolProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoolProperty;
	static C(Other: UObject): BoolProperty;
}

declare class ByteProperty extends NumericProperty { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ByteProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ByteProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ByteProperty;
	static C(Other: UObject): ByteProperty;
}

declare class ObjectProperty extends ObjectPropertyBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ObjectProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ObjectProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectProperty;
	static C(Other: UObject): ObjectProperty;
}

declare class ClassProperty extends ObjectProperty { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ClassProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ClassProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassProperty;
	static C(Other: UObject): ClassProperty;
}

declare class DelegateProperty extends Property { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DelegateProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DelegateProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DelegateProperty;
	static C(Other: UObject): DelegateProperty;
}

declare class DoubleProperty extends NumericProperty { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DoubleProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DoubleProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DoubleProperty;
	static C(Other: UObject): DoubleProperty;
}

declare class FloatProperty extends NumericProperty { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FloatProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FloatProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatProperty;
	static C(Other: UObject): FloatProperty;
}

declare class IntProperty extends NumericProperty { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): IntProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): IntProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntProperty;
	static C(Other: UObject): IntProperty;
}

declare class Int16Property extends NumericProperty { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Int16Property;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Int16Property;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int16Property;
	static C(Other: UObject): Int16Property;
}

declare class Int64Property extends NumericProperty { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Int64Property;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Int64Property;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int64Property;
	static C(Other: UObject): Int64Property;
}

declare class Int8Property extends NumericProperty { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Int8Property;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Int8Property;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int8Property;
	static C(Other: UObject): Int8Property;
}

declare class InterfaceProperty extends Property { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterfaceProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterfaceProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterfaceProperty;
	static C(Other: UObject): InterfaceProperty;
}

declare class LazyObjectProperty extends ObjectPropertyBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LazyObjectProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LazyObjectProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LazyObjectProperty;
	static C(Other: UObject): LazyObjectProperty;
}

declare class MapProperty extends Property { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MapProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MapProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MapProperty;
	static C(Other: UObject): MapProperty;
}

declare class MulticastDelegateProperty extends Property { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MulticastDelegateProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MulticastDelegateProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastDelegateProperty;
	static C(Other: UObject): MulticastDelegateProperty;
}

declare class NameProperty extends Property { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NameProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NameProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NameProperty;
	static C(Other: UObject): NameProperty;
}

declare class StrProperty extends Property { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): StrProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): StrProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StrProperty;
	static C(Other: UObject): StrProperty;
}

declare class StructProperty extends Property { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): StructProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): StructProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StructProperty;
	static C(Other: UObject): StructProperty;
}

declare class UInt16Property extends NumericProperty { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UInt16Property;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UInt16Property;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UInt16Property;
	static C(Other: UObject): UInt16Property;
}

declare class UInt32Property extends NumericProperty { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UInt32Property;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UInt32Property;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UInt32Property;
	static C(Other: UObject): UInt32Property;
}

declare class UInt64Property extends NumericProperty { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UInt64Property;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UInt64Property;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UInt64Property;
	static C(Other: UObject): UInt64Property;
}

declare class WeakObjectProperty extends ObjectPropertyBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WeakObjectProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WeakObjectProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WeakObjectProperty;
	static C(Other: UObject): WeakObjectProperty;
}

declare class TextProperty extends Property { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextProperty;
	static C(Other: UObject): TextProperty;
}

declare class InputCoreTypes extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InputCoreTypes;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InputCoreTypes;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputCoreTypes;
	static C(Other: UObject): InputCoreTypes;
}

declare class FontProviderInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FontProviderInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FontProviderInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontProviderInterface;
	static C(Other: UObject): FontProviderInterface;
}

declare class SlateTypes extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SlateTypes;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SlateTypes;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateTypes;
	static C(Other: UObject): SlateTypes;
}

declare class SlateWidgetStyleContainerInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SlateWidgetStyleContainerInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SlateWidgetStyleContainerInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateWidgetStyleContainerInterface;
	static C(Other: UObject): SlateWidgetStyleContainerInterface;
}

declare class SlateWidgetStyleContainerBase extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SlateWidgetStyleContainerBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SlateWidgetStyleContainerBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateWidgetStyleContainerBase;
	static C(Other: UObject): SlateWidgetStyleContainerBase;
}

declare class SlateWidgetStyleAsset extends UObject { 
	CustomStyle: SlateWidgetStyleContainerBase;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SlateWidgetStyleAsset;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SlateWidgetStyleAsset;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateWidgetStyleAsset;
	static C(Other: UObject): SlateWidgetStyleAsset;
}

declare class SlateWidgetStyle { 
}

declare class SlateSound { 
	ResourceObject: UObject;
}

declare class ButtonStyle extends SlateWidgetStyle { 
	Normal: SlateBrush;
	Hovered: SlateBrush;
	Pressed: SlateBrush;
	Disabled: SlateBrush;
	NormalPadding: Margin;
	PressedPadding: Margin;
	PressedSlateSound: SlateSound;
	HoveredSlateSound: SlateSound;
	PressedSound: string;
	HoveredSound: string;
}

declare class ButtonWidgetStyle extends SlateWidgetStyleContainerBase { 
	ButtonStyle: ButtonStyle;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ButtonWidgetStyle;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ButtonWidgetStyle;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ButtonWidgetStyle;
	static C(Other: UObject): ButtonWidgetStyle;
}

declare type ESlateCheckBoxType = string;
declare class CheckBoxStyle extends SlateWidgetStyle { 
	CheckBoxType: ESlateCheckBoxType;
	UncheckedImage: SlateBrush;
	UncheckedHoveredImage: SlateBrush;
	UncheckedPressedImage: SlateBrush;
	CheckedImage: SlateBrush;
	CheckedHoveredImage: SlateBrush;
	CheckedPressedImage: SlateBrush;
	UndeterminedImage: SlateBrush;
	UndeterminedHoveredImage: SlateBrush;
	UndeterminedPressedImage: SlateBrush;
	Padding: Margin;
	ForegroundColor: SlateColor;
	BorderBackgroundColor: SlateColor;
	CheckedSlateSound: SlateSound;
	UncheckedSlateSound: SlateSound;
	HoveredSlateSound: SlateSound;
	CheckedSound: string;
	UncheckedSound: string;
	HoveredSound: string;
}

declare class CheckBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	CheckBoxStyle: CheckBoxStyle;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CheckBoxWidgetStyle;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CheckBoxWidgetStyle;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckBoxWidgetStyle;
	static C(Other: UObject): CheckBoxWidgetStyle;
}

declare class ComboButtonStyle extends SlateWidgetStyle { 
	ButtonStyle: ButtonStyle;
	DownArrowImage: SlateBrush;
	MenuBorderBrush: SlateBrush;
	MenuBorderPadding: Margin;
}

declare class ComboBoxStyle extends SlateWidgetStyle { 
	ComboButtonStyle: ComboButtonStyle;
	PressedSlateSound: SlateSound;
	SelectionChangeSlateSound: SlateSound;
	PressedSound: string;
	SelectionChangeSound: string;
}

declare class ComboBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	ComboBoxStyle: ComboBoxStyle;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ComboBoxWidgetStyle;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ComboBoxWidgetStyle;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBoxWidgetStyle;
	static C(Other: UObject): ComboBoxWidgetStyle;
}

declare class ComboButtonWidgetStyle extends SlateWidgetStyleContainerBase { 
	ComboButtonStyle: ComboButtonStyle;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ComboButtonWidgetStyle;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ComboButtonWidgetStyle;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboButtonWidgetStyle;
	static C(Other: UObject): ComboButtonWidgetStyle;
}

declare class SlateFontInfo { 
	FontObject: UObject;
	FontMaterial: UObject;
	TypefaceFontName: string;
	Size: number;
	FontName: string;
	Hinting: EFontHinting;
}

declare class ScrollBarStyle extends SlateWidgetStyle { 
	HorizontalBackgroundImage: SlateBrush;
	VerticalBackgroundImage: SlateBrush;
	VerticalTopSlotImage: SlateBrush;
	HorizontalTopSlotImage: SlateBrush;
	VerticalBottomSlotImage: SlateBrush;
	HorizontalBottomSlotImage: SlateBrush;
	NormalThumbImage: SlateBrush;
	HoveredThumbImage: SlateBrush;
	DraggedThumbImage: SlateBrush;
}

declare class EditableTextBoxStyle extends SlateWidgetStyle { 
	BackgroundImageNormal: SlateBrush;
	BackgroundImageHovered: SlateBrush;
	BackgroundImageFocused: SlateBrush;
	BackgroundImageReadOnly: SlateBrush;
	Padding: Margin;
	Font: SlateFontInfo;
	ForegroundColor: SlateColor;
	BackgroundColor: SlateColor;
	ReadOnlyForegroundColor: SlateColor;
	HScrollBarPadding: Margin;
	VScrollBarPadding: Margin;
	ScrollBarStyle: ScrollBarStyle;
}

declare class EditableTextBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	EditableTextBoxStyle: EditableTextBoxStyle;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditableTextBoxWidgetStyle;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditableTextBoxWidgetStyle;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableTextBoxWidgetStyle;
	static C(Other: UObject): EditableTextBoxWidgetStyle;
}

declare class EditableTextStyle extends SlateWidgetStyle { 
	Font: SlateFontInfo;
	ColorAndOpacity: SlateColor;
	BackgroundImageSelected: SlateBrush;
	BackgroundImageComposing: SlateBrush;
	CaretImage: SlateBrush;
}

declare class EditableTextWidgetStyle extends SlateWidgetStyleContainerBase { 
	EditableTextStyle: EditableTextStyle;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditableTextWidgetStyle;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditableTextWidgetStyle;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableTextWidgetStyle;
	static C(Other: UObject): EditableTextWidgetStyle;
}

declare class ProgressBarStyle extends SlateWidgetStyle { 
	BackgroundImage: SlateBrush;
	FillImage: SlateBrush;
	MarqueeImage: SlateBrush;
}

declare class ProgressWidgetStyle extends SlateWidgetStyleContainerBase { 
	ProgressBarStyle: ProgressBarStyle;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ProgressWidgetStyle;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ProgressWidgetStyle;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProgressWidgetStyle;
	static C(Other: UObject): ProgressWidgetStyle;
}

declare class ScrollBarWidgetStyle extends SlateWidgetStyleContainerBase { 
	ScrollBarStyle: ScrollBarStyle;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ScrollBarWidgetStyle;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ScrollBarWidgetStyle;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBarWidgetStyle;
	static C(Other: UObject): ScrollBarWidgetStyle;
}

declare class ScrollBoxStyle extends SlateWidgetStyle { 
	TopShadowBrush: SlateBrush;
	BottomShadowBrush: SlateBrush;
	LeftShadowBrush: SlateBrush;
	RightShadowBrush: SlateBrush;
}

declare class ScrollBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	ScrollBoxStyle: ScrollBoxStyle;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ScrollBoxWidgetStyle;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ScrollBoxWidgetStyle;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBoxWidgetStyle;
	static C(Other: UObject): ScrollBoxWidgetStyle;
}

declare class SpinBoxStyle extends SlateWidgetStyle { 
	BackgroundBrush: SlateBrush;
	HoveredBackgroundBrush: SlateBrush;
	ActiveFillBrush: SlateBrush;
	InactiveFillBrush: SlateBrush;
	ArrowsImage: SlateBrush;
	ForegroundColor: SlateColor;
	TextPadding: Margin;
}

declare class SpinBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	SpinBoxStyle: SpinBoxStyle;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SpinBoxWidgetStyle;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SpinBoxWidgetStyle;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpinBoxWidgetStyle;
	static C(Other: UObject): SpinBoxWidgetStyle;
}

declare class TextBlockStyle extends SlateWidgetStyle { 
	Font: SlateFontInfo;
	ColorAndOpacity: SlateColor;
	ShadowOffset: Vector2D;
	ShadowColorAndOpacity: LinearColor;
	SelectedBackgroundColor: SlateColor;
	HighlightColor: LinearColor;
	HighlightShape: SlateBrush;
}

declare class TextBlockWidgetStyle extends SlateWidgetStyleContainerBase { 
	TextBlockStyle: TextBlockStyle;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextBlockWidgetStyle;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextBlockWidgetStyle;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBlockWidgetStyle;
	static C(Other: UObject): TextBlockWidgetStyle;
}

declare type EColorVisionDeficiency = string;
declare type ELogTimes = string;
declare class EditorStyleSettings extends UObject { 
	SelectionColor: LinearColor;
	PressedSelectionColor: LinearColor;
	InactiveSelectionColor: LinearColor;
	KeyboardFocusColor: LinearColor;
	ColorVisionDeficiencyPreviewType: EColorVisionDeficiency;
	bUseSmallToolBarIcons: boolean;
	bEnableWindowAnimations: boolean;
	bShowFriendlyNames: boolean;
	bExpandConfigurationMenus: boolean;
	bShowProjectMenus: boolean;
	bShowLaunchMenus: boolean;
	LogTimestampMode: ELogTimes;
	bOpenAssetEditorTabsInNewWindow: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorStyleSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorStyleSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorStyleSettings;
	static C(Other: UObject): EditorStyleSettings;
}

declare class MaterialQualityOverrides { 
	bEnableOverride: boolean;
	bForceFullyRough: boolean;
	bForceNonMetal: boolean;
	bForceDisableLMDirectionality: boolean;
}

declare class ShaderPlatformQualitySettings extends UObject { 
	QualityOverrides: MaterialQualityOverrides;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ShaderPlatformQualitySettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ShaderPlatformQualitySettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ShaderPlatformQualitySettings;
	static C(Other: UObject): ShaderPlatformQualitySettings;
}

declare class MaterialShaderQualitySettings extends UObject { 
	ForwardSettingMap: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialShaderQualitySettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialShaderQualitySettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialShaderQualitySettings;
	static C(Other: UObject): MaterialShaderQualitySettings;
}

declare class AutoCompleteCommand { 
	Command: string;
	Desc: string;
}

declare class ConsoleSettings extends UObject { 
	MaxScrollbackSize: number;
	ManualAutoCompleteList: AutoCompleteCommand[];
	AutoCompleteMapPaths: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ConsoleSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ConsoleSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConsoleSettings;
	static C(Other: UObject): ConsoleSettings;
}

declare type ETwoPlayerSplitScreenType = string;
declare type EThreePlayerSplitScreenType = string;
declare class GameMapsSettings extends UObject { 
	EditorStartupMap: string;
	LocalMapOptions: string;
	TransitionMap: string;
	bUseSplitscreen: boolean;
	TwoPlayerSplitscreenLayout: ETwoPlayerSplitScreenType;
	ThreePlayerSplitscreenLayout: EThreePlayerSplitScreenType;
	GameInstanceClass: StringClassReference;
	GameDefaultMap: string;
	ServerDefaultMap: string;
	GlobalDefaultGameMode: StringClassReference;
	GlobalDefaultServerGameMode: StringClassReference;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameMapsSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameMapsSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameMapsSettings;
	static C(Other: UObject): GameMapsSettings;
}

declare class GameNetworkManagerSettings extends UObject { 
	MinDynamicBandwidth: number;
	MaxDynamicBandwidth: number;
	TotalNetBandwidth: number;
	BadPingThreshold: number;
	bIsStandbyCheckingEnabled: boolean;
	StandbyRxCheatTime: number;
	StandbyTxCheatTime: number;
	PercentMissingForRxStandby: number;
	PercentMissingForTxStandby: number;
	PercentForBadPing: number;
	JoinInProgressStandbyWaitTime: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameNetworkManagerSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameNetworkManagerSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameNetworkManagerSettings;
	static C(Other: UObject): GameNetworkManagerSettings;
}

declare class GameSessionSettings extends UObject { 
	MaxSpectators: number;
	MaxPlayers: number;
	bRequiresPushToTalk: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameSessionSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameSessionSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameSessionSettings;
	static C(Other: UObject): GameSessionSettings;
}

declare class GeneralEngineSettings extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GeneralEngineSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GeneralEngineSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeneralEngineSettings;
	static C(Other: UObject): GeneralEngineSettings;
}

declare class GeneralProjectSettings extends UObject { 
	CompanyName: string;
	CompanyDistinguishedName: string;
	CopyrightNotice: string;
	Description: string;
	Homepage: string;
	LicensingTerms: string;
	PrivacyPolicy: string;
	ProjectID: Guid;
	ProjectName: string;
	ProjectVersion: string;
	SupportContact: string;
	ProjectDisplayedTitle: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GeneralProjectSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GeneralProjectSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeneralProjectSettings;
	static C(Other: UObject): GeneralProjectSettings;
}

declare class HudSettings extends UObject { 
	bShowHUD: boolean;
	DebugDisplay: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): HudSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): HudSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HudSettings;
	static C(Other: UObject): HudSettings;
}

declare class NamedInterface { 
	InterfaceName: string;
	InterfaceObject: UObject;
}

declare class NamedInterfaceDef { 
	InterfaceName: string;
	InterfaceClassName: string;
}

declare class NamedInterfaces extends UObject { 
	NamedInterfaces: NamedInterface[];
	NamedInterfaceDefs: NamedInterfaceDef[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NamedInterfaces;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NamedInterfaces;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NamedInterfaces;
	static C(Other: UObject): NamedInterfaces;
}

declare class TurnBasedMatchInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TurnBasedMatchInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TurnBasedMatchInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TurnBasedMatchInterface;
	static C(Other: UObject): TurnBasedMatchInterface;
	OnMatchReceivedTurn(Match: string,bDidBecomeActive: boolean): void;
	OnMatchEnded(Match: string): void;
}

declare class MovieSceneSection extends UObject { 
	StartTime: number;
	EndTime: number;
	RowIndex: number;
	bIsActive: boolean;
	bIsInfinite: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSection;
	static C(Other: UObject): MovieSceneSection;
}

declare class MovieScene3DConstraintSection extends MovieSceneSection { 
	ConstraintId: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieScene3DConstraintSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieScene3DConstraintSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DConstraintSection;
	static C(Other: UObject): MovieScene3DConstraintSection;
}

declare class MovieScene3DAttachSection extends MovieScene3DConstraintSection { 
	bConstrainTx: boolean;
	bConstrainTy: boolean;
	bConstrainTz: boolean;
	bConstrainRx: boolean;
	bConstrainRy: boolean;
	bConstrainRz: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieScene3DAttachSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieScene3DAttachSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DAttachSection;
	static C(Other: UObject): MovieScene3DAttachSection;
}

declare type MovieScene3DPathSection_Axis = string;
declare class MovieScene3DPathSection extends MovieScene3DConstraintSection { 
	TimingCurve: RichCurve;
	FrontAxisEnum: MovieScene3DPathSection_Axis;
	UpAxisEnum: MovieScene3DPathSection_Axis;
	bFollow: boolean;
	bReverse: boolean;
	bForceUpright: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieScene3DPathSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieScene3DPathSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DPathSection;
	static C(Other: UObject): MovieScene3DPathSection;
}

declare class MovieScene3DConstraintTrack extends MovieSceneTrack { 
	ConstraintSections: MovieSceneSection[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieScene3DConstraintTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieScene3DConstraintTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DConstraintTrack;
	static C(Other: UObject): MovieScene3DConstraintTrack;
}

declare class MovieScene3DAttachTrack extends MovieScene3DConstraintTrack { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieScene3DAttachTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieScene3DAttachTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DAttachTrack;
	static C(Other: UObject): MovieScene3DAttachTrack;
}

declare class MovieScene3DPathTrack extends MovieScene3DConstraintTrack { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieScene3DPathTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieScene3DPathTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DPathTrack;
	static C(Other: UObject): MovieScene3DPathTrack;
}

declare class MovieScene3DTransformSection extends MovieSceneSection { 
	Translation: RichCurve;
	Rotation: RichCurve;
	Scale: RichCurve;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieScene3DTransformSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieScene3DTransformSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DTransformSection;
	static C(Other: UObject): MovieScene3DTransformSection;
}

declare class MovieSceneAudioSection extends MovieSceneSection { 
	Sound: SoundBase;
	AudioStartTime: number;
	AudioDilationFactor: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneAudioSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneAudioSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneAudioSection;
	static C(Other: UObject): MovieSceneAudioSection;
}

declare class MovieSceneAudioTrack extends MovieSceneTrack { 
	AudioSections: MovieSceneSection[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneAudioTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneAudioTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneAudioTrack;
	static C(Other: UObject): MovieSceneAudioTrack;
}

declare class IntegralKey { 
	Time: number;
	Value: number;
}

declare class IntegralCurve extends IndexedCurve { 
	Keys: IntegralKey[];
	DefaultValue: number;
	bUseDefaultValueBeforeFirstKey: boolean;
}

declare class MovieSceneBoolSection extends MovieSceneSection { 
	BoolCurve: IntegralCurve;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneBoolSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneBoolSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneBoolSection;
	static C(Other: UObject): MovieSceneBoolSection;
}

declare class MovieSceneVisibilitySection extends MovieSceneBoolSection { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneVisibilitySection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneVisibilitySection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneVisibilitySection;
	static C(Other: UObject): MovieSceneVisibilitySection;
}

declare class MovieSceneByteSection extends MovieSceneSection { 
	ByteCurve: IntegralCurve;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneByteSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneByteSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneByteSection;
	static C(Other: UObject): MovieSceneByteSection;
}

declare class MovieSceneColorSection extends MovieSceneSection { 
	RedCurve: RichCurve;
	GreenCurve: RichCurve;
	BlueCurve: RichCurve;
	AlphaCurve: RichCurve;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneColorSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneColorSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneColorSection;
	static C(Other: UObject): MovieSceneColorSection;
}

declare class NameCurveKey { 
	Time: number;
	Value: string;
}

declare class NameCurve extends IndexedCurve { 
	Keys: NameCurveKey[];
}

declare class MovieSceneEventSection extends MovieSceneSection { 
	Events: NameCurve;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneEventSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneEventSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEventSection;
	static C(Other: UObject): MovieSceneEventSection;
}

declare class MovieSceneEventTrack extends MovieSceneTrack { 
	bFireEventsWhenForwards: boolean;
	bFireEventsWhenBackwards: boolean;
	Sections: MovieSceneSection[];
	TrackName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneEventTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneEventTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEventTrack;
	static C(Other: UObject): MovieSceneEventTrack;
}

declare class MovieSceneFloatSection extends MovieSceneSection { 
	FloatCurve: RichCurve;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneFloatSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneFloatSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneFloatSection;
	static C(Other: UObject): MovieSceneFloatSection;
}

declare class MovieSceneFadeSection extends MovieSceneFloatSection { 
	FadeColor: LinearColor;
	bFadeAudio: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneFadeSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneFadeSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneFadeSection;
	static C(Other: UObject): MovieSceneFadeSection;
}

declare class MovieSceneSlomoSection extends MovieSceneFloatSection { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneSlomoSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneSlomoSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSlomoSection;
	static C(Other: UObject): MovieSceneSlomoSection;
}

declare class ScalarParameterNameAndCurve { 
	ParameterName: string;
	Index: number;
	ParameterCurve: RichCurve;
}

declare class VectorParameterNameAndCurves { 
	ParameterName: string;
	Index: number;
	RedCurve: RichCurve;
	GreenCurve: RichCurve;
	BlueCurve: RichCurve;
	AlphaCurve: RichCurve;
}

declare class MovieSceneMaterialParameterSection extends MovieSceneSection { 
	ScalarParameterNamesAndCurves: ScalarParameterNameAndCurve[];
	VectorParameterNamesAndCurves: VectorParameterNameAndCurves[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneMaterialParameterSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneMaterialParameterSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMaterialParameterSection;
	static C(Other: UObject): MovieSceneMaterialParameterSection;
}

declare class MovieSceneMaterialTrack extends MovieSceneTrack { 
	Sections: MovieSceneSection[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneMaterialTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneMaterialTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMaterialTrack;
	static C(Other: UObject): MovieSceneMaterialTrack;
}

declare class MovieSceneComponentMaterialTrack extends MovieSceneMaterialTrack { 
	TrackName: string;
	MaterialIndex: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneComponentMaterialTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneComponentMaterialTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneComponentMaterialTrack;
	static C(Other: UObject): MovieSceneComponentMaterialTrack;
}

declare class MovieSceneParticleSection extends MovieSceneSection { 
	ParticleKeys: IntegralCurve;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneParticleSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneParticleSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneParticleSection;
	static C(Other: UObject): MovieSceneParticleSection;
}

declare class MovieSceneParticleTrack extends MovieSceneTrack { 
	ParticleSections: MovieSceneSection[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneParticleTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneParticleTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneParticleTrack;
	static C(Other: UObject): MovieSceneParticleTrack;
}

declare class MovieScenePropertyTrack extends MovieSceneTrack { 
	PropertyName: string;
	PropertyPath: string;
	Sections: MovieSceneSection[];
	bSectionsAreShowable: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieScenePropertyTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieScenePropertyTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScenePropertyTrack;
	static C(Other: UObject): MovieScenePropertyTrack;
}

declare class MovieScene3DTransformTrack extends MovieScenePropertyTrack { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieScene3DTransformTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieScene3DTransformTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DTransformTrack;
	static C(Other: UObject): MovieScene3DTransformTrack;
}

declare class MovieSceneBoolTrack extends MovieScenePropertyTrack { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneBoolTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneBoolTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneBoolTrack;
	static C(Other: UObject): MovieSceneBoolTrack;
}

declare class MovieSceneVisibilityTrack extends MovieSceneBoolTrack { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneVisibilityTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneVisibilityTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneVisibilityTrack;
	static C(Other: UObject): MovieSceneVisibilityTrack;
}

declare class MovieSceneByteTrack extends MovieScenePropertyTrack { 
	Enum: Enum;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneByteTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneByteTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneByteTrack;
	static C(Other: UObject): MovieSceneByteTrack;
}

declare class MovieSceneColorTrack extends MovieScenePropertyTrack { 
	bIsSlateColor: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneColorTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneColorTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneColorTrack;
	static C(Other: UObject): MovieSceneColorTrack;
}

declare class MovieSceneFloatTrack extends MovieScenePropertyTrack { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneFloatTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneFloatTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneFloatTrack;
	static C(Other: UObject): MovieSceneFloatTrack;
}

declare class MovieSceneFadeTrack extends MovieSceneFloatTrack { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneFadeTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneFadeTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneFadeTrack;
	static C(Other: UObject): MovieSceneFadeTrack;
}

declare class MovieSceneSlomoTrack extends MovieSceneFloatTrack { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneSlomoTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneSlomoTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSlomoTrack;
	static C(Other: UObject): MovieSceneSlomoTrack;
}

declare class MovieSceneVectorTrack extends MovieScenePropertyTrack { 
	NumChannelsUsed: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneVectorTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneVectorTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneVectorTrack;
	static C(Other: UObject): MovieSceneVectorTrack;
}

declare class MovieSceneSkeletalAnimationSection extends MovieSceneSection { 
	AnimSequence: AnimSequence;
	AnimationStartTime: number;
	AnimationDilationFactor: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneSkeletalAnimationSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneSkeletalAnimationSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSkeletalAnimationSection;
	static C(Other: UObject): MovieSceneSkeletalAnimationSection;
}

declare class MovieSceneSkeletalAnimationTrack extends MovieSceneTrack { 
	AnimationSections: MovieSceneSection[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneSkeletalAnimationTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneSkeletalAnimationTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSkeletalAnimationTrack;
	static C(Other: UObject): MovieSceneSkeletalAnimationTrack;
}

declare class MovieSceneVectorSection extends MovieSceneSection { 
	Curves: RichCurve;
	ChannelsUsed: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneVectorSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneVectorSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneVectorSection;
	static C(Other: UObject): MovieSceneVectorSection;
}

declare class SubMovieSceneSection extends MovieSceneSection { 
	Sequence: MovieSceneSequence;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SubMovieSceneSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SubMovieSceneSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubMovieSceneSection;
	static C(Other: UObject): SubMovieSceneSection;
}

declare class MovieSceneShotSection extends SubMovieSceneSection { 
	CameraGuid: Guid;
	DisplayName: string;
	ShotNumber: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneShotSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneShotSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneShotSection;
	static C(Other: UObject): MovieSceneShotSection;
}

declare class SubMovieSceneTrack extends MovieSceneTrack { 
	SubMovieSceneSections: MovieSceneSection[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SubMovieSceneTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SubMovieSceneTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubMovieSceneTrack;
	static C(Other: UObject): SubMovieSceneTrack;
}

declare class MovieSceneShotTrack extends SubMovieSceneTrack { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneShotTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneShotTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneShotTrack;
	static C(Other: UObject): MovieSceneShotTrack;
}

declare class BlueprintAsyncActionBase extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintAsyncActionBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintAsyncActionBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintAsyncActionBase;
	static C(Other: UObject): BlueprintAsyncActionBase;
	Activate(): void;
}

declare class AsyncTaskDownloadImage extends BlueprintAsyncActionBase { 
	OnSuccess: UnrealEngineMulticastDelegate<(Texture: Texture2D) => void>;
	OnFail: UnrealEngineMulticastDelegate<(Texture: Texture2D) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AsyncTaskDownloadImage;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AsyncTaskDownloadImage;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncTaskDownloadImage;
	static C(Other: UObject): AsyncTaskDownloadImage;
	static DownloadImage(URL: string): AsyncTaskDownloadImage;
}

declare class MovieScene2DTransformSection extends MovieSceneSection { 
	Translation: RichCurve;
	Rotation: RichCurve;
	Scale: RichCurve;
	Shear: RichCurve;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieScene2DTransformSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieScene2DTransformSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene2DTransformSection;
	static C(Other: UObject): MovieScene2DTransformSection;
}

declare class MovieScene2DTransformTrack extends MovieScenePropertyTrack { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieScene2DTransformTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieScene2DTransformTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene2DTransformTrack;
	static C(Other: UObject): MovieScene2DTransformTrack;
}

declare class MovieSceneMarginSection extends MovieSceneSection { 
	TopCurve: RichCurve;
	LeftCurve: RichCurve;
	RightCurve: RichCurve;
	BottomCurve: RichCurve;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneMarginSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneMarginSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMarginSection;
	static C(Other: UObject): MovieSceneMarginSection;
}

declare class MovieSceneMarginTrack extends MovieScenePropertyTrack { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneMarginTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneMarginTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMarginTrack;
	static C(Other: UObject): MovieSceneMarginTrack;
}

declare class NamedSlotInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NamedSlotInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NamedSlotInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NamedSlotInterface;
	static C(Other: UObject): NamedSlotInterface;
}

declare class BoolBinding extends PropertyBinding { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BoolBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BoolBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoolBinding;
	static C(Other: UObject): BoolBinding;
	GetValue(): boolean;
}

declare class BrushBinding extends PropertyBinding { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BrushBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BrushBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushBinding;
	static C(Other: UObject): BrushBinding;
	GetValue(): SlateBrush;
}

declare type ECheckBoxState = string;
declare class CheckedStateBinding extends PropertyBinding { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CheckedStateBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CheckedStateBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckedStateBinding;
	static C(Other: UObject): CheckedStateBinding;
	GetValue(): ECheckBoxState;
}

declare class ColorBinding extends PropertyBinding { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ColorBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ColorBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ColorBinding;
	static C(Other: UObject): ColorBinding;
	GetSlateValue(): SlateColor;
	GetLinearValue(): LinearColor;
}

declare class FloatBinding extends PropertyBinding { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FloatBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FloatBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatBinding;
	static C(Other: UObject): FloatBinding;
	GetValue(): number;
}

declare class Int32Binding extends PropertyBinding { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Int32Binding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Int32Binding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int32Binding;
	static C(Other: UObject): Int32Binding;
	GetValue(): number;
}

declare class MouseCursorBinding extends PropertyBinding { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MouseCursorBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MouseCursorBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MouseCursorBinding;
	static C(Other: UObject): MouseCursorBinding;
	GetValue(): EMouseCursor;
}

declare class TextBinding extends PropertyBinding { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBinding;
	static C(Other: UObject): TextBinding;
	GetTextValue(): string;
	GetStringValue(): string;
}

declare class VisibilityBinding extends PropertyBinding { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VisibilityBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VisibilityBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisibilityBinding;
	static C(Other: UObject): VisibilityBinding;
	GetValue(): ESlateVisibility;
}

declare class WidgetBinding extends PropertyBinding { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WidgetBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WidgetBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBinding;
	static C(Other: UObject): WidgetBinding;
	GetValue(): Widget;
}

declare class RichTextBlockDecorator extends UObject { 
	bReveal: boolean;
	RevealedIndex: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): RichTextBlockDecorator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): RichTextBlockDecorator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RichTextBlockDecorator;
	static C(Other: UObject): RichTextBlockDecorator;
}

declare class SlateBlueprintLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SlateBlueprintLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SlateBlueprintLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateBlueprintLibrary;
	static C(Other: UObject): SlateBlueprintLibrary;
	static LocalToViewport(WorldContextObject: UObject,Geometry: Geometry,LocalCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
	static LocalToAbsolute(Geometry: Geometry,LocalCoordinate: Vector2D): Vector2D;
	static IsUnderLocation(Geometry: Geometry,AbsoluteCoordinate: Vector2D): boolean;
	static GetLocalSize(Geometry: Geometry): Vector2D;
	static AbsoluteToViewport(WorldContextObject: UObject,AbsoluteDesktopCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
	static AbsoluteToLocal(Geometry: Geometry,AbsoluteCoordinate: Vector2D): Vector2D;
}

declare class BorderSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BorderSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BorderSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BorderSlot;
	static C(Other: UObject): BorderSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
}

declare class ButtonSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ButtonSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ButtonSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ButtonSlot;
	static C(Other: UObject): ButtonSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
}

declare class SafeZoneSlot extends PanelSlot { 
	bIsTitleSafe: boolean;
	HAlign: EHorizontalAlignment;
	VAlign: EVerticalAlignment;
	Padding: Margin;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SafeZoneSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SafeZoneSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SafeZoneSlot;
	static C(Other: UObject): SafeZoneSlot;
}

declare class ScaleBoxSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ScaleBoxSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ScaleBoxSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScaleBoxSlot;
	static C(Other: UObject): ScaleBoxSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
}

declare class ScrollBoxSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ScrollBoxSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ScrollBoxSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBoxSlot;
	static C(Other: UObject): ScrollBoxSlot;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
}

declare class SizeBoxSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SizeBoxSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SizeBoxSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SizeBoxSlot;
	static C(Other: UObject): SizeBoxSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
}

declare class WidgetSwitcherSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WidgetSwitcherSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WidgetSwitcherSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetSwitcherSlot;
	static C(Other: UObject): WidgetSwitcherSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
}

declare class WrapBoxSlot extends PanelSlot { 
	Padding: Margin;
	bFillEmptySpace: boolean;
	FillSpanWhenLessThan: number;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WrapBoxSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WrapBoxSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WrapBoxSlot;
	static C(Other: UObject): WrapBoxSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	SetFillSpanWhenLessThan(InFillSpanWhenLessThan: number): void;
	SetFillEmptySpace(InbFillEmptySpace: boolean): void;
}

declare class SlateBrushAsset extends UObject { 
	Brush: SlateBrush;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SlateBrushAsset;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SlateBrushAsset;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateBrushAsset;
	static C(Other: UObject): SlateBrushAsset;
	MakeBrushFromAsset(): SlateBrush;
}

declare class CircularThrobber extends Widget { 
	NumberOfPieces: number;
	Period: number;
	Radius: number;
	PieceImage: SlateBrushAsset;
	UImage: SlateBrush;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CircularThrobber;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CircularThrobber;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CircularThrobber;
	static C(Other: UObject): CircularThrobber;
	SetRadius(InRadius: number): void;
	SetPeriod(InPeriod: number): void;
	SetNumberOfPieces(InNumberOfPieces: number): void;
}

declare class ComboBox extends Widget { 
	Items: UObject[];
	OnGenerateWidgetEvent: UnrealEngineDelegate<(Item: UObject) => Widget>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ComboBox;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ComboBox;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBox;
	static C(Other: UObject): ComboBox;
}

declare type ESelectInfo = string;
declare class ComboBoxString extends Widget { 
	DefaultOptions: string[];
	SelectedOption: string;
	WidgetStyle: ComboBoxStyle;
	ContentPadding: Margin;
	MaxListHeight: number;
	HasDownArrow: boolean;
	OnGenerateWidgetEvent: UnrealEngineDelegate<(Item: string) => Widget>;
	OnSelectionChanged: UnrealEngineMulticastDelegate<(SelectedItem: string, SelectionType: ESelectInfo) => void>;
	OnOpening: UnrealEngineMulticastDelegate<() => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ComboBoxString;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ComboBoxString;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBoxString;
	static C(Other: UObject): ComboBoxString;
	SetSelectedOption(Option: string): void;
	RemoveOption(Option: string): boolean;
	RefreshOptions(): void;
	GetSelectedOption(): string;
	GetOptionCount(): number;
	GetOptionAtIndex(Index: number): string;
	FindOptionIndex(Option: string): number;
	ClearSelection(): void;
	ClearOptions(): void;
	AddOption(Option: string): void;
}

declare type ETextCommit = string;
declare class EditableText extends Widget { 
	Text: string;
	TextDelegate: UnrealEngineDelegate<() => string>;
	HintText: string;
	HintTextDelegate: UnrealEngineDelegate<() => string>;
	WidgetStyle: EditableTextStyle;
	Style: SlateWidgetStyleAsset;
	BackgroundImageSelected: SlateBrushAsset;
	BackgroundImageComposing: SlateBrushAsset;
	CaretImage: SlateBrushAsset;
	Font: SlateFontInfo;
	ColorAndOpacity: SlateColor;
	IsReadOnly: boolean;
	IsPassword: boolean;
	MinimumDesiredWidth: number;
	IsCaretMovedWhenGainFocus: boolean;
	SelectAllTextWhenFocused: boolean;
	RevertTextOnEscape: boolean;
	ClearKeyboardFocusOnCommit: boolean;
	SelectAllTextOnCommit: boolean;
	OnTextChanged: UnrealEngineMulticastDelegate<(Text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(Text: string, CommitMethod: ETextCommit) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditableText;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditableText;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableText;
	static C(Other: UObject): EditableText;
	SetText(InText: string): void;
	SetIsReadOnly(InbIsReadyOnly: boolean): void;
	SetIsPassword(InbIsPassword: boolean): void;
	SetHintText(InHintText: string): void;
	GetText(): string;
}

declare class EditableTextBox extends Widget { 
	Text: string;
	TextDelegate: UnrealEngineDelegate<() => string>;
	WidgetStyle: EditableTextBoxStyle;
	Style: SlateWidgetStyleAsset;
	HintText: string;
	HintTextDelegate: UnrealEngineDelegate<() => string>;
	Font: SlateFontInfo;
	ForegroundColor: LinearColor;
	BackgroundColor: LinearColor;
	ReadOnlyForegroundColor: LinearColor;
	IsReadOnly: boolean;
	IsPassword: boolean;
	MinimumDesiredWidth: number;
	Padding: Margin;
	IsCaretMovedWhenGainFocus: boolean;
	SelectAllTextWhenFocused: boolean;
	RevertTextOnEscape: boolean;
	ClearKeyboardFocusOnCommit: boolean;
	SelectAllTextOnCommit: boolean;
	OnTextChanged: UnrealEngineMulticastDelegate<(Text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(Text: string, CommitMethod: ETextCommit) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditableTextBox;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditableTextBox;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableTextBox;
	static C(Other: UObject): EditableTextBox;
	SetText(InText: string): void;
	SetError(InError: string): void;
	GetText(): string;
	ClearError(): void;
}

declare class ExpandableArea extends Widget { 
	bIsExpanded: boolean;
	MaxHeight: number;
	AreaPadding: Margin;
	OnExpansionChanged: UnrealEngineMulticastDelegate<(bIsExpanded: boolean) => void>;
	HeaderContent: Widget;
	BodyContent: Widget;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ExpandableArea;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ExpandableArea;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ExpandableArea;
	static C(Other: UObject): ExpandableArea;
	SetIsExpanded(IsExpanded: boolean): void;
	GetIsExpanded(): boolean;
}

declare class UImage extends Widget { 
	UImage: SlateBrushAsset;
	Brush: SlateBrush;
	BrushDelegate: UnrealEngineDelegate<() => SlateBrush>;
	ColorAndOpacity: LinearColor;
	ColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	OnMouseButtonDownEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UImage;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UImage;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UImage;
	static C(Other: UObject): UImage;
	SetOpacity(InOpacity: number): void;
	SetColorAndOpacity(InColorAndOpacity: LinearColor): void;
	SetBrushFromTexture(Texture: Texture2D,bMatchSize: boolean): void;
	SetBrushFromMaterial(Material: MaterialInterface): void;
	SetBrushFromAsset(Asset: SlateBrushAsset): void;
	SetBrush(InBrush: SlateBrush): void;
	GetDynamicMaterial(): MaterialInstanceDynamic;
}

declare type ETextJustify = string;
declare class MultiLineEditableText extends Widget { 
	Text: string;
	WidgetStyle: TextBlockStyle;
	Justification: ETextJustify;
	bAutoWrapText: boolean;
	WrapTextAt: number;
	Font: SlateFontInfo;
	OnTextChanged: UnrealEngineMulticastDelegate<(Text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(Text: string, CommitMethod: ETextCommit) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MultiLineEditableText;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MultiLineEditableText;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MultiLineEditableText;
	static C(Other: UObject): MultiLineEditableText;
	SetText(InText: string): void;
	GetText(): string;
}

declare class MultiLineEditableTextBox extends Widget { 
	Text: string;
	WidgetStyle: EditableTextBoxStyle;
	TextStyle: TextBlockStyle;
	Style: SlateWidgetStyleAsset;
	Justification: ETextJustify;
	bAutoWrapText: boolean;
	WrapTextAt: number;
	Font: SlateFontInfo;
	ForegroundColor: LinearColor;
	BackgroundColor: LinearColor;
	ReadOnlyForegroundColor: LinearColor;
	OnTextChanged: UnrealEngineMulticastDelegate<(Text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(Text: string, CommitMethod: ETextCommit) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MultiLineEditableTextBox;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MultiLineEditableTextBox;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MultiLineEditableTextBox;
	static C(Other: UObject): MultiLineEditableTextBox;
	SetText(InText: string): void;
	SetError(InError: string): void;
	GetText(): string;
}

declare class NativeWidgetHost extends Widget { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NativeWidgetHost;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NativeWidgetHost;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NativeWidgetHost;
	static C(Other: UObject): NativeWidgetHost;
}

declare class CanvasPanel extends PanelWidget { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CanvasPanel;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CanvasPanel;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CanvasPanel;
	static C(Other: UObject): CanvasPanel;
	AddChildToCanvas(Content: Widget): CanvasPanelSlot;
}

declare class ContentWidget extends PanelWidget { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ContentWidget;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ContentWidget;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentWidget;
	static C(Other: UObject): ContentWidget;
	GetContentSlot(): PanelSlot;
}

declare class Border extends ContentWidget { 
	ContentColorAndOpacity: LinearColor;
	ContentColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	Background: SlateBrush;
	BackgroundDelegate: UnrealEngineDelegate<() => SlateBrush>;
	BrushColor: LinearColor;
	BrushColorDelegate: UnrealEngineDelegate<() => LinearColor>;
	bShowEffectWhenDisabled: boolean;
	OnMouseButtonDownEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	OnMouseButtonUpEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	OnMouseMoveEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	OnMouseDoubleClickEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	Brush: SlateBrushAsset;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Border;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Border;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Border;
	static C(Other: UObject): Border;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	SetContentColorAndOpacity(InContentColorAndOpacity: LinearColor): void;
	SetBrushFromTexture(Texture: Texture2D): void;
	SetBrushFromMaterial(Material: MaterialInterface): void;
	SetBrushFromAsset(Asset: SlateBrushAsset): void;
	SetBrushColor(InBrushColor: LinearColor): void;
	SetBrush(InBrush: SlateBrush): void;
	GetDynamicMaterial(): MaterialInstanceDynamic;
}

declare type EButtonClickMethod = string;
declare type EButtonTouchMethod = string;
declare class Button extends ContentWidget { 
	Style: SlateWidgetStyleAsset;
	WidgetStyle: ButtonStyle;
	ColorAndOpacity: LinearColor;
	BackgroundColor: LinearColor;
	ClickMethod: EButtonClickMethod;
	TouchMethod: EButtonTouchMethod;
	IsFocusable: boolean;
	OnClicked: UnrealEngineMulticastDelegate<() => void>;
	OnPressed: UnrealEngineMulticastDelegate<() => void>;
	OnReleased: UnrealEngineMulticastDelegate<() => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Button;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Button;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Button;
	static C(Other: UObject): Button;
	SetColorAndOpacity(InColorAndOpacity: LinearColor): void;
	SetBackgroundColor(InBackgroundColor: LinearColor): void;
	IsPressed(): boolean;
}

declare class CheckBox extends ContentWidget { 
	CheckedState: ECheckBoxState;
	CheckedStateDelegate: UnrealEngineDelegate<() => ECheckBoxState>;
	WidgetStyle: CheckBoxStyle;
	Style: SlateWidgetStyleAsset;
	UncheckedImage: SlateBrushAsset;
	UncheckedHoveredImage: SlateBrushAsset;
	UncheckedPressedImage: SlateBrushAsset;
	CheckedImage: SlateBrushAsset;
	CheckedHoveredImage: SlateBrushAsset;
	CheckedPressedImage: SlateBrushAsset;
	UndeterminedImage: SlateBrushAsset;
	UndeterminedHoveredImage: SlateBrushAsset;
	UndeterminedPressedImage: SlateBrushAsset;
	HorizontalAlignment: EHorizontalAlignment;
	Padding: Margin;
	BorderBackgroundColor: SlateColor;
	OnCheckStateChanged: UnrealEngineMulticastDelegate<(bIsChecked: boolean) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CheckBox;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CheckBox;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckBox;
	static C(Other: UObject): CheckBox;
	SetIsChecked(InIsChecked: boolean): void;
	SetCheckedState(InCheckedState: ECheckBoxState): void;
	IsPressed(): boolean;
	IsChecked(): boolean;
	GetCheckedState(): ECheckBoxState;
}

declare class InvalidationBox extends ContentWidget { 
	CacheRelativeTransforms: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InvalidationBox;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InvalidationBox;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InvalidationBox;
	static C(Other: UObject): InvalidationBox;
	InvalidateCache(): void;
}

declare type EMenuPlacement = string;
declare class MenuAnchor extends ContentWidget { 
	MenuClass: UnrealEngineClass;
	OnGetMenuContentEvent: UnrealEngineDelegate<() => Widget>;
	Placement: EMenuPlacement;
	OnMenuOpenChanged: UnrealEngineMulticastDelegate<(bIsOpen: boolean) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MenuAnchor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MenuAnchor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MenuAnchor;
	static C(Other: UObject): MenuAnchor;
	ToggleOpen(bFocusOnOpen: boolean): void;
	ShouldOpenDueToClick(): boolean;
	Open(bFocusMenu: boolean): void;
	IsOpen(): boolean;
	HasOpenSubMenus(): boolean;
	GetMenuPosition(): Vector2D;
	Close(): void;
}

declare class NamedSlot extends ContentWidget { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NamedSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NamedSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NamedSlot;
	static C(Other: UObject): NamedSlot;
}

declare class SafeZone extends ContentWidget { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SafeZone;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SafeZone;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SafeZone;
	static C(Other: UObject): SafeZone;
}

declare type EStretchDirection = string;
declare type EStretch = string;
declare class ScaleBox extends ContentWidget { 
	StretchDirection: EStretchDirection;
	Stretch: EStretch;
	UserSpecifiedScale: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ScaleBox;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ScaleBox;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScaleBox;
	static C(Other: UObject): ScaleBox;
}

declare class SizeBox extends ContentWidget { 
	bOverride_WidthOverride: boolean;
	bOverride_HeightOverride: boolean;
	bOverride_MinDesiredWidth: boolean;
	bOverride_MinDesiredHeight: boolean;
	bOverride_MaxDesiredWidth: boolean;
	bOverride_MaxDesiredHeight: boolean;
	WidthOverride: number;
	HeightOverride: number;
	MinDesiredWidth: number;
	MinDesiredHeight: number;
	MaxDesiredWidth: number;
	MaxDesiredHeight: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SizeBox;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SizeBox;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SizeBox;
	static C(Other: UObject): SizeBox;
	SetWidthOverride(InWidthOverride: number): void;
	SetMinDesiredWidth(InMinDesiredWidth: number): void;
	SetMinDesiredHeight(InMinDesiredHeight: number): void;
	SetMaxDesiredWidth(InMaxDesiredWidth: number): void;
	SetMaxDesiredHeight(InMaxDesiredHeight: number): void;
	SetHeightOverride(InHeightOverride: number): void;
	ClearWidthOverride(): void;
	ClearMinDesiredWidth(): void;
	ClearMinDesiredHeight(): void;
	ClearMaxDesiredWidth(): void;
	ClearMaxDesiredHeight(): void;
	ClearHeightOverride(): void;
}

declare class Viewport extends ContentWidget { 
	BackgroundColor: LinearColor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Viewport;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Viewport;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Viewport;
	static C(Other: UObject): Viewport;
	Spawn(ActorClass: UnrealEngineClass): Actor;
	SetViewRotation(Rotation: Rotator): void;
	SetViewLocation(Location: Vector): void;
	GetViewRotation(): Rotator;
	GetViewportWorld(): World;
	GetViewLocation(): Vector;
}

declare class GridPanel extends PanelWidget { 
	ColumnFill: number[];
	RowFill: number[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GridPanel;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GridPanel;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GridPanel;
	static C(Other: UObject): GridPanel;
	AddChildToGrid(Content: Widget): GridSlot;
}

declare class HorizontalBox extends PanelWidget { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): HorizontalBox;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): HorizontalBox;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HorizontalBox;
	static C(Other: UObject): HorizontalBox;
	AddChildToHorizontalBox(Content: Widget): HorizontalBoxSlot;
}

declare class Overlay extends PanelWidget { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Overlay;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Overlay;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Overlay;
	static C(Other: UObject): Overlay;
	AddChildToOverlay(Content: Widget): OverlaySlot;
}

declare type EOrientation = string;
declare type EConsumeMouseWheel = string;
declare class ScrollBox extends PanelWidget { 
	WidgetStyle: ScrollBoxStyle;
	WidgetBarStyle: ScrollBarStyle;
	Style: SlateWidgetStyleAsset;
	BarStyle: SlateWidgetStyleAsset;
	Orientation: EOrientation;
	ScrollBarVisibility: ESlateVisibility;
	ConsumeMouseWheel: EConsumeMouseWheel;
	ScrollbarThickness: Vector2D;
	AlwaysShowScrollbar: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ScrollBox;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ScrollBox;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBox;
	static C(Other: UObject): ScrollBox;
	SetScrollOffset(NewScrollOffset: number): void;
	ScrollWidgetIntoView(WidgetToFind: Widget,AnimateScroll: boolean): void;
	ScrollToStart(): void;
	ScrollToEnd(): void;
	GetScrollOffset(): number;
}

declare class UniformGridPanel extends PanelWidget { 
	SlotPadding: Margin;
	MinDesiredSlotWidth: number;
	MinDesiredSlotHeight: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UniformGridPanel;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UniformGridPanel;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformGridPanel;
	static C(Other: UObject): UniformGridPanel;
	SetSlotPadding(InSlotPadding: Margin): void;
	SetMinDesiredSlotWidth(InMinDesiredSlotWidth: number): void;
	SetMinDesiredSlotHeight(InMinDesiredSlotHeight: number): void;
	AddChildToUniformGrid(Content: Widget): UniformGridSlot;
}

declare class VerticalBox extends PanelWidget { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VerticalBox;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VerticalBox;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VerticalBox;
	static C(Other: UObject): VerticalBox;
	AddChildToVerticalBox(Content: Widget): VerticalBoxSlot;
}

declare class WidgetSwitcher extends PanelWidget { 
	ActiveWidgetIndex: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WidgetSwitcher;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WidgetSwitcher;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetSwitcher;
	static C(Other: UObject): WidgetSwitcher;
	SetActiveWidgetIndex(Index: number): void;
	SetActiveWidget(Widget: Widget): void;
	GetWidgetAtIndex(Index: number): Widget;
	GetNumWidgets(): number;
	GetActiveWidgetIndex(): number;
}

declare class WrapBox extends PanelWidget { 
	InnerSlotPadding: Vector2D;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WrapBox;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WrapBox;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WrapBox;
	static C(Other: UObject): WrapBox;
	SetInnerSlotPadding(InPadding: Vector2D): void;
	AddChildWrapBox(Content: Widget): WrapBoxSlot;
}

declare type EProgressBarFillType = string;
declare class ProgressBar extends Widget { 
	WidgetStyle: ProgressBarStyle;
	Style: SlateWidgetStyleAsset;
	BackgroundImage: SlateBrushAsset;
	FillImage: SlateBrushAsset;
	MarqueeImage: SlateBrushAsset;
	Percent: number;
	BarFillType: EProgressBarFillType;
	bIsMarquee: boolean;
	PercentDelegate: UnrealEngineDelegate<() => number>;
	FillColorAndOpacity: LinearColor;
	FillColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ProgressBar;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ProgressBar;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProgressBar;
	static C(Other: UObject): ProgressBar;
	SetPercent(InPercent: number): void;
	SetIsMarquee(InbIsMarquee: boolean): void;
	SetFillColorAndOpacity(InColor: LinearColor): void;
}

declare class RichTextBlock extends Widget { 
	Text: string;
	TextDelegate: UnrealEngineDelegate<() => string>;
	Font: SlateFontInfo;
	Color: LinearColor;
	Justification: ETextJustify;
	AutoWrapText: boolean;
	WrapTextAt: number;
	Margin: Margin;
	LineHeightPercentage: number;
	Decorators: RichTextBlockDecorator[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): RichTextBlock;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): RichTextBlock;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RichTextBlock;
	static C(Other: UObject): RichTextBlock;
}

declare class ScrollBar extends Widget { 
	WidgetStyle: ScrollBarStyle;
	Style: SlateWidgetStyleAsset;
	bAlwaysShowScrollbar: boolean;
	Orientation: EOrientation;
	Thickness: Vector2D;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ScrollBar;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ScrollBar;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBar;
	static C(Other: UObject): ScrollBar;
	SetState(InOffsetFraction: number,InThumbSizeFraction: number): void;
}

declare class SliderStyle extends SlateWidgetStyle { 
	NormalBarImage: SlateBrush;
	DisabledBarImage: SlateBrush;
	NormalThumbImage: SlateBrush;
	DisabledThumbImage: SlateBrush;
}

declare class Slider extends Widget { 
	Value: number;
	ValueDelegate: UnrealEngineDelegate<() => number>;
	WidgetStyle: SliderStyle;
	Orientation: EOrientation;
	SliderBarColor: LinearColor;
	SliderHandleColor: LinearColor;
	IndentHandle: boolean;
	Locked: boolean;
	OnMouseCaptureBegin: UnrealEngineMulticastDelegate<() => void>;
	OnMouseCaptureEnd: UnrealEngineMulticastDelegate<() => void>;
	OnValueChanged: UnrealEngineMulticastDelegate<(Value: number) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Slider;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Slider;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Slider;
	static C(Other: UObject): Slider;
	SetValue(InValue: number): void;
	SetLocked(InValue: boolean): void;
	SetIndentHandle(InValue: boolean): void;
	GetValue(): number;
}

declare class Spacer extends Widget { 
	Size: Vector2D;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Spacer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Spacer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Spacer;
	static C(Other: UObject): Spacer;
	SetSize(InSize: Vector2D): void;
}

declare class SpinBox extends Widget { 
	Value: number;
	ValueDelegate: UnrealEngineDelegate<() => number>;
	WidgetStyle: SpinBoxStyle;
	Style: SlateWidgetStyleAsset;
	Delta: number;
	SliderExponent: number;
	Font: SlateFontInfo;
	MinDesiredWidth: number;
	ClearKeyboardFocusOnCommit: boolean;
	SelectAllTextOnCommit: boolean;
	ForegroundColor: SlateColor;
	OnValueChanged: UnrealEngineMulticastDelegate<(InValue: number) => void>;
	OnValueCommitted: UnrealEngineMulticastDelegate<(InValue: number, CommitMethod: ETextCommit) => void>;
	OnBeginSliderMovement: UnrealEngineMulticastDelegate<() => void>;
	OnEndSliderMovement: UnrealEngineMulticastDelegate<(InValue: number) => void>;
	bOverride_MinValue: boolean;
	bOverride_MaxValue: boolean;
	bOverride_MinSliderValue: boolean;
	bOverride_MaxSliderValue: boolean;
	MinValue: number;
	MaxValue: number;
	MinSliderValue: number;
	MaxSliderValue: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SpinBox;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SpinBox;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpinBox;
	static C(Other: UObject): SpinBox;
	SetValue(NewValue: number): void;
	SetMinValue(NewValue: number): void;
	SetMinSliderValue(NewValue: number): void;
	SetMaxValue(NewValue: number): void;
	SetMaxSliderValue(NewValue: number): void;
	SetForegroundColor(InForegroundColor: SlateColor): void;
	GetValue(): number;
	GetMinValue(): number;
	GetMinSliderValue(): number;
	GetMaxValue(): number;
	GetMaxSliderValue(): number;
	ClearMinValue(): void;
	ClearMinSliderValue(): void;
	ClearMaxValue(): void;
	ClearMaxSliderValue(): void;
}

declare class TableViewBase extends Widget { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TableViewBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TableViewBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TableViewBase;
	static C(Other: UObject): TableViewBase;
}

declare type ESelectionMode = string;
declare class ListView extends TableViewBase { 
	ItemHeight: number;
	Items: UObject[];
	SelectionMode: ESelectionMode;
	OnGenerateRowEvent: UnrealEngineDelegate<(Item: UObject) => Widget>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ListView;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ListView;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ListView;
	static C(Other: UObject): ListView;
}

declare class TileView extends TableViewBase { 
	ItemWidth: number;
	ItemHeight: number;
	Items: UObject[];
	SelectionMode: ESelectionMode;
	OnGenerateTileEvent: UnrealEngineDelegate<(Item: UObject) => Widget>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TileView;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TileView;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TileView;
	static C(Other: UObject): TileView;
	SetItemWidth(Width: number): void;
	SetItemHeight(Height: number): void;
	RequestListRefresh(): void;
}

declare class TextBlock extends Widget { 
	Style: SlateWidgetStyleAsset;
	Text: string;
	TextDelegate: UnrealEngineDelegate<() => string>;
	ColorAndOpacity: SlateColor;
	ColorAndOpacityDelegate: UnrealEngineDelegate<() => SlateColor>;
	Font: SlateFontInfo;
	ShadowOffset: Vector2D;
	ShadowColorAndOpacity: LinearColor;
	ShadowColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	Justification: ETextJustify;
	AutoWrapText: boolean;
	WrapTextAt: number;
	MinDesiredWidth: number;
	Margin: Margin;
	LineHeightPercentage: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextBlock;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextBlock;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBlock;
	static C(Other: UObject): TextBlock;
	SetText(InText: string): void;
	SetShadowOffset(InShadowOffset: Vector2D): void;
	SetShadowColorAndOpacity(InShadowColorAndOpacity: LinearColor): void;
	SetOpacity(InOpacity: number): void;
	SetJustification(InJustification: ETextJustify): void;
	SetFont(InFontInfo: SlateFontInfo): void;
	SetColorAndOpacity(InColorAndOpacity: SlateColor): void;
	GetText(): string;
}

declare class Throbber extends Widget { 
	NumberOfPieces: number;
	bAnimateHorizontally: boolean;
	bAnimateVertically: boolean;
	bAnimateOpacity: boolean;
	PieceImage: SlateBrushAsset;
	UImage: SlateBrush;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Throbber;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Throbber;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Throbber;
	static C(Other: UObject): Throbber;
	SetNumberOfPieces(InNumberOfPieces: number): void;
	SetAnimateVertically(bInAnimateVertically: boolean): void;
	SetAnimateOpacity(bInAnimateOpacity: boolean): void;
	SetAnimateHorizontally(bInAnimateHorizontally: boolean): void;
}

declare class EventGraphFastCallPair { 
	FunctionToPatch: UFunction;
	EventGraphCallOffset: number;
}

declare class BlueprintGeneratedClass extends Class { 
	NumReplicatedProperties: number;
	DynamicBindingObjects: DynamicBlueprintBinding[];
	ComponentTemplates: ActorComponent[];
	Timelines: TimelineTemplate[];
	SimpleConstructionScript: SimpleConstructionScript;
	InheritableComponentHandler: InheritableComponentHandler;
	UberGraphFramePointerProperty: StructProperty;
	UberGraphFunction: UFunction;
	FastCallPairs: EventGraphFastCallPair[];
	OverridenArchetypeForCDO: UObject;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintGeneratedClass;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintGeneratedClass;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintGeneratedClass;
	static C(Other: UObject): BlueprintGeneratedClass;
}

declare type EBindingKind = string;
declare class DelegateRuntimeBinding { 
	ObjectName: string;
	PropertyName: string;
	FunctionName: string;
	SourcePath: DynamicPropertyPath;
	Kind: EBindingKind;
}

declare class WidgetBlueprintGeneratedClass extends BlueprintGeneratedClass { 
	WidgetTree: WidgetTree;
	DesignerWidgetTree: WidgetTree;
	Bindings: DelegateRuntimeBinding[];
	Animations: WidgetAnimation[];
	NamedSlots: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WidgetBlueprintGeneratedClass;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WidgetBlueprintGeneratedClass;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprintGeneratedClass;
	static C(Other: UObject): WidgetBlueprintGeneratedClass;
}

declare class NavigationEvent extends InputEvent { 
}

declare class WidgetBlueprintLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WidgetBlueprintLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WidgetBlueprintLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprintLibrary;
	static C(Other: UObject): WidgetBlueprintLibrary;
	static UnlockMouse(Reply?: EventReply): {Reply: EventReply, $: EventReply};
	static Unhandled(): EventReply;
	static SetUserFocus(Reply?: EventReply,FocusWidget?: Widget,bInAllUsers?: boolean): {Reply: EventReply, $: EventReply};
	static SetMousePosition(Reply?: EventReply,NewMousePosition?: Vector2D): {Reply: EventReply, $: EventReply};
	static SetInputMode_UIOnly(Target: PlayerController,InWidgetToFocus: Widget,bLockMouseToViewport: boolean): void;
	static SetInputMode_GameOnly(Target: PlayerController): void;
	static SetInputMode_GameAndUI(Target: PlayerController,InWidgetToFocus: Widget,bLockMouseToViewport: boolean,bHideCursorDuringCapture: boolean): void;
	static SetFocusToGameViewport(): void;
	static SetBrushResourceToTexture(Brush?: SlateBrush,Texture?: Texture2D): {Brush: SlateBrush};
	static SetBrushResourceToMaterial(Brush?: SlateBrush,Material?: MaterialInterface): {Brush: SlateBrush};
	static ReleaseMouseCapture(Reply?: EventReply): {Reply: EventReply, $: EventReply};
	static ReleaseJoystickCapture(Reply?: EventReply,bInAllJoysticks?: boolean): {Reply: EventReply, $: EventReply};
	static NoResourceBrush(): SlateBrush;
	static MakeBrushFromTexture(Texture: Texture2D,Width: number,Height: number): SlateBrush;
	static MakeBrushFromMaterial(Material: MaterialInterface,Width: number,Height: number): SlateBrush;
	static MakeBrushFromAsset(BrushAsset: SlateBrushAsset): SlateBrush;
	static LockMouse(Reply?: EventReply,CapturingWidget?: Widget): {Reply: EventReply, $: EventReply};
	static IsDragDropping(): boolean;
	static Handled(): EventReply;
	static GetKeyEventFromAnalogInputEvent(Event: AnalogInputEvent): KeyEvent;
	static GetInputEventFromPointerEvent(Event: UPointerEvent): InputEvent;
	static GetInputEventFromNavigationEvent(Event: NavigationEvent): InputEvent;
	static GetInputEventFromKeyEvent(Event: KeyEvent): InputEvent;
	static GetInputEventFromControllerEvent(Event: ControllerEvent): InputEvent;
	static GetInputEventFromCharacterEvent(Event: CharacterEvent): InputEvent;
	static GetDynamicMaterial(Brush?: SlateBrush): {Brush: SlateBrush, $: MaterialInstanceDynamic};
	static GetDragDroppingContent(): DragDropOperation;
	static GetBrushResourceAsTexture2D(Brush?: SlateBrush): {Brush: SlateBrush, $: Texture2D};
	static GetBrushResourceAsMaterial(Brush?: SlateBrush): {Brush: SlateBrush, $: MaterialInterface};
	static GetBrushResource(Brush?: SlateBrush): {Brush: SlateBrush, $: UObject};
	static GetAllWidgetsWithInterface(WorldContextObject: UObject,Interface: UnrealEngineClass,FoundWidgets?: UserWidget[],TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	static GetAllWidgetsOfClass(WorldContextObject: UObject,FoundWidgets?: UserWidget[],WidgetClass?: UnrealEngineClass,TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	static EndDragDrop(Reply?: EventReply): {Reply: EventReply, $: EventReply};
	static DrawText(Context?: PaintContext,Text?: string,Position?: Vector2D,Font?: Font,FontSize?: number,FontTypeFace?: string,Tint?: LinearColor): {Context: PaintContext};
	static DrawString(Context?: PaintContext,InString?: string,Position?: Vector2D,Tint?: LinearColor): {Context: PaintContext};
	static DrawLines(Context?: PaintContext,Points?: Vector2D[],Tint?: LinearColor,bAntiAlias?: boolean): {Context: PaintContext};
	static DrawLine(Context?: PaintContext,PositionA?: Vector2D,PositionB?: Vector2D,Tint?: LinearColor,bAntiAlias?: boolean): {Context: PaintContext};
	static DrawBox(Context?: PaintContext,Position?: Vector2D,Size?: Vector2D,Brush?: SlateBrushAsset,Tint?: LinearColor): {Context: PaintContext};
	static DismissAllMenus(): void;
	static DetectDragIfPressed(UPointerEvent: UPointerEvent,WidgetDetectingDrag: Widget,DragKey: Key): EventReply;
	static DetectDrag(Reply?: EventReply,WidgetDetectingDrag?: Widget,DragKey?: Key): {Reply: EventReply, $: EventReply};
	static CreateDragDropOperation(OperationClass: UnrealEngineClass): DragDropOperation;
	static CreateWidget(WorldContextObject: UObject,WidgetType: UnrealEngineClass,OwningPlayer: PlayerController): UserWidget;
	static ClearUserFocus(Reply?: EventReply,bInAllUsers?: boolean): {Reply: EventReply, $: EventReply};
	static CaptureMouse(Reply?: EventReply,CapturingWidget?: Widget): {Reply: EventReply, $: EventReply};
	static CaptureJoystick(Reply?: EventReply,CapturingWidget?: Widget,bInAllJoysticks?: boolean): {Reply: EventReply, $: EventReply};
	static CancelDragDrop(): void;
}

declare type EWidgetSpace = string;
declare type EWidgetBlendMode = string;
declare class TextureRenderTarget extends Texture { 
	TargetGamma: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextureRenderTarget;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextureRenderTarget;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureRenderTarget;
	static C(Other: UObject): TextureRenderTarget;
}

declare type EPixelFormat = string;
declare class TextureRenderTarget2D extends TextureRenderTarget { 
	SizeX: number;
	SizeY: number;
	ClearColor: LinearColor;
	AddressX: TextureAddress;
	AddressY: TextureAddress;
	bForceLinearGamma: boolean;
	bHDR: boolean;
	bAutoGenerateMips: boolean;
	OverrideFormat: EPixelFormat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextureRenderTarget2D;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextureRenderTarget2D;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureRenderTarget2D;
	static C(Other: UObject): TextureRenderTarget2D;
}

declare class WidgetComponent extends PrimitiveComponent { 
	Space: EWidgetSpace;
	WidgetClass: UnrealEngineClass;
	DrawSize: IntPoint;
	Pivot: Vector2D;
	MaxInteractionDistance: number;
	OwnerPlayer: LocalPlayer;
	BackgroundColor: LinearColor;
	BlendMode: EWidgetBlendMode;
	bIsOpaque: boolean;
	bIsTwoSided: boolean;
	ParabolaDistortion: number;
	TickWhenOffscreen: boolean;
	Widget: UserWidget;
	BodySetup: BodySetup;
	TranslucentMaterial: MaterialInterface;
	TranslucentMaterial_OneSided: MaterialInterface;
	OpaqueMaterial: MaterialInterface;
	OpaqueMaterial_OneSided: MaterialInterface;
	MaskedMaterial: MaterialInterface;
	MaskedMaterial_OneSided: MaterialInterface;
	RenderTarget: TextureRenderTarget2D;
	MaterialInstance: MaterialInstanceDynamic;
	bUseLegacyRotation: boolean;
	bAddedToScreen: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WidgetComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WidgetComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetComponent;
	static C(Other: UObject): WidgetComponent;
	SetWidget(Widget: UserWidget): void;
	SetOwnerPlayer(LocalPlayer: LocalPlayer): void;
	SetMaxInteractionDistance(Distance: number): void;
	SetDrawSize(Size: Vector2D): void;
	GetUserWidgetObject(): UserWidget;
	GetOwnerPlayer(): LocalPlayer;
	GetMaxInteractionDistance(): number;
	GetDrawSize(): Vector2D;
}

declare class WidgetLayoutLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WidgetLayoutLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WidgetLayoutLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetLayoutLibrary;
	static C(Other: UObject): WidgetLayoutLibrary;
	static SlotAsVerticalBoxSlot(Widget: Widget): VerticalBoxSlot;
	static SlotAsUniformGridSlot(Widget: Widget): UniformGridSlot;
	static SlotAsOverlaySlot(Widget: Widget): OverlaySlot;
	static SlotAsHorizontalBoxSlot(Widget: Widget): HorizontalBoxSlot;
	static SlotAsGridSlot(Widget: Widget): GridSlot;
	static SlotAsCanvasSlot(Widget: Widget): CanvasPanelSlot;
	static RemoveAllWidgets(WorldContextObject: UObject): void;
	static ProjectWorldLocationToWidgetPosition(PlayerController: PlayerController,WorldLocation: Vector,ScreenPosition?: Vector2D): {ScreenPosition: Vector2D, $: boolean};
	static GetViewportSize(WorldContextObject: UObject): Vector2D;
	static GetViewportScale(WorldContextObject: UObject): number;
	static GetMousePositionScaledByDPI(Player: PlayerController,LocationX?: number,LocationY?: number): {LocationX: number, LocationY: number, $: boolean};
}

declare class NiagaraActor extends Actor { 
	NiagaraComponent: NiagaraComponent;
	SpriteComponent: BillboardComponent;
	ArrowComponent: ArrowComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraActor;
	static C(Other: UObject): NiagaraActor;
}

declare class NiagaraFunctionLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraFunctionLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraFunctionLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraFunctionLibrary;
	static C(Other: UObject): NiagaraFunctionLibrary;
	static SpawnEffectAttached(EffectTemplate: NiagaraEffect,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bAutoDestroy: boolean): NiagaraComponent;
	static SpawnEffectAtLocation(WorldContextObject: UObject,EffectTemplate: NiagaraEffect,Location: Vector,Rotation: Rotator,bAutoDestroy: boolean): NiagaraComponent;
	static SetUpdateScriptConstant(Component: NiagaraComponent,EmitterName: string,ConstantName: string,Value: Vector): void;
}

declare class NiagaraSequence extends MovieSceneSequence { 
	MovieScene: MovieScene;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraSequence;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraSequence;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraSequence;
	static C(Other: UObject): NiagaraSequence;
}

declare type EHardwareClass = string;
declare type EGraphicsPreset = string;
declare class HardwareTargetingSettings extends UObject { 
	TargetedHardwareClass: EHardwareClass;
	AppliedTargetedHardwareClass: EHardwareClass;
	DefaultGraphicsPerformance: EGraphicsPreset;
	AppliedDefaultGraphicsPerformance: EGraphicsPreset;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): HardwareTargetingSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): HardwareTargetingSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HardwareTargetingSettings;
	static C(Other: UObject): HardwareTargetingSettings;
}

declare class LocalizedTemplateString { 
	Language: string;
	Text: string;
}

declare class TemplateFolderRename { 
	From: string;
	To: string;
}

declare class TemplateReplacement { 
	Extensions: string[];
	From: string;
	To: string;
	bCaseSensitive: boolean;
}

declare type EFeaturePackDetailLevel = string;
declare class FeaturePackLevelSet { 
	DetailLevels: EFeaturePackDetailLevel[];
	MountName: string;
}

declare class TemplateProjectDefs extends UObject { 
	LocalizedDisplayNames: LocalizedTemplateString[];
	LocalizedDescriptions: LocalizedTemplateString[];
	FoldersToIgnore: string[];
	FilesToIgnore: string[];
	FolderRenames: TemplateFolderRename[];
	FilenameReplacements: TemplateReplacement[];
	ReplacementsInFiles: TemplateReplacement[];
	SortKey: string;
	Category: string;
	ClassTypes: string;
	AssetTypes: string;
	bAllowProjectCreation: boolean;
	PacksToInclude: string[];
	EditDetailLevelPreference: EFeaturePackDetailLevel;
	SharedContentPacks: FeaturePackLevelSet[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TemplateProjectDefs;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TemplateProjectDefs;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TemplateProjectDefs;
	static C(Other: UObject): TemplateProjectDefs;
}

declare class DefaultTemplateProjectDefs extends TemplateProjectDefs { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DefaultTemplateProjectDefs;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DefaultTemplateProjectDefs;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DefaultTemplateProjectDefs;
	static C(Other: UObject): DefaultTemplateProjectDefs;
}

declare class NiagaraCurveDataObject extends NiagaraDataObject { 
	CurveObj: CurveVector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraCurveDataObject;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraCurveDataObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraCurveDataObject;
	static C(Other: UObject): NiagaraCurveDataObject;
}

declare class NiagaraSparseVolumeDataObject extends NiagaraDataObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraSparseVolumeDataObject;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraSparseVolumeDataObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraSparseVolumeDataObject;
	static C(Other: UObject): NiagaraSparseVolumeDataObject;
}

declare class CookerStats extends UObject { 
	Assets: any[];
	SizeBefore: number;
	SizeAfter: number;
	Path: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CookerStats;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CookerStats;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CookerStats;
	static C(Other: UObject): CookerStats;
}

declare class LightingBuildInfo extends UObject { 
	UObject: any;
	LightingTime: number;
	UnmappedTexelsPercentage: number;
	UnmappedTexelsMemory: number;
	TotalTexelMemory: number;
	LevelName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LightingBuildInfo;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LightingBuildInfo;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightingBuildInfo;
	static C(Other: UObject): LightingBuildInfo;
}

declare class PrimitiveStats extends UObject { 
	UObject: any;
	Actors: any[];
	Type: string;
	Count: number;
	Sections: number;
	InstSections: number;
	Triangles: number;
	InstTriangles: number;
	ResourceSize: number;
	VertexColorMem: number;
	InstVertexColorMem: number;
	LightsLM: number;
	LightsOther: number;
	LightsTotal: number;
	ObjLightCost: number;
	LightMapData: number;
	LMSMResolution: number;
	RadiusMin: number;
	RadiusMax: number;
	RadiusAvg: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PrimitiveStats;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PrimitiveStats;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveStats;
	static C(Other: UObject): PrimitiveStats;
}

declare class StaticMeshLightingInfo extends UObject { 
	StaticMeshActor: any;
	StaticMesh: any;
	LevelName: string;
	TextureMapping: string;
	bTextureMapping: boolean;
	bHasLightmapTexCoords: boolean;
	StaticLightingResolution: number;
	TextureLightMapMemoryUsage: number;
	VertexLightMapMemoryUsage: number;
	LightMapLightCount: number;
	TextureShadowMapMemoryUsage: number;
	VertexShadowMapMemoryUsage: number;
	ShadowMapLightCount: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): StaticMeshLightingInfo;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): StaticMeshLightingInfo;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshLightingInfo;
	static C(Other: UObject): StaticMeshLightingInfo;
}

declare class TextureStats extends UObject { 
	Texture: any;
	Actors: any[];
	Type: string;
	MaxDim: Vector2D;
	CurrentDim: Vector2D;
	Format: EPixelFormat;
	Group: TextureGroup;
	LODBias: number;
	CurrentKB: number;
	FullyLoadedKB: number;
	NumUses: number;
	LastTimeRendered: number;
	Path: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextureStats;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextureStats;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureStats;
	static C(Other: UObject): TextureStats;
}

declare class GameplayTaskOwnerInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTaskOwnerInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTaskOwnerInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTaskOwnerInterface;
	static C(Other: UObject): GameplayTaskOwnerInterface;
}

declare class GameplayTask_SpawnActor extends GameplayTask { 
	Success: UnrealEngineMulticastDelegate<(SpawnedActor: Actor) => void>;
	DidNotSpawn: UnrealEngineMulticastDelegate<(SpawnedActor: Actor) => void>;
	ClassToSpawn: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTask_SpawnActor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTask_SpawnActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTask_SpawnActor;
	static C(Other: UObject): GameplayTask_SpawnActor;
	FinishSpawningActor(WorldContextObject: UObject,SpawnedActor: Actor): void;
	BeginSpawningActor(WorldContextObject: UObject,SpawnedActor?: Actor): {SpawnedActor: Actor, $: boolean};
}

declare class GameplayTask_WaitDelay extends GameplayTask { 
	OnFinish: UnrealEngineMulticastDelegate<() => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTask_WaitDelay;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTask_WaitDelay;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTask_WaitDelay;
	static C(Other: UObject): GameplayTask_WaitDelay;
}

declare class GameplayTaskResource extends UObject { 
	ManualResourceID: number;
	bManuallySetID: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTaskResource;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTaskResource;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTaskResource;
	static C(Other: UObject): GameplayTaskResource;
}

declare class EditableGameplayTagQueryExpression extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditableGameplayTagQueryExpression;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditableGameplayTagQueryExpression;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression;
	static C(Other: UObject): EditableGameplayTagQueryExpression;
}

declare class GameplayTagQuery { 
	TokenStreamVersion: number;
	TagDictionary: GameplayTag[];
	QueryTokenStream: number[];
	UserDescription: string;
	AutoDescription: string;
}

declare class EditableGameplayTagQuery extends UObject { 
	UserDescription: string;
	RootExpression: EditableGameplayTagQueryExpression;
	TagQueryExportText_Helper: GameplayTagQuery;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditableGameplayTagQuery;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditableGameplayTagQuery;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQuery;
	static C(Other: UObject): EditableGameplayTagQuery;
}

declare class GameplayTagContainer { 
	GameplayTags: GameplayTag[];
	Tags: string[];
}

declare class EditableGameplayTagQueryExpression_AnyTagsMatch extends EditableGameplayTagQueryExpression { 
	Tags: GameplayTagContainer;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_AnyTagsMatch;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_AnyTagsMatch;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_AnyTagsMatch;
	static C(Other: UObject): EditableGameplayTagQueryExpression_AnyTagsMatch;
}

declare class EditableGameplayTagQueryExpression_AllTagsMatch extends EditableGameplayTagQueryExpression { 
	Tags: GameplayTagContainer;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_AllTagsMatch;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_AllTagsMatch;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_AllTagsMatch;
	static C(Other: UObject): EditableGameplayTagQueryExpression_AllTagsMatch;
}

declare class EditableGameplayTagQueryExpression_NoTagsMatch extends EditableGameplayTagQueryExpression { 
	Tags: GameplayTagContainer;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_NoTagsMatch;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_NoTagsMatch;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_NoTagsMatch;
	static C(Other: UObject): EditableGameplayTagQueryExpression_NoTagsMatch;
}

declare class EditableGameplayTagQueryExpression_AnyExprMatch extends EditableGameplayTagQueryExpression { 
	Expressions: EditableGameplayTagQueryExpression[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_AnyExprMatch;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_AnyExprMatch;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_AnyExprMatch;
	static C(Other: UObject): EditableGameplayTagQueryExpression_AnyExprMatch;
}

declare class EditableGameplayTagQueryExpression_AllExprMatch extends EditableGameplayTagQueryExpression { 
	Expressions: EditableGameplayTagQueryExpression[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_AllExprMatch;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_AllExprMatch;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_AllExprMatch;
	static C(Other: UObject): EditableGameplayTagQueryExpression_AllExprMatch;
}

declare class EditableGameplayTagQueryExpression_NoExprMatch extends EditableGameplayTagQueryExpression { 
	Expressions: EditableGameplayTagQueryExpression[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_NoExprMatch;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_NoExprMatch;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_NoExprMatch;
	static C(Other: UObject): EditableGameplayTagQueryExpression_NoExprMatch;
}

declare class GameplayTagAssetInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTagAssetInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTagAssetInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagAssetInterface;
	static C(Other: UObject): GameplayTagAssetInterface;
	HasMatchingGameplayTag(TagToCheck: GameplayTag): boolean;
	HasAnyMatchingGameplayTags(TagContainer: GameplayTagContainer,bCountEmptyAsMatch: boolean): boolean;
	HasAllMatchingGameplayTags(TagContainer: GameplayTagContainer,bCountEmptyAsMatch: boolean): boolean;
	GetOwnedGameplayTags(TagContainer?: GameplayTagContainer): {TagContainer: GameplayTagContainer};
}

declare type EGameplayTagMatchType = string;
declare class BlueprintGameplayTagLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintGameplayTagLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintGameplayTagLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintGameplayTagLibrary;
	static C(Other: UObject): BlueprintGameplayTagLibrary;
	static MakeLiteralGameplayTag(Value: GameplayTag): GameplayTag;
	static MakeGameplayTagQuery(TagQuery: GameplayTagQuery): GameplayTagQuery;
	static GetNumGameplayTagsInContainer(TagContainer: GameplayTagContainer): number;
	static DoGameplayTagsMatch(TagOne: GameplayTag,TagTwo: GameplayTag,TagOneMatchType: EGameplayTagMatchType,TagTwoMatchType: EGameplayTagMatchType): boolean;
	static DoesContainerMatchTagQuery(TagContainer: GameplayTagContainer,TagQuery: GameplayTagQuery): boolean;
	static DoesContainerMatchAnyTagsInContainer(TagContainer: GameplayTagContainer,OtherContainer: GameplayTagContainer,bCountEmptyAsMatch: boolean): boolean;
	static DoesContainerMatchAllTagsInContainer(TagContainer: GameplayTagContainer,OtherContainer: GameplayTagContainer,bCountEmptyAsMatch: boolean): boolean;
	static DoesContainerHaveTag(TagContainer: GameplayTagContainer,ContainerTagsMatchType: EGameplayTagMatchType,Tag: GameplayTag,TagMatchType: EGameplayTagMatchType): boolean;
	static AppendGameplayTagContainers(InTagContainer: GameplayTagContainer,InOutTagContainer?: GameplayTagContainer): {InOutTagContainer: GameplayTagContainer, $: boolean};
}

declare class TableRowBase { 
}

declare class DataTable extends UObject { 
	RowStruct: ScriptStruct;
	AssetImportData: AssetImportData;
	ImportPath: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DataTable;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DataTable;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataTable;
	static C(Other: UObject): DataTable;
	GetDataTableRowFromName(RowName: string,OutRow?: TableRowBase): {OutRow: TableRowBase, $: boolean};
	GetDataTableRowNames(OutRowNames?: string[]): {OutRowNames: string[]};
}

declare class GameplayTagsManager extends UObject { 
	GameplayTagTables: DataTable[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTagsManager;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTagsManager;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsManager;
	static C(Other: UObject): GameplayTagsManager;
	RequestGameplayTag(TagName: string,ErrorIfNotFound: boolean): GameplayTag;
}

declare class GameplayTagsSettings extends UObject { 
	GameplayTags: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTagsSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTagsSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsSettings;
	static C(Other: UObject): GameplayTagsSettings;
}

declare class AIResourceInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AIResourceInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AIResourceInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIResourceInterface;
	static C(Other: UObject): AIResourceInterface;
}

declare class AIBlueprintHelperLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AIBlueprintHelperLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AIBlueprintHelperLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIBlueprintHelperLibrary;
	static C(Other: UObject): AIBlueprintHelperLibrary;
	static UnlockAIResourcesWithAnimation(AnimInstance: AnimInstance,bUnlockMovement: boolean,UnlockAILogic: boolean): void;
	static SpawnAIFromClass(WorldContextObject: UObject,PawnClass: UnrealEngineClass,BehaviorTree: BehaviorTree,Location: Vector,Rotation: Rotator,bNoCollisionFail: boolean): Pawn;
	static SendAIMessage(Target: Pawn,Message: string,MessageSource: UObject,bSuccess: boolean): void;
	static LockAIResourcesWithAnimation(AnimInstance: AnimInstance,bLockMovement: boolean,LockAILogic: boolean): void;
	static IsValidAIRotation(Rotation: Rotator): boolean;
	static IsValidAILocation(Location: Vector): boolean;
	static IsValidAIDirection(DirectionVector: Vector): boolean;
	static GetBlackboard(Target: Actor): BlackboardComponent;
	static GetAIController(ControlledActor: Actor): AIController;
	static CreateMoveToProxyObject(WorldContextObject: UObject,Pawn: Pawn,Destination: Vector,TargetActor: Actor,AcceptanceRadius: number,bStopOnOverlap: boolean): AIAsyncTaskBlueprintProxy;
}

declare class AIPerceptionListenerInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AIPerceptionListenerInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AIPerceptionListenerInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIPerceptionListenerInterface;
	static C(Other: UObject): AIPerceptionListenerInterface;
}

declare class BehaviorTreeTypes extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeTypes;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeTypes;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeTypes;
	static C(Other: UObject): BehaviorTreeTypes;
}

declare class GenericTeamAgentInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GenericTeamAgentInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GenericTeamAgentInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GenericTeamAgentInterface;
	static C(Other: UObject): GenericTeamAgentInterface;
}

declare class DetourCrowdAIController extends AIController { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DetourCrowdAIController;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DetourCrowdAIController;
	static C(Other: UObject): DetourCrowdAIController;
}

declare class AIDataProvider extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AIDataProvider;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AIDataProvider;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIDataProvider;
	static C(Other: UObject): AIDataProvider;
}

declare class AIDataProvider_QueryParams extends AIDataProvider { 
	ParamName: string;
	FloatValue: number;
	IntValue: number;
	BoolValue: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AIDataProvider_QueryParams;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AIDataProvider_QueryParams;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIDataProvider_QueryParams;
	static C(Other: UObject): AIDataProvider_QueryParams;
}

declare class AIHotSpotManager extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AIHotSpotManager;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AIHotSpotManager;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIHotSpotManager;
	static C(Other: UObject): AIHotSpotManager;
}

declare class BehaviorTreeTemplateInfo { 
	Asset: BehaviorTree;
	Template: BTCompositeNode;
}

declare class BehaviorTreeManager extends UObject { 
	MaxDebuggerSteps: number;
	LoadedTemplates: BehaviorTreeTemplateInfo[];
	ActiveComponents: BehaviorTreeComponent[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeManager;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeManager;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeManager;
	static C(Other: UObject): BehaviorTreeManager;
}

declare class EnvQueryNode extends UObject { 
	VerNum: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryNode;
	static C(Other: UObject): EnvQueryNode;
}

declare class EnvQueryItemType extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryItemType;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryItemType;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType;
	static C(Other: UObject): EnvQueryItemType;
}

declare class EnvQueryGenerator extends EnvQueryNode { 
	OptionName: string;
	ItemType: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryGenerator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryGenerator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator;
	static C(Other: UObject): EnvQueryGenerator;
}

declare type EEnvTestPurpose = string;
declare type EEnvTestFilterOperator = string;
declare type EEnvTestScoreOperator = string;
declare type EEnvTestFilterType = string;
declare class AIDataProviderValue { 
	CachedProperty: Property;
	DataBinding: AIDataProvider;
	DataField: string;
}

declare class AIDataProviderTypedValue extends AIDataProviderValue { 
	PropertyType: UnrealEngineClass;
}

declare class AIDataProviderBoolValue extends AIDataProviderTypedValue { 
	DefaultValue: boolean;
}

declare class AIDataProviderFloatValue extends AIDataProviderTypedValue { 
	DefaultValue: number;
}

declare type EEnvTestScoreEquation = string;
declare type EEnvQueryTestClamping = string;
declare class EnvQueryTest extends EnvQueryNode { 
	TestOrder: number;
	TestPurpose: EEnvTestPurpose;
	MultipleContextFilterOp: EEnvTestFilterOperator;
	MultipleContextScoreOp: EEnvTestScoreOperator;
	FilterType: EEnvTestFilterType;
	BoolValue: AIDataProviderBoolValue;
	FloatValueMin: AIDataProviderFloatValue;
	FloatValueMax: AIDataProviderFloatValue;
	ScoringEquation: EEnvTestScoreEquation;
	ClampMinType: EEnvQueryTestClamping;
	ClampMaxType: EEnvQueryTestClamping;
	ScoreClampMin: AIDataProviderFloatValue;
	ScoreClampMax: AIDataProviderFloatValue;
	ScoringFactor: AIDataProviderFloatValue;
	bWorkOnFloatValues: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryTest;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryTest;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest;
	static C(Other: UObject): EnvQueryTest;
}

declare class EnvQueryOption extends UObject { 
	Generator: EnvQueryGenerator;
	Tests: EnvQueryTest[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryOption;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryOption;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryOption;
	static C(Other: UObject): EnvQueryOption;
}

declare class EnvQuery extends UObject { 
	EdGraph: EdGraph;
	Options: EnvQueryOption[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQuery;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQuery;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQuery;
	static C(Other: UObject): EnvQuery;
}

declare class EnvQueryInstanceCache { 
	Template: EnvQuery;
}

declare class EnvQueryContext extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryContext;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryContext;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryContext;
	static C(Other: UObject): EnvQueryContext;
}

declare type EEnvQueryRunMode = string;
declare type EEnvQueryStatus = string;
declare class EnvQueryInstanceBlueprintWrapper extends UObject { 
	QueryID: number;
	ItemType: UnrealEngineClass;
	OptionIndex: number;
	OnQueryFinishedEvent: UnrealEngineMulticastDelegate<(QueryInstance: EnvQueryInstanceBlueprintWrapper, QueryStatus: EEnvQueryStatus) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryInstanceBlueprintWrapper;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryInstanceBlueprintWrapper;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryInstanceBlueprintWrapper;
	static C(Other: UObject): EnvQueryInstanceBlueprintWrapper;
	GetResultsAsLocations(): Vector[];
	GetResultsAsActors(): Actor[];
	GetItemScore(ItemIndex: number): number;
}

declare class EnvQueryManager extends UObject { 
	InstanceCache: EnvQueryInstanceCache[];
	LocalContexts: EnvQueryContext[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryManager;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryManager;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryManager;
	static C(Other: UObject): EnvQueryManager;
	static RunEQSQuery(WorldContext: UObject,QueryTemplate: EnvQuery,Querier: UObject,RunMode: EEnvQueryRunMode,WrapperClass: UnrealEngineClass): EnvQueryInstanceBlueprintWrapper;
}

declare class AISystem extends AISystemBase { 
	PerceptionSystemClassName: StringClassReference;
	HotSpotManagerClassName: StringClassReference;
	AcceptanceRadius: number;
	bFinishMoveOnGoalOverlap: boolean;
	bAcceptPartialPaths: boolean;
	bAllowStrafing: boolean;
	bEnableBTAITasks: boolean;
	BehaviorTreeManager: BehaviorTreeManager;
	EnvironmentQueryManager: EnvQueryManager;
	PerceptionSystem: AIPerceptionSystem;
	AllProxyObjects: AIAsyncTaskBlueprintProxy[];
	HotSpotManager: AIHotSpotManager;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISystem;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISystem;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISystem;
	static C(Other: UObject): AISystem;
	AILoggingVerbose(): void;
	AIIgnorePlayers(): void;
}

declare class AIPerceptionStimuliSourceComponent extends ActorComponent { 
	bAutoRegisterAsSource: boolean;
	RegisterAsSourceForSenses: UnrealEngineClass[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AIPerceptionStimuliSourceComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AIPerceptionStimuliSourceComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIPerceptionStimuliSourceComponent;
	static C(Other: UObject): AIPerceptionStimuliSourceComponent;
	UnregisterFromSense(SenseClass: UnrealEngineClass): void;
	UnregisterFromPerceptionSystem(): void;
	RegisterWithPerceptionSystem(): void;
	RegisterForSense(SenseClass: UnrealEngineClass): void;
}

declare class AIResource_Movement extends GameplayTaskResource { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AIResource_Movement;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AIResource_Movement;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIResource_Movement;
	static C(Other: UObject): AIResource_Movement;
}

declare class AIResource_Logic extends GameplayTaskResource { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AIResource_Logic;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AIResource_Logic;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIResource_Logic;
	static C(Other: UObject): AIResource_Logic;
}

declare type EUserDefinedStructureStatus = string;
declare class UserDefinedStruct extends ScriptStruct { 
	Status: EUserDefinedStructureStatus;
	PrimaryStruct: any;
	ErrorMessage: string;
	EditorData: UObject;
	Guid: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UserDefinedStruct;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UserDefinedStruct;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserDefinedStruct;
	static C(Other: UObject): UserDefinedStruct;
}

declare class AISense_Blueprint extends AISense { 
	ListenerDataType: UnrealEngineClass;
	ListenerContainer: AIPerceptionComponent[];
	UnprocessedEvents: AISenseEvent[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISense_Blueprint;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISense_Blueprint;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Blueprint;
	static C(Other: UObject): AISense_Blueprint;
	OnUpdate(EventsToProcess: AISenseEvent[]): number;
	OnListenerUpdated(ActorListener: Actor,PerceptionComponent: AIPerceptionComponent): void;
	OnListenerUnregistered(ActorListener: Actor,PerceptionComponent: AIPerceptionComponent): void;
	OnListenerRegistered(ActorListener: Actor,PerceptionComponent: AIPerceptionComponent): void;
	OnNewPawn(NewPawn: Pawn): void;
	GetAllListenerComponents(ListenerComponents?: AIPerceptionComponent[]): {ListenerComponents: AIPerceptionComponent[]};
	GetAllListenerActors(ListenerActors?: Actor[]): {ListenerActors: Actor[]};
}

declare class AIDamageEvent { 
	Amount: number;
	Location: Vector;
	HitLocation: Vector;
	DamagedActor: Actor;
	Instigator: Actor;
}

declare class AISense_Damage extends AISense { 
	RegisteredEvents: AIDamageEvent[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISense_Damage;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISense_Damage;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Damage;
	static C(Other: UObject): AISense_Damage;
	static ReportDamageEvent(WorldContext: UObject,DamagedActor: Actor,Instigator: Actor,DamageAmount: number,EventLocation: Vector,HitLocation: Vector): void;
}

declare class AINoiseEvent { 
	NoiseLocation: Vector;
	Loudness: number;
	MaxRange: number;
	Instigator: Actor;
	Tag: string;
}

declare class AISense_Hearing extends AISense { 
	NoiseEvents: AINoiseEvent[];
	SpeedOfSoundSq: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISense_Hearing;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISense_Hearing;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Hearing;
	static C(Other: UObject): AISense_Hearing;
	static ReportNoiseEvent(WorldContext: UObject,NoiseLocation: Vector,Loudness: number,Instigator: Actor,MaxRange: number,Tag: string): void;
}

declare class AIPredictionEvent { 
	Requestor: Actor;
	PredictedActor: Actor;
}

declare class AISense_Prediction extends AISense { 
	RegisteredEvents: AIPredictionEvent[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISense_Prediction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISense_Prediction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Prediction;
	static C(Other: UObject): AISense_Prediction;
	static RequestPawnPredictionEvent(Requestor: Pawn,PredictedActor: Actor,PredictionTime: number): void;
	static RequestControllerPredictionEvent(Requestor: AIController,PredictedActor: Actor,PredictionTime: number): void;
}

declare class AISense_Sight extends AISense { 
	MaxTracesPerTick: number;
	HighImportanceQueryDistanceThreshold: number;
	MaxQueryImportance: number;
	SightLimitQueryImportance: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISense_Sight;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISense_Sight;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Sight;
	static C(Other: UObject): AISense_Sight;
}

declare class AITeamStimulusEvent { 
	Broadcaster: Actor;
	Enemy: Actor;
}

declare class AISense_Team extends AISense { 
	RegisteredEvents: AITeamStimulusEvent[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISense_Team;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISense_Team;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Team;
	static C(Other: UObject): AISense_Team;
}

declare class AITouchEvent { 
	TouchReceiver: Actor;
	OtherActor: Actor;
}

declare class AISense_Touch extends AISense { 
	RegisteredEvents: AITouchEvent[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISense_Touch;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISense_Touch;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Touch;
	static C(Other: UObject): AISense_Touch;
}

declare class AISenseBlueprintListener extends UserDefinedStruct { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISenseBlueprintListener;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISenseBlueprintListener;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseBlueprintListener;
	static C(Other: UObject): AISenseBlueprintListener;
}

declare class AISenseConfig_Blueprint extends AISenseConfig { 
	Implementation: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISenseConfig_Blueprint;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISenseConfig_Blueprint;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Blueprint;
	static C(Other: UObject): AISenseConfig_Blueprint;
}

declare class AISenseConfig_Damage extends AISenseConfig { 
	Implementation: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISenseConfig_Damage;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISenseConfig_Damage;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Damage;
	static C(Other: UObject): AISenseConfig_Damage;
}

declare class AISenseAffiliationFilter { 
	bDetectEnemies: boolean;
	bDetectNeutrals: boolean;
	bDetectFriendlies: boolean;
}

declare class AISenseConfig_Hearing extends AISenseConfig { 
	Implementation: UnrealEngineClass;
	HearingRange: number;
	LoSHearingRange: number;
	bUseLoSHearing: boolean;
	DetectionByAffiliation: AISenseAffiliationFilter;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISenseConfig_Hearing;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISenseConfig_Hearing;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Hearing;
	static C(Other: UObject): AISenseConfig_Hearing;
}

declare class AISenseConfig_Prediction extends AISenseConfig { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISenseConfig_Prediction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISenseConfig_Prediction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Prediction;
	static C(Other: UObject): AISenseConfig_Prediction;
}

declare class AISenseConfig_Sight extends AISenseConfig { 
	Implementation: UnrealEngineClass;
	SightRadius: number;
	LoseSightRadius: number;
	PeripheralVisionAngleDegrees: number;
	DetectionByAffiliation: AISenseAffiliationFilter;
	AutoSuccessRangeFromLastSeenLocation: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISenseConfig_Sight;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISenseConfig_Sight;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Sight;
	static C(Other: UObject): AISenseConfig_Sight;
}

declare class AISenseConfig_Team extends AISenseConfig { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISenseConfig_Team;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISenseConfig_Team;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Team;
	static C(Other: UObject): AISenseConfig_Team;
}

declare class AISenseConfig_Touch extends AISenseConfig { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISenseConfig_Touch;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISenseConfig_Touch;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Touch;
	static C(Other: UObject): AISenseConfig_Touch;
}

declare class AISenseEvent_Damage extends AISenseEvent { 
	Event: AIDamageEvent;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISenseEvent_Damage;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISenseEvent_Damage;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseEvent_Damage;
	static C(Other: UObject): AISenseEvent_Damage;
}

declare class AISenseEvent_Hearing extends AISenseEvent { 
	Event: AINoiseEvent;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISenseEvent_Hearing;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISenseEvent_Hearing;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseEvent_Hearing;
	static C(Other: UObject): AISenseEvent_Hearing;
}

declare class AISightTargetInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISightTargetInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISightTargetInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISightTargetInterface;
	static C(Other: UObject): AISightTargetInterface;
}

declare class AITask extends GameplayTask { 
	OwnerController: AIController;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AITask;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AITask;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AITask;
	static C(Other: UObject): AITask;
}

declare type EAIOptionFlag = string;
declare class AITask_MoveTo extends AITask { 
	OnRequestFailed: UnrealEngineMulticastDelegate<() => void>;
	OnMoveFinished: UnrealEngineMulticastDelegate<(Result: EPathFollowingResult) => void>;
	MoveGoalLocation: Vector;
	MoveGoalActor: Actor;
	MoveAcceptanceRadius: number;
	bShouldStopOnOverlap: boolean;
	bShouldAcceptPartialPath: boolean;
	bShouldUsePathfinding: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AITask_MoveTo;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AITask_MoveTo;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AITask_MoveTo;
	static C(Other: UObject): AITask_MoveTo;
	static MoveToLocationorActor(Controller: AIController,GoalLocation: Vector,GoalActor: Actor,AcceptanceRadius: number,StopOnOverlap: EAIOptionFlag,AcceptPartialPath: EAIOptionFlag,bUsePathfinding: boolean,bLockAILogic: boolean): AITask_MoveTo;
}

declare class BlackboardKeyType_Enum extends BlackboardKeyType { 
	EnumType: Enum;
	EnumName: string;
	bIsEnumNameValid: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlackboardKeyType_Enum;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlackboardKeyType_Enum;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Enum;
	static C(Other: UObject): BlackboardKeyType_Enum;
}

declare class BlackboardKeyType_NativeEnum extends BlackboardKeyType { 
	EnumName: string;
	EnumType: Enum;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlackboardKeyType_NativeEnum;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlackboardKeyType_NativeEnum;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_NativeEnum;
	static C(Other: UObject): BlackboardKeyType_NativeEnum;
}

declare class BlackboardKeyType_Bool extends BlackboardKeyType { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlackboardKeyType_Bool;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlackboardKeyType_Bool;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Bool;
	static C(Other: UObject): BlackboardKeyType_Bool;
}

declare class BlackboardKeyType_Class extends BlackboardKeyType { 
	BaseClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlackboardKeyType_Class;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlackboardKeyType_Class;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Class;
	static C(Other: UObject): BlackboardKeyType_Class;
}

declare class BlackboardKeyType_Float extends BlackboardKeyType { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlackboardKeyType_Float;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlackboardKeyType_Float;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Float;
	static C(Other: UObject): BlackboardKeyType_Float;
}

declare class BlackboardKeyType_Int extends BlackboardKeyType { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlackboardKeyType_Int;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlackboardKeyType_Int;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Int;
	static C(Other: UObject): BlackboardKeyType_Int;
}

declare class BlackboardKeyType_Name extends BlackboardKeyType { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlackboardKeyType_Name;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlackboardKeyType_Name;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Name;
	static C(Other: UObject): BlackboardKeyType_Name;
}

declare class BlackboardKeyType_Object extends BlackboardKeyType { 
	BaseClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlackboardKeyType_Object;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlackboardKeyType_Object;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Object;
	static C(Other: UObject): BlackboardKeyType_Object;
}

declare class BlackboardKeyType_Rotator extends BlackboardKeyType { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlackboardKeyType_Rotator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlackboardKeyType_Rotator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Rotator;
	static C(Other: UObject): BlackboardKeyType_Rotator;
}

declare class BlackboardKeyType_String extends BlackboardKeyType { 
	StringValue: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlackboardKeyType_String;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlackboardKeyType_String;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_String;
	static C(Other: UObject): BlackboardKeyType_String;
}

declare class BlackboardKeyType_Vector extends BlackboardKeyType { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlackboardKeyType_Vector;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlackboardKeyType_Vector;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Vector;
	static C(Other: UObject): BlackboardKeyType_Vector;
}

declare class BTFunctionLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTFunctionLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTFunctionLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTFunctionLibrary;
	static C(Other: UObject): BTFunctionLibrary;
	static StopUsingExternalEvent(NodeOwner: BTNode): void;
	static StartUsingExternalEvent(NodeOwner: BTNode,OwningActor: Actor): void;
	static SetBlackboardValueAsVector(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: Vector): void;
	static SetBlackboardValueAsString(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: string): void;
	static SetBlackboardValueAsRotator(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: Rotator): void;
	static SetBlackboardValueAsObject(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: UObject): void;
	static SetBlackboardValueAsName(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: string): void;
	static SetBlackboardValueAsInt(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: number): void;
	static SetBlackboardValueAsFloat(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: number): void;
	static SetBlackboardValueAsEnum(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: number): void;
	static SetBlackboardValueAsClass(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: UnrealEngineClass): void;
	static SetBlackboardValueAsBool(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: boolean): void;
	static GetOwnersBlackboard(NodeOwner: BTNode): BlackboardComponent;
	static GetOwnerComponent(NodeOwner: BTNode): BehaviorTreeComponent;
	static GetBlackboardValueAsVector(NodeOwner: BTNode,Key: BlackboardKeySelector): Vector;
	static GetBlackboardValueAsString(NodeOwner: BTNode,Key: BlackboardKeySelector): string;
	static GetBlackboardValueAsRotator(NodeOwner: BTNode,Key: BlackboardKeySelector): Rotator;
	static GetBlackboardValueAsObject(NodeOwner: BTNode,Key: BlackboardKeySelector): UObject;
	static GetBlackboardValueAsName(NodeOwner: BTNode,Key: BlackboardKeySelector): string;
	static GetBlackboardValueAsInt(NodeOwner: BTNode,Key: BlackboardKeySelector): number;
	static GetBlackboardValueAsFloat(NodeOwner: BTNode,Key: BlackboardKeySelector): number;
	static GetBlackboardValueAsEnum(NodeOwner: BTNode,Key: BlackboardKeySelector): number;
	static GetBlackboardValueAsClass(NodeOwner: BTNode,Key: BlackboardKeySelector): UnrealEngineClass;
	static GetBlackboardValueAsBool(NodeOwner: BTNode,Key: BlackboardKeySelector): boolean;
	static GetBlackboardValueAsActor(NodeOwner: BTNode,Key: BlackboardKeySelector): Actor;
	static ClearBlackboardValueAsVector(NodeOwner: BTNode,Key: BlackboardKeySelector): void;
	static ClearBlackboardValue(NodeOwner: BTNode,Key: BlackboardKeySelector): void;
}

declare class BTDecorator_BlackboardBase extends BTDecorator { 
	BlackboardKey: BlackboardKeySelector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator_BlackboardBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator_BlackboardBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_BlackboardBase;
	static C(Other: UObject): BTDecorator_BlackboardBase;
}

declare type EBTBlackboardRestart = string;
declare type EBasicKeyOperation = string;
declare type EArithmeticKeyOperation = string;
declare type ETextKeyOperation = string;
declare class BTDecorator_Blackboard extends BTDecorator_BlackboardBase { 
	IntValue: number;
	FloatValue: number;
	StringValue: string;
	CachedDescription: string;
	OperationType: number;
	NotifyObserver: EBTBlackboardRestart;
	BasicOperation: EBasicKeyOperation;
	ArithmeticOperation: EArithmeticKeyOperation;
	TextOperation: ETextKeyOperation;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator_Blackboard;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator_Blackboard;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_Blackboard;
	static C(Other: UObject): BTDecorator_Blackboard;
}

declare class BTDecorator_ConditionalLoop extends BTDecorator_Blackboard { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator_ConditionalLoop;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator_ConditionalLoop;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_ConditionalLoop;
	static C(Other: UObject): BTDecorator_ConditionalLoop;
}

declare class BTDecorator_IsAtLocation extends BTDecorator_BlackboardBase { 
	AcceptableRadius: number;
	bUseNavAgentGoalLocation: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator_IsAtLocation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator_IsAtLocation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_IsAtLocation;
	static C(Other: UObject): BTDecorator_IsAtLocation;
}

declare class BTDecorator_IsBBEntryOfClass extends BTDecorator_BlackboardBase { 
	TestClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator_IsBBEntryOfClass;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator_IsBBEntryOfClass;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_IsBBEntryOfClass;
	static C(Other: UObject): BTDecorator_IsBBEntryOfClass;
}

declare type EBTNodeResult = string;
declare class BTDecorator_BlueprintBase extends BTDecorator { 
	AIOwner: AIController;
	ActorOwner: Actor;
	ObservedKeyNames: string[];
	bShowPropertyDetails: boolean;
	bCheckConditionOnlyBlackBoardChanges: boolean;
	bIsObservingBB: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator_BlueprintBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator_BlueprintBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_BlueprintBase;
	static C(Other: UObject): BTDecorator_BlueprintBase;
	ReceiveTickAI(OwnerController: AIController,ControlledPawn: Pawn,DeltaSeconds: number): void;
	ReceiveTick(OwnerActor: Actor,DeltaSeconds: number): void;
	ReceiveObserverDeactivatedAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveObserverDeactivated(OwnerActor: Actor): void;
	ReceiveObserverActivatedAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveObserverActivated(OwnerActor: Actor): void;
	ReceiveExecutionStartAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveExecutionStart(OwnerActor: Actor): void;
	ReceiveExecutionFinishAI(OwnerController: AIController,ControlledPawn: Pawn,NodeResult: EBTNodeResult): void;
	ReceiveExecutionFinish(OwnerActor: Actor,NodeResult: EBTNodeResult): void;
	ReceiveConditionCheck(OwnerActor: Actor): void;
	PerformConditionCheckAI(OwnerController: AIController,ControlledPawn: Pawn): boolean;
	PerformConditionCheck(OwnerActor: Actor): boolean;
	IsDecoratorObserverActive(): boolean;
	IsDecoratorExecutionActive(): boolean;
	FinishConditionCheck(bAllowExecution: boolean): void;
}

declare type EGameplayContainerMatchType = string;
declare class BTDecorator_CheckGameplayTagsOnActor extends BTDecorator { 
	ActorToCheck: BlackboardKeySelector;
	TagsToMatch: EGameplayContainerMatchType;
	GameplayTags: GameplayTagContainer;
	CachedDescription: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator_CheckGameplayTagsOnActor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator_CheckGameplayTagsOnActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_CheckGameplayTagsOnActor;
	static C(Other: UObject): BTDecorator_CheckGameplayTagsOnActor;
}

declare type EBlackBoardEntryComparison = string;
declare class BTDecorator_CompareBBEntries extends BTDecorator { 
	Operator: EBlackBoardEntryComparison;
	BlackboardKeyA: BlackboardKeySelector;
	BlackboardKeyB: BlackboardKeySelector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator_CompareBBEntries;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator_CompareBBEntries;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_CompareBBEntries;
	static C(Other: UObject): BTDecorator_CompareBBEntries;
}

declare class BTDecorator_ConeCheck extends BTDecorator { 
	ConeHalfAngle: number;
	ConeOrigin: BlackboardKeySelector;
	ConeDirection: BlackboardKeySelector;
	Observed: BlackboardKeySelector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator_ConeCheck;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator_ConeCheck;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_ConeCheck;
	static C(Other: UObject): BTDecorator_ConeCheck;
}

declare class BTDecorator_Cooldown extends BTDecorator { 
	CoolDownTime: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator_Cooldown;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator_Cooldown;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_Cooldown;
	static C(Other: UObject): BTDecorator_Cooldown;
}

declare type EPathExistanceQueryType = string;
declare class BTDecorator_DoesPathExist extends BTDecorator { 
	BlackboardKeyA: BlackboardKeySelector;
	BlackboardKeyB: BlackboardKeySelector;
	bUseSelf: boolean;
	PathQueryType: EPathExistanceQueryType;
	FilterClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator_DoesPathExist;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator_DoesPathExist;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_DoesPathExist;
	static C(Other: UObject): BTDecorator_DoesPathExist;
}

declare class BTDecorator_ForceSuccess extends BTDecorator { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator_ForceSuccess;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator_ForceSuccess;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_ForceSuccess;
	static C(Other: UObject): BTDecorator_ForceSuccess;
}

declare class BTDecorator_KeepInCone extends BTDecorator { 
	ConeHalfAngle: number;
	ConeOrigin: BlackboardKeySelector;
	Observed: BlackboardKeySelector;
	bUseSelfAsOrigin: boolean;
	bUseSelfAsObserved: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator_KeepInCone;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator_KeepInCone;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_KeepInCone;
	static C(Other: UObject): BTDecorator_KeepInCone;
}

declare class BTDecorator_Loop extends BTDecorator { 
	NumLoops: number;
	bInfiniteLoop: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator_Loop;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator_Loop;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_Loop;
	static C(Other: UObject): BTDecorator_Loop;
}

declare class BTDecorator_ReachedMoveGoal extends BTDecorator { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator_ReachedMoveGoal;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator_ReachedMoveGoal;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_ReachedMoveGoal;
	static C(Other: UObject): BTDecorator_ReachedMoveGoal;
}

declare class BTDecorator_SetTagCooldown extends BTDecorator { 
	CooldownTag: GameplayTag;
	CooldownDuration: number;
	bAddToExistingDuration: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator_SetTagCooldown;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator_SetTagCooldown;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_SetTagCooldown;
	static C(Other: UObject): BTDecorator_SetTagCooldown;
}

declare class BTDecorator_TagCooldown extends BTDecorator { 
	CooldownTag: GameplayTag;
	CooldownDuration: number;
	bAddToExistingDuration: boolean;
	bActivatesCooldown: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator_TagCooldown;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator_TagCooldown;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_TagCooldown;
	static C(Other: UObject): BTDecorator_TagCooldown;
}

declare class BTDecorator_TimeLimit extends BTDecorator { 
	TimeLimit: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator_TimeLimit;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator_TimeLimit;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_TimeLimit;
	static C(Other: UObject): BTDecorator_TimeLimit;
}

declare class BTService_BlackboardBase extends BTService { 
	BlackboardKey: BlackboardKeySelector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTService_BlackboardBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTService_BlackboardBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTService_BlackboardBase;
	static C(Other: UObject): BTService_BlackboardBase;
}

declare class BTService_DefaultFocus extends BTService_BlackboardBase { 
	FocusPriority: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTService_DefaultFocus;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTService_DefaultFocus;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTService_DefaultFocus;
	static C(Other: UObject): BTService_DefaultFocus;
}

declare class BTService_BlueprintBase extends BTService { 
	AIOwner: AIController;
	ActorOwner: Actor;
	bShowPropertyDetails: boolean;
	bShowEventDetails: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTService_BlueprintBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTService_BlueprintBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTService_BlueprintBase;
	static C(Other: UObject): BTService_BlueprintBase;
	ReceiveTickAI(OwnerController: AIController,ControlledPawn: Pawn,DeltaSeconds: number): void;
	ReceiveTick(OwnerActor: Actor,DeltaSeconds: number): void;
	ReceiveSearchStartAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveSearchStart(OwnerActor: Actor): void;
	ReceiveDeactivationAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveDeactivation(OwnerActor: Actor): void;
	ReceiveActivationAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveActivation(OwnerActor: Actor): void;
	IsServiceActive(): boolean;
}

declare class BTComposite_Selector extends BTCompositeNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTComposite_Selector;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTComposite_Selector;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTComposite_Selector;
	static C(Other: UObject): BTComposite_Selector;
}

declare class BTComposite_Sequence extends BTCompositeNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTComposite_Sequence;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTComposite_Sequence;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTComposite_Sequence;
	static C(Other: UObject): BTComposite_Sequence;
}

declare type EBTParallelMode = string;
declare class BTComposite_SimpleParallel extends BTCompositeNode { 
	FinishMode: EBTParallelMode;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTComposite_SimpleParallel;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTComposite_SimpleParallel;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTComposite_SimpleParallel;
	static C(Other: UObject): BTComposite_SimpleParallel;
}

declare class BTTask_BlackboardBase extends BTTaskNode { 
	BlackboardKey: BlackboardKeySelector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTTask_BlackboardBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTTask_BlackboardBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_BlackboardBase;
	static C(Other: UObject): BTTask_BlackboardBase;
}

declare class BTTask_MoveDirectlyToward extends BTTask_BlackboardBase { 
	AcceptableRadius: number;
	bDisablePathUpdateOnGoalLocationChange: boolean;
	bProjectVectorGoalToNavigation: boolean;
	bAllowStrafe: boolean;
	bStopOnOverlap: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTTask_MoveDirectlyToward;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTTask_MoveDirectlyToward;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_MoveDirectlyToward;
	static C(Other: UObject): BTTask_MoveDirectlyToward;
}

declare class BTTask_MoveTo extends BTTask_BlackboardBase { 
	AcceptableRadius: number;
	FilterClass: UnrealEngineClass;
	bAllowStrafe: boolean;
	bAllowPartialPath: boolean;
	bStopOnOverlap: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTTask_MoveTo;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTTask_MoveTo;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_MoveTo;
	static C(Other: UObject): BTTask_MoveTo;
}

declare class BTTask_RotateToFaceBBEntry extends BTTask_BlackboardBase { 
	Precision: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTTask_RotateToFaceBBEntry;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTTask_RotateToFaceBBEntry;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_RotateToFaceBBEntry;
	static C(Other: UObject): BTTask_RotateToFaceBBEntry;
}

declare class EnvQueryTypes extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryTypes;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryTypes;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTypes;
	static C(Other: UObject): EnvQueryTypes;
}

declare type EEnvQueryParam = string;
declare class EnvNamedValue { 
	ParamName: string;
	ParamType: EEnvQueryParam;
	Value: number;
}

declare class BTTask_RunEQSQuery extends BTTask_BlackboardBase { 
	QueryTemplate: EnvQuery;
	QueryParams: EnvNamedValue[];
	RunMode: EEnvQueryRunMode;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTTask_RunEQSQuery;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTTask_RunEQSQuery;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_RunEQSQuery;
	static C(Other: UObject): BTTask_RunEQSQuery;
}

declare class BTTask_BlueprintBase extends BTTaskNode { 
	AIOwner: AIController;
	ActorOwner: Actor;
	bShowPropertyDetails: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTTask_BlueprintBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTTask_BlueprintBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_BlueprintBase;
	static C(Other: UObject): BTTask_BlueprintBase;
	SetFinishOnMessageWithId(MessageName: string,RequestID: number): void;
	SetFinishOnMessage(MessageName: string): void;
	ReceiveTickAI(OwnerController: AIController,ControlledPawn: Pawn,DeltaSeconds: number): void;
	ReceiveTick(OwnerActor: Actor,DeltaSeconds: number): void;
	ReceiveExecuteAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveExecute(OwnerActor: Actor): void;
	ReceiveAbortAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveAbort(OwnerActor: Actor): void;
	IsTaskExecuting(): boolean;
	IsTaskAborting(): boolean;
	FinishExecute(bSuccess: boolean): void;
	FinishAbort(): void;
}

declare class BTTask_MakeNoise extends BTTaskNode { 
	Loudnes: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTTask_MakeNoise;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTTask_MakeNoise;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_MakeNoise;
	static C(Other: UObject): BTTask_MakeNoise;
}

declare class BTTask_PawnActionBase extends BTTaskNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTTask_PawnActionBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTTask_PawnActionBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_PawnActionBase;
	static C(Other: UObject): BTTask_PawnActionBase;
}

declare class BTTask_PushPawnAction extends BTTask_PawnActionBase { 
	Action: PawnAction;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTTask_PushPawnAction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTTask_PushPawnAction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_PushPawnAction;
	static C(Other: UObject): BTTask_PushPawnAction;
}

declare class BTTask_PlayAnimation extends BTTaskNode { 
	AnimationToPlay: AnimationAsset;
	bLooping: boolean;
	bNonBlocking: boolean;
	MyOwnerComp: BehaviorTreeComponent;
	CachedSkelMesh: SkeletalMeshComponent;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTTask_PlayAnimation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTTask_PlayAnimation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_PlayAnimation;
	static C(Other: UObject): BTTask_PlayAnimation;
}

declare class SoundNode extends UObject { 
	ChildNodes: SoundNode[];
	GraphNode: EdGraphNode;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNode;
	static C(Other: UObject): SoundNode;
}

declare class SoundCue extends SoundBase { 
	bOverrideAttenuation: boolean;
	FirstNode: SoundNode;
	VolumeMultiplier: number;
	PitchMultiplier: number;
	AttenuationOverrides: AttenuationSettings;
	AllNodes: SoundNode[];
	SoundCueGraph: EdGraph;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundCue;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundCue;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCue;
	static C(Other: UObject): SoundCue;
}

declare class BTTask_PlaySound extends BTTaskNode { 
	SoundToPlay: SoundCue;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTTask_PlaySound;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTTask_PlaySound;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_PlaySound;
	static C(Other: UObject): BTTask_PlaySound;
}

declare class BTTask_RunBehavior extends BTTaskNode { 
	BehaviorAsset: BehaviorTree;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTTask_RunBehavior;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTTask_RunBehavior;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_RunBehavior;
	static C(Other: UObject): BTTask_RunBehavior;
}

declare class BTTask_RunBehaviorDynamic extends BTTaskNode { 
	InjectionTag: GameplayTag;
	DefaultBehaviorAsset: BehaviorTree;
	BehaviorAsset: BehaviorTree;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTTask_RunBehaviorDynamic;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTTask_RunBehaviorDynamic;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_RunBehaviorDynamic;
	static C(Other: UObject): BTTask_RunBehaviorDynamic;
}

declare class BTTask_SetTagCooldown extends BTTaskNode { 
	CooldownTag: GameplayTag;
	bAddToExistingDuration: boolean;
	CooldownDuration: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTTask_SetTagCooldown;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTTask_SetTagCooldown;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_SetTagCooldown;
	static C(Other: UObject): BTTask_SetTagCooldown;
}

declare class BTTask_Wait extends BTTaskNode { 
	WaitTime: number;
	RandomDeviation: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTTask_Wait;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTTask_Wait;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_Wait;
	static C(Other: UObject): BTTask_Wait;
}

declare class BTTask_WaitBlackboardTime extends BTTask_Wait { 
	BlackboardKey: BlackboardKeySelector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTTask_WaitBlackboardTime;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTTask_WaitBlackboardTime;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_WaitBlackboardTime;
	static C(Other: UObject): BTTask_WaitBlackboardTime;
}

declare class CrowdAgentInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CrowdAgentInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CrowdAgentInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CrowdAgentInterface;
	static C(Other: UObject): CrowdAgentInterface;
}

declare class CrowdAvoidanceConfig { 
	VelocityBias: number;
	DesiredVelocityWeight: number;
	CurrentVelocityWeight: number;
	SideBiasWeight: number;
	ImpactTimeWeight: number;
	ImpactTimeRange: number;
	CustomPatternIdx: number;
	AdaptiveDivisions: number;
	AdaptiveRings: number;
	AdaptiveDepth: number;
}

declare class CrowdAvoidanceSamplingPattern { 
	Angles: number[];
	Radii: number[];
}

declare class CrowdManager extends UObject { 
	MyNavData: NavigationData;
	AvoidanceConfig: CrowdAvoidanceConfig[];
	SamplingPatterns: CrowdAvoidanceSamplingPattern[];
	MaxAgents: number;
	MaxAgentRadius: number;
	MaxAvoidedAgents: number;
	MaxAvoidedWalls: number;
	NavmeshCheckInterval: number;
	PathOptimizationInterval: number;
	bResolveCollisions: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CrowdManager;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CrowdManager;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CrowdManager;
	static C(Other: UObject): CrowdManager;
}

declare class EnvQueryContext_BlueprintBase extends EnvQueryContext { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryContext_BlueprintBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryContext_BlueprintBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryContext_BlueprintBase;
	static C(Other: UObject): EnvQueryContext_BlueprintBase;
	ProvideSingleLocation(QuerierActor: Actor,ResultingLocation?: Vector): {ResultingLocation: Vector};
	ProvideSingleActor(QuerierActor: Actor,ResultingActor?: Actor): {ResultingActor: Actor};
	ProvideLocationsSet(QuerierActor: Actor,ResultingLocationSet?: Vector[]): {ResultingLocationSet: Vector[]};
	ProvideActorsSet(QuerierActor: Actor,ResultingActorsSet?: Actor[]): {ResultingActorsSet: Actor[]};
}

declare class EnvQueryContext_Item extends EnvQueryContext { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryContext_Item;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryContext_Item;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryContext_Item;
	static C(Other: UObject): EnvQueryContext_Item;
}

declare class EnvQueryContext_Querier extends EnvQueryContext { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryContext_Querier;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryContext_Querier;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryContext_Querier;
	static C(Other: UObject): EnvQueryContext_Querier;
}

declare class VisualLoggerExtension extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VisualLoggerExtension;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VisualLoggerExtension;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisualLoggerExtension;
	static C(Other: UObject): VisualLoggerExtension;
}

declare class EnvQueryDebugHelpers extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryDebugHelpers;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryDebugHelpers;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryDebugHelpers;
	static C(Other: UObject): EnvQueryDebugHelpers;
}

declare class EQSQueryResultSourceInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EQSQueryResultSourceInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EQSQueryResultSourceInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EQSQueryResultSourceInterface;
	static C(Other: UObject): EQSQueryResultSourceInterface;
}

declare class EnvQueryItemType_VectorBase extends EnvQueryItemType { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryItemType_VectorBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryItemType_VectorBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_VectorBase;
	static C(Other: UObject): EnvQueryItemType_VectorBase;
}

declare class EnvQueryItemType_ActorBase extends EnvQueryItemType_VectorBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryItemType_ActorBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryItemType_ActorBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_ActorBase;
	static C(Other: UObject): EnvQueryItemType_ActorBase;
}

declare class EnvQueryItemType_Actor extends EnvQueryItemType_ActorBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryItemType_Actor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryItemType_Actor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_Actor;
	static C(Other: UObject): EnvQueryItemType_Actor;
}

declare class EnvQueryItemType_Direction extends EnvQueryItemType_VectorBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryItemType_Direction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryItemType_Direction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_Direction;
	static C(Other: UObject): EnvQueryItemType_Direction;
}

declare class EnvQueryItemType_Point extends EnvQueryItemType_VectorBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryItemType_Point;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryItemType_Point;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_Point;
	static C(Other: UObject): EnvQueryItemType_Point;
}

declare class EnvQueryGenerator_ActorsOfClass extends EnvQueryGenerator { 
	SearchRadius: AIDataProviderFloatValue;
	SearchedActorClass: UnrealEngineClass;
	SearchCenter: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryGenerator_ActorsOfClass;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryGenerator_ActorsOfClass;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_ActorsOfClass;
	static C(Other: UObject): EnvQueryGenerator_ActorsOfClass;
}

declare class EnvQueryGenerator_BlueprintBase extends EnvQueryGenerator { 
	GeneratorsActionDescription: string;
	Context: UnrealEngineClass;
	GeneratedItemType: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryGenerator_BlueprintBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryGenerator_BlueprintBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_BlueprintBase;
	static C(Other: UObject): EnvQueryGenerator_BlueprintBase;
	GetQuerier(): UObject;
	DoItemGeneration(ContextLocations: Vector[]): void;
	AddGeneratedVector(GeneratedVector: Vector): void;
	AddGeneratedActor(GeneratedActor: Actor): void;
}

declare class EnvQueryGenerator_Composite extends EnvQueryGenerator { 
	Generators: EnvQueryGenerator[];
	bHasMatchingItemType: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryGenerator_Composite;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryGenerator_Composite;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_Composite;
	static C(Other: UObject): EnvQueryGenerator_Composite;
}

declare type EEnvTraceShape = string;
declare type EEnvQueryTrace = string;
declare class EnvTraceData { 
	VersionNum: number;
	NavigationFilter: UnrealEngineClass;
	ProjectDown: number;
	ProjectUp: number;
	ExtentX: number;
	ExtentY: number;
	ExtentZ: number;
	PostProjectionVerticalOffset: number;
	TraceChannel: ETraceTypeQuery;
	SerializedChannel: ECollisionChannel;
	TraceShape: EEnvTraceShape;
	TraceMode: EEnvQueryTrace;
	bTraceComplex: boolean;
	bOnlyBlockingHits: boolean;
	bCanTraceOnNavMesh: boolean;
	bCanTraceOnGeometry: boolean;
	bCanDisableTrace: boolean;
	bCanProjectDown: boolean;
}

declare class EnvQueryGenerator_ProjectedPoints extends EnvQueryGenerator { 
	ProjectionData: EnvTraceData;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryGenerator_ProjectedPoints;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryGenerator_ProjectedPoints;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_ProjectedPoints;
	static C(Other: UObject): EnvQueryGenerator_ProjectedPoints;
}

declare class AIDataProviderIntValue extends AIDataProviderTypedValue { 
	DefaultValue: number;
}

declare type EEnvDirection = string;
declare class EnvDirection { 
	LineFrom: UnrealEngineClass;
	LineTo: UnrealEngineClass;
	Rotation: UnrealEngineClass;
	DirMode: EEnvDirection;
}

declare class EnvQueryGenerator_Donut extends EnvQueryGenerator_ProjectedPoints { 
	InnerRadius: AIDataProviderFloatValue;
	OuterRadius: AIDataProviderFloatValue;
	NumberOfRings: AIDataProviderIntValue;
	PointsPerRing: AIDataProviderIntValue;
	ArcDirection: EnvDirection;
	ArcAngle: AIDataProviderFloatValue;
	Center: UnrealEngineClass;
	bDefineArc: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryGenerator_Donut;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryGenerator_Donut;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_Donut;
	static C(Other: UObject): EnvQueryGenerator_Donut;
}

declare class EnvQueryGenerator_OnCircle extends EnvQueryGenerator_ProjectedPoints { 
	CircleRadius: AIDataProviderFloatValue;
	SpaceBetween: AIDataProviderFloatValue;
	ArcDirection: EnvDirection;
	ArcAngle: AIDataProviderFloatValue;
	AngleRadians: number;
	CircleCenter: UnrealEngineClass;
	TraceData: EnvTraceData;
	bDefineArc: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryGenerator_OnCircle;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryGenerator_OnCircle;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_OnCircle;
	static C(Other: UObject): EnvQueryGenerator_OnCircle;
}

declare class EnvQueryGenerator_SimpleGrid extends EnvQueryGenerator_ProjectedPoints { 
	GridSize: AIDataProviderFloatValue;
	SpaceBetween: AIDataProviderFloatValue;
	GenerateAround: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryGenerator_SimpleGrid;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryGenerator_SimpleGrid;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_SimpleGrid;
	static C(Other: UObject): EnvQueryGenerator_SimpleGrid;
}

declare class EnvQueryGenerator_PathingGrid extends EnvQueryGenerator_SimpleGrid { 
	PathToItem: AIDataProviderBoolValue;
	NavigationFilter: UnrealEngineClass;
	ScanRangeMultiplier: AIDataProviderFloatValue;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryGenerator_PathingGrid;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryGenerator_PathingGrid;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_PathingGrid;
	static C(Other: UObject): EnvQueryGenerator_PathingGrid;
}

declare type EEnvTestDistance = string;
declare class EnvQueryTest_Distance extends EnvQueryTest { 
	TestMode: EEnvTestDistance;
	DistanceTo: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryTest_Distance;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryTest_Distance;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Distance;
	static C(Other: UObject): EnvQueryTest_Distance;
}

declare type EEnvTestDot = string;
declare class EnvQueryTest_Dot extends EnvQueryTest { 
	LineA: EnvDirection;
	LineB: EnvDirection;
	TestMode: EEnvTestDot;
	bAbsoluteValue: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryTest_Dot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryTest_Dot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Dot;
	static C(Other: UObject): EnvQueryTest_Dot;
}

declare class EnvQueryTest_GameplayTags extends EnvQueryTest { 
	TagsToMatch: EGameplayContainerMatchType;
	GameplayTags: GameplayTagContainer;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryTest_GameplayTags;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryTest_GameplayTags;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_GameplayTags;
	static C(Other: UObject): EnvQueryTest_GameplayTags;
}

declare type EEnvTestPathfinding = string;
declare class EnvQueryTest_Pathfinding extends EnvQueryTest { 
	TestMode: EEnvTestPathfinding;
	Context: UnrealEngineClass;
	PathFromContext: AIDataProviderBoolValue;
	SkipUnreachable: AIDataProviderBoolValue;
	FilterClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryTest_Pathfinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryTest_Pathfinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Pathfinding;
	static C(Other: UObject): EnvQueryTest_Pathfinding;
}

declare class EnvQueryTest_PathfindingBatch extends EnvQueryTest_Pathfinding { 
	ScanRangeMultiplier: AIDataProviderFloatValue;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryTest_PathfindingBatch;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryTest_PathfindingBatch;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_PathfindingBatch;
	static C(Other: UObject): EnvQueryTest_PathfindingBatch;
}

declare class EnvQueryTest_Random extends EnvQueryTest { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryTest_Random;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryTest_Random;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Random;
	static C(Other: UObject): EnvQueryTest_Random;
}

declare class EnvQueryTest_Trace extends EnvQueryTest { 
	TraceData: EnvTraceData;
	TraceFromContext: AIDataProviderBoolValue;
	ItemHeightOffset: AIDataProviderFloatValue;
	ContextHeightOffset: AIDataProviderFloatValue;
	Context: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnvQueryTest_Trace;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnvQueryTest_Trace;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Trace;
	static C(Other: UObject): EnvQueryTest_Trace;
}

declare class EQSRenderingComponent extends PrimitiveComponent { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EQSRenderingComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EQSRenderingComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EQSRenderingComponent;
	static C(Other: UObject): EQSRenderingComponent;
}

declare type EEnvQueryHightlightMode = string;
declare class EQSTestingPawn extends Character { 
	QueryTemplate: EnvQuery;
	QueryParams: EnvNamedValue[];
	TimeLimitPerStep: number;
	StepToDebugDraw: number;
	HighlightMode: EEnvQueryHightlightMode;
	bDrawLabels: boolean;
	bDrawFailedItems: boolean;
	bReRunQueryOnlyOnFinishedMove: boolean;
	bShouldBeVisibleInGame: boolean;
	QueryingMode: EEnvQueryRunMode;
	EdRenderComp: EQSRenderingComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EQSTestingPawn;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EQSTestingPawn;
	static C(Other: UObject): EQSTestingPawn;
}

declare class CrowdFollowingComponent extends PathFollowingComponent { 
	CrowdAgentMoveDirection: Vector;
	CharacterMovement: CharacterMovementComponent;
	AvoidanceGroup: NavAvoidanceMask;
	GroupsToAvoid: NavAvoidanceMask;
	GroupsToIgnore: NavAvoidanceMask;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CrowdFollowingComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CrowdFollowingComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CrowdFollowingComponent;
	static C(Other: UObject): CrowdFollowingComponent;
	SuspendCrowdSteering(bSuspend: boolean): void;
}

declare class PawnAction_BlueprintBase extends PawnAction { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PawnAction_BlueprintBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PawnAction_BlueprintBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_BlueprintBase;
	static C(Other: UObject): PawnAction_BlueprintBase;
	ActionTick(ControlledPawn: Pawn,DeltaSeconds: number): void;
	ActionStart(ControlledPawn: Pawn): void;
	ActionResume(ControlledPawn: Pawn): void;
	ActionPause(ControlledPawn: Pawn): void;
	ActionFinished(ControlledPawn: Pawn,WithResult: EPawnActionResult): void;
}

declare class PawnAction_Move extends PawnAction { 
	GoalActor: Actor;
	GoalLocation: Vector;
	AcceptableRadius: number;
	FilterClass: UnrealEngineClass;
	bAllowStrafe: boolean;
	bFinishOnOverlap: boolean;
	bUsePathfinding: boolean;
	bAllowPartialPath: boolean;
	bProjectGoalToNavigation: boolean;
	bUpdatePathToGoal: boolean;
	bAbortChildActionOnPathChange: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PawnAction_Move;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PawnAction_Move;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_Move;
	static C(Other: UObject): PawnAction_Move;
}

declare type EPawnActionFailHandling = string;
declare class PawnAction_Repeat extends PawnAction { 
	ActionToRepeat: PawnAction;
	RecentActionCopy: PawnAction;
	ChildFailureHandlingMode: EPawnActionFailHandling;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PawnAction_Repeat;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PawnAction_Repeat;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_Repeat;
	static C(Other: UObject): PawnAction_Repeat;
}

declare class PawnAction_Sequence extends PawnAction { 
	ActionSequence: PawnAction[];
	ChildFailureHandlingMode: EPawnActionFailHandling;
	RecentActionCopy: PawnAction;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PawnAction_Sequence;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PawnAction_Sequence;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_Sequence;
	static C(Other: UObject): PawnAction_Sequence;
}

declare class PawnAction_Wait extends PawnAction { 
	TimeToWait: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PawnAction_Wait;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PawnAction_Wait;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_Wait;
	static C(Other: UObject): PawnAction_Wait;
}

declare class PawnSensingComponent extends ActorComponent { 
	HearingThreshold: number;
	LOSHearingThreshold: number;
	SightRadius: number;
	SensingInterval: number;
	HearingMaxSoundAge: number;
	bEnableSensingUpdates: boolean;
	bOnlySensePlayers: boolean;
	bSeePawns: boolean;
	bHearNoises: boolean;
	OnSeePawn: UnrealEngineMulticastDelegate<(Pawn: Pawn) => void>;
	OnHearNoise: UnrealEngineMulticastDelegate<(Instigator: Pawn, Location: Vector, Volume: number) => void>;
	PeripheralVisionAngle: number;
	PeripheralVisionCosine: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PawnSensingComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PawnSensingComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnSensingComponent;
	static C(Other: UObject): PawnSensingComponent;
	SetSensingUpdatesEnabled(bEnabled: boolean): void;
	SetSensingInterval(NewSensingInterval: number): void;
	SetPeripheralVisionAngle(NewPeripheralVisionAngle: number): void;
	GetPeripheralVisionCosine(): number;
	GetPeripheralVisionAngle(): number;
}

declare class FavoritedBlueprintPaletteItem { 
}

declare class BlueprintPaletteFavorites extends UObject { 
	CustomFavorites: string[];
	CurrentFavorites: FavoritedBlueprintPaletteItem[];
	CurrentProfile: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintPaletteFavorites;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintPaletteFavorites;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintPaletteFavorites;
	static C(Other: UObject): BlueprintPaletteFavorites;
}

declare class K2Node extends EdGraphNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node;
	static C(Other: UObject): K2Node;
}

declare class K2Node_BaseAsyncTask extends K2Node { 
	ProxyFactoryFunctionName: string;
	ProxyFactoryClass: UnrealEngineClass;
	ProxyClass: UnrealEngineClass;
	ProxyActivateFunctionName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_BaseAsyncTask;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_BaseAsyncTask;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_BaseAsyncTask;
	static C(Other: UObject): K2Node_BaseAsyncTask;
}

declare class K2Node_AsyncAction extends K2Node_BaseAsyncTask { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_AsyncAction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_AsyncAction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AsyncAction;
	static C(Other: UObject): K2Node_AsyncAction;
}

declare type ESaveOnCompile = string;
declare class BlueprintEditorSettings extends UObject { 
	bDrawMidpointArrowsInBlueprints: boolean;
	bShowGraphInstructionText: boolean;
	bSplitContextTargetSettings: boolean;
	bExposeAllMemberComponentFunctions: boolean;
	bShowContextualFavorites: boolean;
	bCompactCallOnMemberNodes: boolean;
	bFlattenFavoritesMenus: boolean;
	bFavorPureCastNodes: boolean;
	bAutoCastObjectConnections: boolean;
	bShowViewportOnSimulate: boolean;
	bShowInheritedVariables: boolean;
	bShowEmptySections: boolean;
	bSpawnDefaultBlueprintNodes: boolean;
	bHideConstructionScriptComponentsInDetailsView: boolean;
	SaveOnCompile: ESaveOnCompile;
	bJumpToNodeErrors: boolean;
	bShowActionMenuItemSignatures: boolean;
	bShowDetailedCompileResults: boolean;
	CompileEventDisplayThresholdMs: number;
	NodeTemplateCacheCapMB: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintEditorSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintEditorSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintEditorSettings;
	static C(Other: UObject): BlueprintEditorSettings;
}

declare class BlueprintNodeSpawner extends UObject { 
	NodeClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintNodeSpawner;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintNodeSpawner;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintNodeSpawner;
	static C(Other: UObject): BlueprintNodeSpawner;
}

declare class BlueprintBoundNodeSpawner extends BlueprintNodeSpawner { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintBoundNodeSpawner;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintBoundNodeSpawner;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintBoundNodeSpawner;
	static C(Other: UObject): BlueprintBoundNodeSpawner;
}

declare class BlueprintComponentNodeSpawner extends BlueprintNodeSpawner { 
	ComponentClass: UnrealEngineClass;
	ComponentName: string;
	ComponentAssetName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintComponentNodeSpawner;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintComponentNodeSpawner;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintComponentNodeSpawner;
	static C(Other: UObject): BlueprintComponentNodeSpawner;
}

declare class BlueprintEventNodeSpawner extends BlueprintNodeSpawner { 
	EventFunc: UFunction;
	CustomEventName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintEventNodeSpawner;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintEventNodeSpawner;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintEventNodeSpawner;
	static C(Other: UObject): BlueprintEventNodeSpawner;
}

declare class BlueprintBoundEventNodeSpawner extends BlueprintEventNodeSpawner { 
	EventDelegate: MulticastDelegateProperty;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintBoundEventNodeSpawner;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintBoundEventNodeSpawner;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintBoundEventNodeSpawner;
	static C(Other: UObject): BlueprintBoundEventNodeSpawner;
}

declare class BlueprintFieldNodeSpawner extends BlueprintNodeSpawner { 
	Field: Field;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintFieldNodeSpawner;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintFieldNodeSpawner;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintFieldNodeSpawner;
	static C(Other: UObject): BlueprintFieldNodeSpawner;
}

declare class BlueprintDelegateNodeSpawner extends BlueprintFieldNodeSpawner { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintDelegateNodeSpawner;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintDelegateNodeSpawner;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintDelegateNodeSpawner;
	static C(Other: UObject): BlueprintDelegateNodeSpawner;
}

declare class BlueprintFunctionNodeSpawner extends BlueprintFieldNodeSpawner { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintFunctionNodeSpawner;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintFunctionNodeSpawner;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintFunctionNodeSpawner;
	static C(Other: UObject): BlueprintFunctionNodeSpawner;
}

declare class BlueprintVariableNodeSpawner extends BlueprintFieldNodeSpawner { 
	LocalVarOuter: EdGraph;
	LocalVarDesc: BPVariableDescription;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintVariableNodeSpawner;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintVariableNodeSpawner;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintVariableNodeSpawner;
	static C(Other: UObject): BlueprintVariableNodeSpawner;
}

declare class BlueprintCallableFunctionRedirect { 
	ClassName: string;
	OldFunctionName: string;
	NewFunctionName: string;
	BlueprintParamName: string;
	ClassParamName: string;
}

declare class EdGraphSchema_K2 extends EdGraphSchema { 
	EditoronlyBPFunctionRedirects: BlueprintCallableFunctionRedirect[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EdGraphSchema_K2;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EdGraphSchema_K2;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphSchema_K2;
	static C(Other: UObject): EdGraphSchema_K2;
}

declare class K2Node_AssignmentStatement extends K2Node { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_AssignmentStatement;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_AssignmentStatement;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AssignmentStatement;
	static C(Other: UObject): K2Node_AssignmentStatement;
}

declare class K2Node_AIMoveTo extends K2Node_BaseAsyncTask { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_AIMoveTo;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_AIMoveTo;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AIMoveTo;
	static C(Other: UObject): K2Node_AIMoveTo;
}

declare class MemberReference { 
	MemberParent: UObject;
	MemberScope: string;
	MemberName: string;
	MemberGuid: Guid;
	bSelfContext: boolean;
	bWasDeprecated: boolean;
}

declare class K2Node_BaseMCDelegate extends K2Node { 
	DelegateReference: MemberReference;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_BaseMCDelegate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_BaseMCDelegate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_BaseMCDelegate;
	static C(Other: UObject): K2Node_BaseMCDelegate;
}

declare class K2Node_AddDelegate extends K2Node_BaseMCDelegate { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_AddDelegate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_AddDelegate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AddDelegate;
	static C(Other: UObject): K2Node_AddDelegate;
}

declare class K2Node_AssignDelegate extends K2Node_AddDelegate { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_AssignDelegate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_AssignDelegate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AssignDelegate;
	static C(Other: UObject): K2Node_AssignDelegate;
}

declare class K2Node_CallDelegate extends K2Node_BaseMCDelegate { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_CallDelegate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_CallDelegate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallDelegate;
	static C(Other: UObject): K2Node_CallDelegate;
}

declare class K2Node_ClearDelegate extends K2Node_BaseMCDelegate { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_ClearDelegate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_ClearDelegate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ClearDelegate;
	static C(Other: UObject): K2Node_ClearDelegate;
}

declare class K2Node_RemoveDelegate extends K2Node_BaseMCDelegate { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_RemoveDelegate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_RemoveDelegate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_RemoveDelegate;
	static C(Other: UObject): K2Node_RemoveDelegate;
}

declare class K2Node_CallFunction extends K2Node { 
	bIsPureFunc: boolean;
	bIsConstFunc: boolean;
	bWantsEnumToExecExpansion: boolean;
	bIsInterfaceCall: boolean;
	bIsFinalFunction: boolean;
	bIsBeadFunction: boolean;
	FunctionReference: MemberReference;
	CallFunctionName: string;
	CallFunctionClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_CallFunction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_CallFunction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallFunction;
	static C(Other: UObject): K2Node_CallFunction;
}

declare class K2Node_AddComponent extends K2Node_CallFunction { 
	bHasExposedVariable: boolean;
	TemplateBlueprint: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_AddComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_AddComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AddComponent;
	static C(Other: UObject): K2Node_AddComponent;
}

declare class K2Node_CallArrayFunction extends K2Node_CallFunction { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_CallArrayFunction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_CallArrayFunction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallArrayFunction;
	static C(Other: UObject): K2Node_CallArrayFunction;
}

declare class K2Node_CallDataTableFunction extends K2Node_CallFunction { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_CallDataTableFunction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_CallDataTableFunction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallDataTableFunction;
	static C(Other: UObject): K2Node_CallDataTableFunction;
}

declare class K2Node_CallFunctionOnMember extends K2Node_CallFunction { 
	MemberVariableToCallOn: MemberReference;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_CallFunctionOnMember;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_CallFunctionOnMember;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallFunctionOnMember;
	static C(Other: UObject): K2Node_CallFunctionOnMember;
}

declare class K2Node_CallMaterialParameterCollectionFunction extends K2Node_CallFunction { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_CallMaterialParameterCollectionFunction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_CallMaterialParameterCollectionFunction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallMaterialParameterCollectionFunction;
	static C(Other: UObject): K2Node_CallMaterialParameterCollectionFunction;
}

declare class K2Node_CallParentFunction extends K2Node_CallFunction { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_CallParentFunction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_CallParentFunction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallParentFunction;
	static C(Other: UObject): K2Node_CallParentFunction;
}

declare class K2Node_CommutativeAssociativeBinaryOperator extends K2Node_CallFunction { 
	NumAdditionalInputs: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_CommutativeAssociativeBinaryOperator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_CommutativeAssociativeBinaryOperator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CommutativeAssociativeBinaryOperator;
	static C(Other: UObject): K2Node_CommutativeAssociativeBinaryOperator;
}

declare class K2Node_GetInputAxisKeyValue extends K2Node_CallFunction { 
	InputAxisKey: Key;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_GetInputAxisKeyValue;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_GetInputAxisKeyValue;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetInputAxisKeyValue;
	static C(Other: UObject): K2Node_GetInputAxisKeyValue;
}

declare class K2Node_GetInputVectorAxisValue extends K2Node_GetInputAxisKeyValue { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_GetInputVectorAxisValue;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_GetInputVectorAxisValue;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetInputVectorAxisValue;
	static C(Other: UObject): K2Node_GetInputVectorAxisValue;
}

declare class K2Node_GetInputAxisValue extends K2Node_CallFunction { 
	InputAxisName: string;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_GetInputAxisValue;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_GetInputAxisValue;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetInputAxisValue;
	static C(Other: UObject): K2Node_GetInputAxisValue;
}

declare class K2Node_Message extends K2Node_CallFunction { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_Message;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_Message;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Message;
	static C(Other: UObject): K2Node_Message;
}

declare class K2Node_CastByteToEnum extends K2Node { 
	Enum: Enum;
	bSafe: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_CastByteToEnum;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_CastByteToEnum;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CastByteToEnum;
	static C(Other: UObject): K2Node_CastByteToEnum;
}

declare class K2Node_ConstructObjectFromClass extends K2Node { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_ConstructObjectFromClass;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_ConstructObjectFromClass;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ConstructObjectFromClass;
	static C(Other: UObject): K2Node_ConstructObjectFromClass;
}

declare class K2Node_GenericCreateObject extends K2Node_ConstructObjectFromClass { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_GenericCreateObject;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_GenericCreateObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GenericCreateObject;
	static C(Other: UObject): K2Node_GenericCreateObject;
}

declare class K2Node_ConvertAsset extends K2Node { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_ConvertAsset;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_ConvertAsset;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ConvertAsset;
	static C(Other: UObject): K2Node_ConvertAsset;
}

declare class K2Node_CreateDelegate extends K2Node { 
	SelectedFunctionName: string;
	SelectedFunctionGuid: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_CreateDelegate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_CreateDelegate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CreateDelegate;
	static C(Other: UObject): K2Node_CreateDelegate;
}

declare class K2Node_DeadClass extends K2Node { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_DeadClass;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_DeadClass;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_DeadClass;
	static C(Other: UObject): K2Node_DeadClass;
}

declare class K2Node_DelegateSet extends K2Node { 
	DelegatePropertyName: string;
	DelegatePropertyClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_DelegateSet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_DelegateSet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_DelegateSet;
	static C(Other: UObject): K2Node_DelegateSet;
}

declare class K2Node_TemporaryVariable extends K2Node { 
	VariableType: EdGraphPinType;
	bIsPersistent: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_TemporaryVariable;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_TemporaryVariable;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_TemporaryVariable;
	static C(Other: UObject): K2Node_TemporaryVariable;
}

declare class K2Node_DoOnceMultiInput extends K2Node { 
	NumAdditionalInputs: number;
	DataNode: K2Node_TemporaryVariable;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_DoOnceMultiInput;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_DoOnceMultiInput;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_DoOnceMultiInput;
	static C(Other: UObject): K2Node_DoOnceMultiInput;
}

declare class K2Node_DynamicCast extends K2Node { 
	TargetType: UnrealEngineClass;
	bIsPureCast: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_DynamicCast;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_DynamicCast;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_DynamicCast;
	static C(Other: UObject): K2Node_DynamicCast;
}

declare class K2Node_ClassDynamicCast extends K2Node_DynamicCast { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_ClassDynamicCast;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_ClassDynamicCast;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ClassDynamicCast;
	static C(Other: UObject): K2Node_ClassDynamicCast;
}

declare class K2Node_EaseFunction extends K2Node { 
	EaseFunctionName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_EaseFunction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_EaseFunction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EaseFunction;
	static C(Other: UObject): K2Node_EaseFunction;
}

declare class K2Node_EditablePinBase extends K2Node { 
	bIsEditable: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_EditablePinBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_EditablePinBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EditablePinBase;
	static C(Other: UObject): K2Node_EditablePinBase;
}

declare class K2Node_Event extends K2Node_EditablePinBase { 
	EventSignatureName: string;
	EventSignatureClass: UnrealEngineClass;
	EventReference: MemberReference;
	bOverrideFunction: boolean;
	bInternalEvent: boolean;
	CustomFunctionName: string;
	FunctionFlags: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_Event;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_Event;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Event;
	static C(Other: UObject): K2Node_Event;
}

declare class K2Node_ActorBoundEvent extends K2Node_Event { 
	DelegatePropertyName: string;
	DelegateOwnerClass: UnrealEngineClass;
	EventOwner: Actor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_ActorBoundEvent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_ActorBoundEvent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ActorBoundEvent;
	static C(Other: UObject): K2Node_ActorBoundEvent;
}

declare class K2Node_ComponentBoundEvent extends K2Node_Event { 
	DelegatePropertyName: string;
	DelegateOwnerClass: UnrealEngineClass;
	ComponentPropertyName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_ComponentBoundEvent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_ComponentBoundEvent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ComponentBoundEvent;
	static C(Other: UObject): K2Node_ComponentBoundEvent;
}

declare class K2Node_CustomEvent extends K2Node_Event { 
	bCallInEditor: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_CustomEvent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_CustomEvent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CustomEvent;
	static C(Other: UObject): K2Node_CustomEvent;
}

declare type EInputEvent = string;
declare class K2Node_InputActionEvent extends K2Node_Event { 
	InputActionName: string;
	InputKeyEvent: EInputEvent;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_InputActionEvent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_InputActionEvent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputActionEvent;
	static C(Other: UObject): K2Node_InputActionEvent;
}

declare class K2Node_InputAxisEvent extends K2Node_Event { 
	InputAxisName: string;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_InputAxisEvent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_InputAxisEvent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputAxisEvent;
	static C(Other: UObject): K2Node_InputAxisEvent;
}

declare class K2Node_InputAxisKeyEvent extends K2Node_Event { 
	AxisKey: Key;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_InputAxisKeyEvent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_InputAxisKeyEvent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputAxisKeyEvent;
	static C(Other: UObject): K2Node_InputAxisKeyEvent;
}

declare class K2Node_InputVectorAxisEvent extends K2Node_InputAxisKeyEvent { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_InputVectorAxisEvent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_InputVectorAxisEvent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputVectorAxisEvent;
	static C(Other: UObject): K2Node_InputVectorAxisEvent;
}

declare class InputChord { 
	Key: Key;
	bShift: boolean;
	bCtrl: boolean;
	bAlt: boolean;
	bCmd: boolean;
}

declare class K2Node_InputKeyEvent extends K2Node_Event { 
	InputChord: InputChord;
	InputKeyEvent: EInputEvent;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_InputKeyEvent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_InputKeyEvent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputKeyEvent;
	static C(Other: UObject): K2Node_InputKeyEvent;
}

declare class K2Node_InputTouchEvent extends K2Node_Event { 
	InputKeyEvent: EInputEvent;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_InputTouchEvent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_InputTouchEvent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputTouchEvent;
	static C(Other: UObject): K2Node_InputTouchEvent;
}

declare class K2Node_FunctionTerminator extends K2Node_EditablePinBase { 
	SignatureClass: UnrealEngineClass;
	SignatureName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_FunctionTerminator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_FunctionTerminator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_FunctionTerminator;
	static C(Other: UObject): K2Node_FunctionTerminator;
}

declare class KismetUserDeclaredFunctionMetadata { 
	ToolTip: string;
	Category: string;
	Keywords: string;
	CompactNodeTitle: string;
	InstanceTitleColor: LinearColor;
	bCallInEditor: boolean;
	HasLatentFunctions: any;
}

declare class K2Node_FunctionEntry extends K2Node_FunctionTerminator { 
	CustomGeneratedFunctionName: string;
	ExtraFlags: number;
	MetaData: KismetUserDeclaredFunctionMetadata;
	LocalVariables: BPVariableDescription[];
	bEnforceConstCorrectness: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_FunctionEntry;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_FunctionEntry;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_FunctionEntry;
	static C(Other: UObject): K2Node_FunctionEntry;
}

declare class K2Node_FunctionResult extends K2Node_FunctionTerminator { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_FunctionResult;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_FunctionResult;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_FunctionResult;
	static C(Other: UObject): K2Node_FunctionResult;
}

declare class K2Node_Tunnel extends K2Node_EditablePinBase { 
	OutputSourceNode: K2Node_Tunnel;
	InputSinkNode: K2Node_Tunnel;
	bCanHaveInputs: boolean;
	bCanHaveOutputs: boolean;
	MetaData: KismetUserDeclaredFunctionMetadata;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_Tunnel;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_Tunnel;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Tunnel;
	static C(Other: UObject): K2Node_Tunnel;
}

declare class K2Node_Composite extends K2Node_Tunnel { 
	BoundGraph: EdGraph;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_Composite;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_Composite;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Composite;
	static C(Other: UObject): K2Node_Composite;
}

declare class K2Node_MathExpression extends K2Node_Composite { 
	Expression: string;
	bMadeAfterRotChange: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_MathExpression;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_MathExpression;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MathExpression;
	static C(Other: UObject): K2Node_MathExpression;
}

declare class GraphReference { 
	MacroGraph: EdGraph;
	GraphBlueprint: Blueprint;
	GraphGuid: Guid;
}

declare class K2Node_MacroInstance extends K2Node_Tunnel { 
	MacroGraph: EdGraph;
	MacroGraphReference: GraphReference;
	ResolvedWildcardType: EdGraphPinType;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_MacroInstance;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_MacroInstance;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MacroInstance;
	static C(Other: UObject): K2Node_MacroInstance;
}

declare class K2Node_EnumEquality extends K2Node { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_EnumEquality;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_EnumEquality;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EnumEquality;
	static C(Other: UObject): K2Node_EnumEquality;
}

declare class K2Node_EnumInequality extends K2Node_EnumEquality { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_EnumInequality;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_EnumInequality;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EnumInequality;
	static C(Other: UObject): K2Node_EnumInequality;
}

declare class NodeDependingOnEnumInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NodeDependingOnEnumInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NodeDependingOnEnumInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NodeDependingOnEnumInterface;
	static C(Other: UObject): NodeDependingOnEnumInterface;
}

declare class K2Node_EnumLiteral extends K2Node { 
	Enum: Enum;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_EnumLiteral;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_EnumLiteral;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EnumLiteral;
	static C(Other: UObject): K2Node_EnumLiteral;
}

declare class K2Node_ExecutionSequence extends K2Node { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_ExecutionSequence;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_ExecutionSequence;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ExecutionSequence;
	static C(Other: UObject): K2Node_ExecutionSequence;
}

declare class K2Node_MultiGate extends K2Node_ExecutionSequence { 
	DataNode: K2Node_TemporaryVariable;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_MultiGate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_MultiGate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MultiGate;
	static C(Other: UObject): K2Node_MultiGate;
}

declare class K2Node_ForEachElementInEnum extends K2Node { 
	Enum: Enum;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_ForEachElementInEnum;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_ForEachElementInEnum;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ForEachElementInEnum;
	static C(Other: UObject): K2Node_ForEachElementInEnum;
}

declare class K2Node_FormatText extends K2Node { 
	PinNames: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_FormatText;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_FormatText;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_FormatText;
	static C(Other: UObject): K2Node_FormatText;
}

declare class OptionalPinFromProperty { 
	PropertyName: string;
	PropertyFriendlyName: string;
	PropertyTooltip: string;
	bShowPin: boolean;
	bCanToggleVisibility: boolean;
	bPropertyIsCustomized: boolean;
	CategoryName: string;
}

declare class K2Node_GetClassDefaults extends K2Node { 
	ShowPinForProperties: OptionalPinFromProperty[];
	bExcludeObjectArrays: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_GetClassDefaults;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_GetClassDefaults;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetClassDefaults;
	static C(Other: UObject): K2Node_GetClassDefaults;
}

declare class K2Node_GetDataTableRow extends K2Node { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_GetDataTableRow;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_GetDataTableRow;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetDataTableRow;
	static C(Other: UObject): K2Node_GetDataTableRow;
}

declare class K2Node_GetEnumeratorName extends K2Node { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_GetEnumeratorName;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_GetEnumeratorName;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetEnumeratorName;
	static C(Other: UObject): K2Node_GetEnumeratorName;
}

declare class K2Node_GetEnumeratorNameAsString extends K2Node_GetEnumeratorName { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_GetEnumeratorNameAsString;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_GetEnumeratorNameAsString;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetEnumeratorNameAsString;
	static C(Other: UObject): K2Node_GetEnumeratorNameAsString;
}

declare class K2Node_GetNumEnumEntries extends K2Node { 
	Enum: Enum;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_GetNumEnumEntries;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_GetNumEnumEntries;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetNumEnumEntries;
	static C(Other: UObject): K2Node_GetNumEnumEntries;
}

declare class K2Node_IfThenElse extends K2Node { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_IfThenElse;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_IfThenElse;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_IfThenElse;
	static C(Other: UObject): K2Node_IfThenElse;
}

declare class K2Node_InputAction extends K2Node { 
	InputActionName: string;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_InputAction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_InputAction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputAction;
	static C(Other: UObject): K2Node_InputAction;
}

declare class K2Node_InputKey extends K2Node { 
	InputKey: Key;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	bControl: boolean;
	bAlt: boolean;
	bShift: boolean;
	bCommand: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_InputKey;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_InputKey;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputKey;
	static C(Other: UObject): K2Node_InputKey;
}

declare class K2Node_InputTouch extends K2Node { 
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_InputTouch;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_InputTouch;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputTouch;
	static C(Other: UObject): K2Node_InputTouch;
}

declare class K2Node_Knot extends K2Node { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_Knot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_Knot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Knot;
	static C(Other: UObject): K2Node_Knot;
}

declare class K2Node_Literal extends K2Node { 
	ObjectRef: UObject;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_Literal;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_Literal;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Literal;
	static C(Other: UObject): K2Node_Literal;
}

declare class K2Node_LoadAsset extends K2Node { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_LoadAsset;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_LoadAsset;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LoadAsset;
	static C(Other: UObject): K2Node_LoadAsset;
}

declare class K2Node_LoadAssetClass extends K2Node_LoadAsset { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_LoadAssetClass;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_LoadAssetClass;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LoadAssetClass;
	static C(Other: UObject): K2Node_LoadAssetClass;
}

declare class K2Node_MakeArray extends K2Node { 
	NumInputs: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_MakeArray;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_MakeArray;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeArray;
	static C(Other: UObject): K2Node_MakeArray;
}

declare class K2Node_MatineeController extends K2Node { 
	MatineeActor: MatineeActor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_MatineeController;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_MatineeController;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MatineeController;
	static C(Other: UObject): K2Node_MatineeController;
}

declare class K2Node_PureAssignmentStatement extends K2Node { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_PureAssignmentStatement;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_PureAssignmentStatement;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_PureAssignmentStatement;
	static C(Other: UObject): K2Node_PureAssignmentStatement;
}

declare class K2Node_Select extends K2Node { 
	NumOptionPins: number;
	IndexPinType: EdGraphPinType;
	Enum: Enum;
	EnumEntries: string[];
	EnumEntryFriendlyNames: string[];
	bReconstructNode: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_Select;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_Select;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Select;
	static C(Other: UObject): K2Node_Select;
}

declare class K2Node_Self extends K2Node { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_Self;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_Self;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Self;
	static C(Other: UObject): K2Node_Self;
}

declare class K2Node_SetVariableOnPersistentFrame extends K2Node { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_SetVariableOnPersistentFrame;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_SetVariableOnPersistentFrame;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SetVariableOnPersistentFrame;
	static C(Other: UObject): K2Node_SetVariableOnPersistentFrame;
}

declare class K2Node_SpawnActor extends K2Node { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_SpawnActor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_SpawnActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SpawnActor;
	static C(Other: UObject): K2Node_SpawnActor;
}

declare class K2Node_SpawnActorFromClass extends K2Node { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_SpawnActorFromClass;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_SpawnActorFromClass;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SpawnActorFromClass;
	static C(Other: UObject): K2Node_SpawnActorFromClass;
}

declare class K2Node_Switch extends K2Node { 
	bHasDefaultPin: boolean;
	FunctionName: string;
	FunctionClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_Switch;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_Switch;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Switch;
	static C(Other: UObject): K2Node_Switch;
}

declare class K2Node_SwitchEnum extends K2Node_Switch { 
	Enum: Enum;
	EnumEntries: string[];
	EnumFriendlyNames: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_SwitchEnum;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_SwitchEnum;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SwitchEnum;
	static C(Other: UObject): K2Node_SwitchEnum;
}

declare class K2Node_SwitchInteger extends K2Node_Switch { 
	StartIndex: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_SwitchInteger;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_SwitchInteger;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SwitchInteger;
	static C(Other: UObject): K2Node_SwitchInteger;
}

declare class K2Node_SwitchName extends K2Node_Switch { 
	PinNames: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_SwitchName;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_SwitchName;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SwitchName;
	static C(Other: UObject): K2Node_SwitchName;
}

declare class K2Node_SwitchString extends K2Node_Switch { 
	PinNames: string[];
	bIsCaseSensitive: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_SwitchString;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_SwitchString;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SwitchString;
	static C(Other: UObject): K2Node_SwitchString;
}

declare class K2Node_LocalVariable extends K2Node_TemporaryVariable { 
	CustomVariableName: string;
	VariableTooltip: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_LocalVariable;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_LocalVariable;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LocalVariable;
	static C(Other: UObject): K2Node_LocalVariable;
}

declare class K2Node_Timeline extends K2Node { 
	TimelineName: string;
	bAutoPlay: boolean;
	TimelineGuid: Guid;
	bLoop: boolean;
	bReplicated: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_Timeline;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_Timeline;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Timeline;
	static C(Other: UObject): K2Node_Timeline;
}

declare type ESelfContextInfo = string;
declare class K2Node_Variable extends K2Node { 
	VariableReference: MemberReference;
	SelfContextInfo: ESelfContextInfo;
	VariableSourceClass: UnrealEngineClass;
	VariableName: string;
	bSelfContext: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_Variable;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_Variable;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Variable;
	static C(Other: UObject): K2Node_Variable;
}

declare class K2Node_StructOperation extends K2Node_Variable { 
	StructType: ScriptStruct;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_StructOperation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_StructOperation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_StructOperation;
	static C(Other: UObject): K2Node_StructOperation;
}

declare class K2Node_StructMemberGet extends K2Node_StructOperation { 
	ShowPinForProperties: OptionalPinFromProperty[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_StructMemberGet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_StructMemberGet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_StructMemberGet;
	static C(Other: UObject): K2Node_StructMemberGet;
}

declare class K2Node_BreakStruct extends K2Node_StructMemberGet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_BreakStruct;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_BreakStruct;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_BreakStruct;
	static C(Other: UObject): K2Node_BreakStruct;
}

declare class K2Node_StructMemberSet extends K2Node_StructOperation { 
	ShowPinForProperties: OptionalPinFromProperty[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_StructMemberSet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_StructMemberSet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_StructMemberSet;
	static C(Other: UObject): K2Node_StructMemberSet;
}

declare class K2Node_MakeStruct extends K2Node_StructMemberSet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_MakeStruct;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_MakeStruct;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeStruct;
	static C(Other: UObject): K2Node_MakeStruct;
}

declare class K2Node_SetFieldsInStruct extends K2Node_MakeStruct { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_SetFieldsInStruct;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_SetFieldsInStruct;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SetFieldsInStruct;
	static C(Other: UObject): K2Node_SetFieldsInStruct;
}

declare class K2Node_VariableGet extends K2Node_Variable { 
	bIsPureGet: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_VariableGet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_VariableGet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_VariableGet;
	static C(Other: UObject): K2Node_VariableGet;
}

declare class K2Node_VariableSet extends K2Node_Variable { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_VariableSet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_VariableSet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_VariableSet;
	static C(Other: UObject): K2Node_VariableSet;
}

declare class K2Node_VariableSetRef extends K2Node { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_VariableSetRef;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_VariableSetRef;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_VariableSetRef;
	static C(Other: UObject): K2Node_VariableSetRef;
}

declare type EBlueprintPinStyleType = string;
declare class GraphEditorSettings extends UObject { 
	DataPinStyle: EBlueprintPinStyleType;
	PaddingAbovePin: number;
	PaddingBelowPin: number;
	PaddingRightOfInput: number;
	PaddingLeftOfOutput: number;
	PaddingTowardsNodeEdge: number;
	bTreatSplinesLikePins: boolean;
	SplineHoverTolerance: number;
	ForwardSplineHorizontalDeltaRange: number;
	ForwardSplineVerticalDeltaRange: number;
	ForwardSplineTangentFromHorizontalDelta: Vector2D;
	ForwardSplineTangentFromVerticalDelta: Vector2D;
	BackwardSplineHorizontalDeltaRange: number;
	BackwardSplineVerticalDeltaRange: number;
	BackwardSplineTangentFromHorizontalDelta: Vector2D;
	BackwardSplineTangentFromVerticalDelta: Vector2D;
	DefaultPinTypeColor: LinearColor;
	ExecutionPinTypeColor: LinearColor;
	BooleanPinTypeColor: LinearColor;
	BytePinTypeColor: LinearColor;
	ClassPinTypeColor: LinearColor;
	IntPinTypeColor: LinearColor;
	FloatPinTypeColor: LinearColor;
	NamePinTypeColor: LinearColor;
	AssetPinTypeColor: LinearColor;
	AssetClassPinTypeColor: LinearColor;
	DelegatePinTypeColor: LinearColor;
	ObjectPinTypeColor: LinearColor;
	InterfacePinTypeColor: LinearColor;
	StringPinTypeColor: LinearColor;
	TextPinTypeColor: LinearColor;
	StructPinTypeColor: LinearColor;
	WildcardPinTypeColor: LinearColor;
	VectorPinTypeColor: LinearColor;
	RotatorPinTypeColor: LinearColor;
	TransformPinTypeColor: LinearColor;
	IndexPinTypeColor: LinearColor;
	EventNodeTitleColor: LinearColor;
	FunctionCallNodeTitleColor: LinearColor;
	PureFunctionCallNodeTitleColor: LinearColor;
	ParentFunctionCallNodeTitleColor: LinearColor;
	FunctionTerminatorNodeTitleColor: LinearColor;
	ExecBranchNodeTitleColor: LinearColor;
	ExecSequenceNodeTitleColor: LinearColor;
	ResultNodeTitleColor: LinearColor;
	DefaultCommentNodeTitleColor: LinearColor;
	TraceAttackColor: LinearColor;
	TraceAttackWireThickness: number;
	TraceAttackHoldPeriod: number;
	TraceDecayPeriod: number;
	TraceDecayExponent: number;
	TraceSustainColor: LinearColor;
	TraceSustainWireThickness: number;
	TraceSustainHoldPeriod: number;
	TraceReleaseColor: LinearColor;
	TraceReleaseWireThickness: number;
	TraceReleasePeriod: number;
	TraceReleaseExponent: number;
	TracePositionBonusPeriod: number;
	TracePositionExponent: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GraphEditorSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GraphEditorSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GraphEditorSettings;
	static C(Other: UObject): GraphEditorSettings;
}

declare class AnimationConduitGraphSchema extends EdGraphSchema_K2 { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimationConduitGraphSchema;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimationConduitGraphSchema;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationConduitGraphSchema;
	static C(Other: UObject): AnimationConduitGraphSchema;
}

declare class AnimationGraph extends EdGraph { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimationGraph;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimationGraph;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationGraph;
	static C(Other: UObject): AnimationGraph;
}

declare class AnimGraphNode_Base extends K2Node { 
	ShowPinForProperties: OptionalPinFromProperty[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_Base;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_Base;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_Base;
	static C(Other: UObject): AnimGraphNode_Base;
}

declare class ExposedValueHandler { 
	BoundFunction: string;
}

declare class AnimNode_Base { 
	EvaluateGraphExposedInputs: ExposedValueHandler;
}

declare class PoseLinkBase { 
	LinkID: number;
	SourceLinkID: number;
}

declare class PoseLink extends PoseLinkBase { 
}

declare class AnimNode_Root extends AnimNode_Base { 
	Result: PoseLink;
}

declare class AnimGraphNode_Root extends AnimGraphNode_Base { 
	UNode: AnimNode_Root;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_Root;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_Root;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_Root;
	static C(Other: UObject): AnimGraphNode_Root;
}

declare class AnimGraphNode_CustomTransitionResult extends AnimGraphNode_Root { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_CustomTransitionResult;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_CustomTransitionResult;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_CustomTransitionResult;
	static C(Other: UObject): AnimGraphNode_CustomTransitionResult;
}

declare class AnimationCustomTransitionGraph extends AnimationGraph { 
	MyResultNode: AnimGraphNode_CustomTransitionResult;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimationCustomTransitionGraph;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimationCustomTransitionGraph;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationCustomTransitionGraph;
	static C(Other: UObject): AnimationCustomTransitionGraph;
}

declare class AnimGraphNode_StateResult extends AnimGraphNode_Root { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_StateResult;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_StateResult;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_StateResult;
	static C(Other: UObject): AnimGraphNode_StateResult;
}

declare class AnimationStateGraph extends AnimationGraph { 
	MyResultNode: AnimGraphNode_StateResult;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimationStateGraph;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimationStateGraph;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationStateGraph;
	static C(Other: UObject): AnimationStateGraph;
}

declare class AnimNode_TransitionResult extends AnimNode_Base { 
	bCanEnterTransition: boolean;
}

declare class AnimGraphNode_TransitionResult extends AnimGraphNode_Base { 
	UNode: AnimNode_TransitionResult;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_TransitionResult;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_TransitionResult;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_TransitionResult;
	static C(Other: UObject): AnimGraphNode_TransitionResult;
}

declare class AnimationTransitionGraph extends AnimationGraph { 
	MyResultNode: AnimGraphNode_TransitionResult;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimationTransitionGraph;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimationTransitionGraph;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationTransitionGraph;
	static C(Other: UObject): AnimationTransitionGraph;
}

declare class AnimationGraphSchema extends EdGraphSchema_K2 { 
	PN_SequenceName: string;
	NAME_NeverAsPin: string;
	NAME_PinHiddenByDefault: string;
	NAME_PinShownByDefault: string;
	NAME_AlwaysAsPin: string;
	NAME_CustomizeProperty: string;
	NAME_OnEvaluate: string;
	DefaultEvaluationHandlerName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimationGraphSchema;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimationGraphSchema;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationGraphSchema;
	static C(Other: UObject): AnimationGraphSchema;
}

declare class AnimationCustomTransitionSchema extends AnimationGraphSchema { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimationCustomTransitionSchema;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimationCustomTransitionSchema;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationCustomTransitionSchema;
	static C(Other: UObject): AnimationCustomTransitionSchema;
}

declare class AnimationStateGraphSchema extends AnimationGraphSchema { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimationStateGraphSchema;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimationStateGraphSchema;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationStateGraphSchema;
	static C(Other: UObject): AnimationStateGraphSchema;
}

declare class AnimStateEntryNode extends EdGraphNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimStateEntryNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimStateEntryNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimStateEntryNode;
	static C(Other: UObject): AnimStateEntryNode;
}

declare class AnimGraphNode_StateMachineBase extends AnimGraphNode_Base { 
	EditorStateMachineGraph: AnimationStateMachineGraph;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_StateMachineBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_StateMachineBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_StateMachineBase;
	static C(Other: UObject): AnimGraphNode_StateMachineBase;
}

declare class AnimationStateMachineGraph extends EdGraph { 
	EntryNode: AnimStateEntryNode;
	OwnerAnimGraphNode: AnimGraphNode_StateMachineBase;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimationStateMachineGraph;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimationStateMachineGraph;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationStateMachineGraph;
	static C(Other: UObject): AnimationStateMachineGraph;
}

declare class AnimationStateMachineSchema extends EdGraphSchema { 
	PC_Exec: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimationStateMachineSchema;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimationStateMachineSchema;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationStateMachineSchema;
	static C(Other: UObject): AnimationStateMachineSchema;
}

declare class AnimationTransitionSchema extends EdGraphSchema_K2 { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimationTransitionSchema;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimationTransitionSchema;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationTransitionSchema;
	static C(Other: UObject): AnimationTransitionSchema;
}

declare class InputScaleBias { 
	Scale: number;
	Bias: number;
}

declare class AnimNode_ApplyAdditive extends AnimNode_Base { 
	Base: PoseLink;
	Additive: PoseLink;
	Alpha: number;
	AlphaScaleBias: InputScaleBias;
}

declare class AnimGraphNode_ApplyAdditive extends AnimGraphNode_Base { 
	UNode: AnimNode_ApplyAdditive;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_ApplyAdditive;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_ApplyAdditive;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ApplyAdditive;
	static C(Other: UObject): AnimGraphNode_ApplyAdditive;
}

declare class AnimGraphNode_AssetPlayerBase extends AnimGraphNode_Base { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_AssetPlayerBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_AssetPlayerBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_AssetPlayerBase;
	static C(Other: UObject): AnimGraphNode_AssetPlayerBase;
}

declare class AnimGraphNode_BlendSpaceBase extends AnimGraphNode_AssetPlayerBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_BlendSpaceBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_BlendSpaceBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendSpaceBase;
	static C(Other: UObject): AnimGraphNode_BlendSpaceBase;
}

declare class AnimNode_AssetPlayerBase extends AnimNode_Base { 
	bIgnoreForRelevancyTest: boolean;
	BlendWeight: number;
	InternalTimeAccumulator: number;
}

declare class BlendParameter { 
	DisplayName: string;
	Min: number;
	Max: number;
	GridNum: number;
}

declare type EFilterInterpolationType = string;
declare class InterpolationParameter { 
	InterpolationTime: number;
	InterpolationType: EFilterInterpolationType;
}

declare type ENotifyTriggerMode = string;
declare class PerBoneInterpolation { 
	BoneReference: BoneReference;
	InterpolationSpeedPerSec: number;
}

declare class BlendSample { 
	Animation: AnimSequence;
	SampleValue: Vector;
}

declare class EditorElement { 
	Indices: number;
	Weights: number;
}

declare class BlendSpaceBase extends AnimationAsset { 
	BlendParameters: BlendParameter;
	InterpolationParam: InterpolationParameter;
	TargetWeightInterpolationSpeedPerSec: number;
	NotifyTriggerMode: ENotifyTriggerMode;
	bRotationBlendInMeshSpace: boolean;
	NumOfDimension: number;
	PreviewBasePose: AnimSequence;
	AnimLength: number;
	PerBoneBlend: PerBoneInterpolation[];
	SampleData: BlendSample[];
	GridSamples: EditorElement[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlendSpaceBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlendSpaceBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlendSpaceBase;
	static C(Other: UObject): BlendSpaceBase;
}

declare type EAnimGroupRole = string;
declare class BlendFilter { 
}

declare class BlendSampleData { 
	SampleDataIndex: number;
	TotalWeight: number;
	Time: number;
}

declare class AnimNode_BlendSpacePlayer extends AnimNode_AssetPlayerBase { 
	X: number;
	Y: number;
	Z: number;
	PlayRate: number;
	bLoop: boolean;
	BlendSpace: BlendSpaceBase;
	GroupIndex: number;
	GroupRole: EAnimGroupRole;
	BlendFilter: BlendFilter;
	BlendSampleDataCache: BlendSampleData[];
}

declare class AnimNode_BlendSpaceEvaluator extends AnimNode_BlendSpacePlayer { 
	NormalizedTime: number;
}

declare class AnimationGroupReference { 
	GroupName: string;
	GroupRole: EAnimGroupRole;
}

declare class AnimGraphNode_BlendSpaceEvaluator extends AnimGraphNode_BlendSpaceBase { 
	UNode: AnimNode_BlendSpaceEvaluator;
	SyncGroup: AnimationGroupReference;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_BlendSpaceEvaluator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_BlendSpaceEvaluator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendSpaceEvaluator;
	static C(Other: UObject): AnimGraphNode_BlendSpaceEvaluator;
}

declare class AnimGraphNode_BlendSpacePlayer extends AnimGraphNode_BlendSpaceBase { 
	UNode: AnimNode_BlendSpacePlayer;
	SyncGroup: AnimationGroupReference;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_BlendSpacePlayer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_BlendSpacePlayer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendSpacePlayer;
	static C(Other: UObject): AnimGraphNode_BlendSpacePlayer;
}

declare class AnimNode_RotationOffsetBlendSpace extends AnimNode_BlendSpacePlayer { 
	BasePose: PoseLink;
}

declare class AnimGraphNode_RotationOffsetBlendSpace extends AnimGraphNode_BlendSpaceBase { 
	UNode: AnimNode_RotationOffsetBlendSpace;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_RotationOffsetBlendSpace;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_RotationOffsetBlendSpace;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_RotationOffsetBlendSpace;
	static C(Other: UObject): AnimGraphNode_RotationOffsetBlendSpace;
}

declare class AnimNode_SequenceEvaluator extends AnimNode_AssetPlayerBase { 
	Sequence: AnimSequenceBase;
	ExplicitTime: number;
}

declare class AnimGraphNode_SequenceEvaluator extends AnimGraphNode_AssetPlayerBase { 
	UNode: AnimNode_SequenceEvaluator;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_SequenceEvaluator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_SequenceEvaluator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_SequenceEvaluator;
	static C(Other: UObject): AnimGraphNode_SequenceEvaluator;
}

declare class AnimNode_SequencePlayer extends AnimNode_AssetPlayerBase { 
	Sequence: AnimSequenceBase;
	bLoopAnimation: boolean;
	PlayRate: number;
	GroupIndex: number;
	GroupRole: EAnimGroupRole;
}

declare class AnimGraphNode_SequencePlayer extends AnimGraphNode_AssetPlayerBase { 
	UNode: AnimNode_SequencePlayer;
	SyncGroup: AnimationGroupReference;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_SequencePlayer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_SequencePlayer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_SequencePlayer;
	static C(Other: UObject): AnimGraphNode_SequencePlayer;
}

declare class AnimGraphNode_BlendListBase extends AnimGraphNode_Base { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_BlendListBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_BlendListBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendListBase;
	static C(Other: UObject): AnimGraphNode_BlendListBase;
}

declare type EAlphaBlendOption = string;
declare class AlphaBlend { 
	BlendOption: EAlphaBlendOption;
	BeginValue: number;
	DesiredValue: number;
	BlendTime: number;
	CustomCurve: CurveFloat;
	AlphaLerp: number;
	AlphaBlend: number;
	AlphaTarget: number;
	BlendTimeRemaining: number;
	BlendedValue: number;
}

declare class AnimNode_BlendListBase extends AnimNode_Base { 
	BlendPose: PoseLink[];
	BlendTime: number[];
	BlendType: EAlphaBlendOption;
	CustomBlendCurve: CurveFloat;
	Blends: AlphaBlend[];
	BlendWeights: number[];
	RemainingBlendTimes: number[];
	LastActiveChildIndex: number;
}

declare class AnimNode_BlendListByBool extends AnimNode_BlendListBase { 
	bActiveValue: boolean;
}

declare class AnimGraphNode_BlendListByBool extends AnimGraphNode_BlendListBase { 
	UNode: AnimNode_BlendListByBool;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_BlendListByBool;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_BlendListByBool;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendListByBool;
	static C(Other: UObject): AnimGraphNode_BlendListByBool;
}

declare class AnimNode_BlendListByEnum extends AnimNode_BlendListBase { 
	EnumToPoseIndex: number[];
	ActiveEnumValue: number;
}

declare class AnimGraphNode_BlendListByEnum extends AnimGraphNode_BlendListBase { 
	UNode: AnimNode_BlendListByEnum;
	BoundEnum: Enum;
	VisibleEnumEntries: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_BlendListByEnum;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_BlendListByEnum;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendListByEnum;
	static C(Other: UObject): AnimGraphNode_BlendListByEnum;
}

declare class AnimNode_BlendListByInt extends AnimNode_BlendListBase { 
	ActiveChildIndex: number;
}

declare class AnimGraphNode_BlendListByInt extends AnimGraphNode_BlendListBase { 
	UNode: AnimNode_BlendListByInt;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_BlendListByInt;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_BlendListByInt;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendListByInt;
	static C(Other: UObject): AnimGraphNode_BlendListByInt;
}

declare class BranchFilter { 
	BoneName: string;
	BlendDepth: number;
}

declare class InputBlendPose { 
	BranchFilters: BranchFilter[];
}

declare type ECurveBlendOption = string;
declare class AnimNode_LayeredBoneBlend extends AnimNode_Base { 
	BasePose: PoseLink;
	BlendPoses: PoseLink[];
	LayerSetup: InputBlendPose[];
	BlendWeights: number[];
	bMeshSpaceRotationBlend: boolean;
	CurveBlendOption: ECurveBlendOption;
}

declare class AnimGraphNode_LayeredBoneBlend extends AnimGraphNode_BlendListBase { 
	UNode: AnimNode_LayeredBoneBlend;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_LayeredBoneBlend;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_LayeredBoneBlend;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_LayeredBoneBlend;
	static C(Other: UObject): AnimGraphNode_LayeredBoneBlend;
}

declare class ComponentSpacePoseLink extends PoseLinkBase { 
}

declare class AnimNode_ConvertComponentToLocalSpace extends AnimNode_Base { 
	ComponentPose: ComponentSpacePoseLink;
}

declare class AnimGraphNode_ComponentToLocalSpace extends AnimGraphNode_Base { 
	UNode: AnimNode_ConvertComponentToLocalSpace;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_ComponentToLocalSpace;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_ComponentToLocalSpace;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ComponentToLocalSpace;
	static C(Other: UObject): AnimGraphNode_ComponentToLocalSpace;
}

declare class AnimNode_ConvertLocalToComponentSpace extends AnimNode_Base { 
	LocalPose: PoseLink;
}

declare class AnimGraphNode_LocalToComponentSpace extends AnimGraphNode_Base { 
	UNode: AnimNode_ConvertLocalToComponentSpace;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_LocalToComponentSpace;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_LocalToComponentSpace;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_LocalToComponentSpace;
	static C(Other: UObject): AnimGraphNode_LocalToComponentSpace;
}

declare class AnimNode_MeshSpaceRefPose extends AnimNode_Base { 
}

declare class AnimGraphNode_MeshRefPose extends AnimGraphNode_Base { 
	UNode: AnimNode_MeshSpaceRefPose;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_MeshRefPose;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_MeshRefPose;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_MeshRefPose;
	static C(Other: UObject): AnimGraphNode_MeshRefPose;
}

declare type ERefPoseType = string;
declare class AnimNode_RefPose extends AnimNode_Base { 
	RefPoseType: ERefPoseType;
}

declare class AnimGraphNode_RefPoseBase extends AnimGraphNode_Base { 
	UNode: AnimNode_RefPose;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_RefPoseBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_RefPoseBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_RefPoseBase;
	static C(Other: UObject): AnimGraphNode_RefPoseBase;
}

declare class AnimGraphNode_IdentityPose extends AnimGraphNode_RefPoseBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_IdentityPose;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_IdentityPose;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_IdentityPose;
	static C(Other: UObject): AnimGraphNode_IdentityPose;
}

declare class AnimGraphNode_LocalRefPose extends AnimGraphNode_RefPoseBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_LocalRefPose;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_LocalRefPose;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_LocalRefPose;
	static C(Other: UObject): AnimGraphNode_LocalRefPose;
}

declare class AnimNode_RotateRootBone extends AnimNode_Base { 
	BasePose: PoseLink;
	Pitch: number;
	Yaw: number;
	MeshToComponent: Rotator;
}

declare class AnimGraphNode_RotateRootBone extends AnimGraphNode_Base { 
	UNode: AnimNode_RotateRootBone;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_RotateRootBone;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_RotateRootBone;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_RotateRootBone;
	static C(Other: UObject): AnimGraphNode_RotateRootBone;
}

declare class AnimNode_SaveCachedPose extends AnimNode_Base { 
	LastInitializedContextCounter: any;
	LastCacheBonesContextCounter: any;
	LastUpdatedContextCounter: any;
	LastEvaluatedContextCounter: any;
	Pose: PoseLink;
}

declare class AnimGraphNode_SaveCachedPose extends AnimGraphNode_Base { 
	UNode: AnimNode_SaveCachedPose;
	CacheName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_SaveCachedPose;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_SaveCachedPose;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_SaveCachedPose;
	static C(Other: UObject): AnimGraphNode_SaveCachedPose;
}

declare class AnimGraphNode_SkeletalControlBase extends AnimGraphNode_Base { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_SkeletalControlBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_SkeletalControlBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_SkeletalControlBase;
	static C(Other: UObject): AnimGraphNode_SkeletalControlBase;
}

declare class AnimNode_SkeletalControlBase extends AnimNode_Base { 
	ComponentPose: ComponentSpacePoseLink;
	Alpha: number;
	AlphaScaleBias: InputScaleBias;
}

declare type EComponentType = string;
declare type EDrivenBoneModificationMode = string;
declare class AnimNode_BoneDrivenController extends AnimNode_SkeletalControlBase { 
	SourceBone: BoneReference;
	SourceComponent: EComponentType;
	DrivingCurve: CurveFloat;
	Multiplier: number;
	bUseRange: boolean;
	RangeMin: number;
	RangeMax: number;
	RemappedMin: number;
	RemappedMax: number;
	TargetBone: BoneReference;
	TargetComponent: EComponentType;
	bAffectTargetTranslationX: boolean;
	bAffectTargetTranslationY: boolean;
	bAffectTargetTranslationZ: boolean;
	bAffectTargetRotationX: boolean;
	bAffectTargetRotationY: boolean;
	bAffectTargetRotationZ: boolean;
	bAffectTargetScaleX: boolean;
	bAffectTargetScaleY: boolean;
	bAffectTargetScaleZ: boolean;
	ModificationMode: EDrivenBoneModificationMode;
}

declare class AnimGraphNode_BoneDrivenController extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_BoneDrivenController;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_BoneDrivenController;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_BoneDrivenController;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BoneDrivenController;
	static C(Other: UObject): AnimGraphNode_BoneDrivenController;
}

declare class AnimNode_CopyBone extends AnimNode_SkeletalControlBase { 
	SourceBone: BoneReference;
	TargetBone: BoneReference;
	bCopyTranslation: boolean;
	bCopyRotation: boolean;
	bCopyScale: boolean;
}

declare class AnimGraphNode_CopyBone extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_CopyBone;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_CopyBone;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_CopyBone;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_CopyBone;
	static C(Other: UObject): AnimGraphNode_CopyBone;
}

declare type EBoneControlSpace = string;
declare type EBoneRotationSource = string;
declare class AnimNode_Fabrik extends AnimNode_SkeletalControlBase { 
	EffectorTransform: Transform;
	EffectorTransformSpace: EBoneControlSpace;
	EffectorTransformBone: BoneReference;
	EffectorRotationSource: EBoneRotationSource;
	TipBone: BoneReference;
	RootBone: BoneReference;
	Precision: number;
	MaxIterations: number;
	bEnableDebugDraw: boolean;
}

declare class AnimGraphNode_Fabrik extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_Fabrik;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_Fabrik;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_Fabrik;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_Fabrik;
	static C(Other: UObject): AnimGraphNode_Fabrik;
}

declare class AnimNode_HandIKRetargeting extends AnimNode_SkeletalControlBase { 
	RightHandFK: BoneReference;
	LeftHandFK: BoneReference;
	RightHandIK: BoneReference;
	LeftHandIK: BoneReference;
	IKBonesToMove: BoneReference[];
	HandFKWeight: number;
}

declare class AnimGraphNode_HandIKRetargeting extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_HandIKRetargeting;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_HandIKRetargeting;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_HandIKRetargeting;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_HandIKRetargeting;
	static C(Other: UObject): AnimGraphNode_HandIKRetargeting;
}

declare type EAxisOption = string;
declare type EInterpolationBlend = string;
declare class AnimNode_LookAt extends AnimNode_SkeletalControlBase { 
	BoneToModify: BoneReference;
	LookAtBone: BoneReference;
	LookAtLocation: Vector;
	LookAtAxis: EAxisOption;
	bUseLookUpAxis: boolean;
	LookUpAxis: EAxisOption;
	LookAtClamp: number;
	InterpolationType: EInterpolationBlend;
	InterpolationTime: number;
	InterpolationTriggerThreashold: number;
	bEnableDebug: boolean;
}

declare class AnimGraphNode_LookAt extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_LookAt;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_LookAt;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_LookAt;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_LookAt;
	static C(Other: UObject): AnimGraphNode_LookAt;
}

declare type EBoneModificationMode = string;
declare class AnimNode_ModifyBone extends AnimNode_SkeletalControlBase { 
	BoneToModify: BoneReference;
	Translation: Vector;
	Rotation: Rotator;
	Scale: Vector;
	TranslationMode: EBoneModificationMode;
	RotationMode: EBoneModificationMode;
	ScaleMode: EBoneModificationMode;
	TranslationSpace: EBoneControlSpace;
	RotationSpace: EBoneControlSpace;
	ScaleSpace: EBoneControlSpace;
}

declare class AnimGraphNode_ModifyBone extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_ModifyBone;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_ModifyBone;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_ModifyBone;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ModifyBone;
	static C(Other: UObject): AnimGraphNode_ModifyBone;
}

declare class AnimNode_ObserveBone extends AnimNode_SkeletalControlBase { 
	BoneToObserve: BoneReference;
	DisplaySpace: EBoneControlSpace;
	bRelativeToRefPose: boolean;
	Translation: Vector;
	Rotation: Rotator;
	Scale: Vector;
}

declare class AnimGraphNode_ObserveBone extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_ObserveBone;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_ObserveBone;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_ObserveBone;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ObserveBone;
	static C(Other: UObject): AnimGraphNode_ObserveBone;
}

declare type EBoneAxis = string;
declare class AnimNode_RotationMultiplier extends AnimNode_SkeletalControlBase { 
	TargetBone: BoneReference;
	SourceBone: BoneReference;
	Multiplier: number;
	RotationAxisToRefer: EBoneAxis;
	bIsAdditive: boolean;
}

declare class AnimGraphNode_RotationMultiplier extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_RotationMultiplier;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_RotationMultiplier;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_RotationMultiplier;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_RotationMultiplier;
	static C(Other: UObject): AnimGraphNode_RotationMultiplier;
}

declare class AnimNode_SpringBone extends AnimNode_SkeletalControlBase { 
	SpringBone: BoneReference;
	bLimitDisplacement: boolean;
	MaxDisplacement: number;
	SpringStiffness: number;
	SpringDamping: number;
	ErrorResetThresh: number;
	bNoZSpring: boolean;
	bTranslateX: boolean;
	bTranslateY: boolean;
	bTranslateZ: boolean;
	bRotateX: boolean;
	bRotateY: boolean;
	bRotateZ: boolean;
}

declare class AnimGraphNode_SpringBone extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_SpringBone;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_SpringBone;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_SpringBone;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_SpringBone;
	static C(Other: UObject): AnimGraphNode_SpringBone;
}

declare class AnimNode_Trail extends AnimNode_SkeletalControlBase { 
	TrailBone: BoneReference;
	ChainLength: number;
	ChainBoneAxis: EAxis;
	bInvertChainBoneAxis: boolean;
	bLimitStretch: boolean;
	TrailRelaxation: number;
	StretchLimit: number;
	FakeVelocity: Vector;
	bActorSpaceFakeVel: boolean;
}

declare class AnimGraphNode_Trail extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_Trail;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_Trail;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_Trail;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_Trail;
	static C(Other: UObject): AnimGraphNode_Trail;
}

declare class AnimNode_TwoBoneIK extends AnimNode_SkeletalControlBase { 
	IKBone: BoneReference;
	EffectorLocation: Vector;
	JointTargetLocation: Vector;
	StretchLimits: Vector2D;
	EffectorSpaceBoneName: string;
	bTakeRotationFromEffectorSpace: boolean;
	bMaintainEffectorRelRot: boolean;
	bAllowStretching: boolean;
	EffectorLocationSpace: EBoneControlSpace;
	JointTargetLocationSpace: EBoneControlSpace;
	JointTargetSpaceBoneName: string;
}

declare class AnimGraphNode_TwoBoneIK extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_TwoBoneIK;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_TwoBoneIK;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_TwoBoneIK;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_TwoBoneIK;
	static C(Other: UObject): AnimGraphNode_TwoBoneIK;
}

declare class VehicleWheel extends UObject { 
	CollisionMesh: StaticMesh;
	bDontCreateShape: boolean;
	bAutoAdjustCollisionSize: boolean;
	Offset: Vector;
	ShapeRadius: number;
	ShapeWidth: number;
	Mass: number;
	DampingRate: number;
	SteerAngle: number;
	bAffectedByHandbrake: boolean;
	TireType: TireType;
	LatStiffMaxLoad: number;
	LatStiffValue: number;
	LongStiffValue: number;
	SuspensionForceOffset: number;
	SuspensionMaxRaise: number;
	SuspensionMaxDrop: number;
	SuspensionNaturalFrequency: number;
	SuspensionDampingRatio: number;
	MaxBrakeTorque: number;
	MaxHandBrakeTorque: number;
	VehicleSim: WheeledVehicleMovementComponent;
	WheelIndex: number;
	DebugLongSlip: number;
	DebugLatSlip: number;
	DebugNormalizedTireLoad: number;
	DebugWheelTorque: number;
	DebugLongForce: number;
	DebugLatForce: number;
	Location: Vector;
	OldLocation: Vector;
	Velocity: Vector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VehicleWheel;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VehicleWheel;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VehicleWheel;
	static C(Other: UObject): VehicleWheel;
	GetSuspensionOffset(): number;
	GetSteerAngle(): number;
	GetRotationAngle(): number;
}

declare class WheelSetup { 
	WheelClass: UnrealEngineClass;
	BoneName: string;
	AdditionalOffset: Vector;
}

declare class ReplicatedVehicleState { 
	SteeringInput: number;
	ThrottleInput: number;
	BrakeInput: number;
	HandbrakeInput: number;
	CurrentGear: number;
}

declare class VehicleInputRate { 
	RiseRate: number;
	FallRate: number;
}

declare class WheeledVehicleMovementComponent extends PawnMovementComponent { 
	WheelSetups: WheelSetup[];
	Mass: number;
	DragCoefficient: number;
	ChassisWidth: number;
	ChassisHeight: number;
	DragArea: number;
	EstimatedMaxEngineSpeed: number;
	MaxEngineRPM: number;
	DebugDragMagnitude: number;
	InertiaTensorScale: Vector;
	MinNormalizedTireLoad: number;
	MinNormalizedTireLoadFiltered: number;
	MaxNormalizedTireLoad: number;
	MaxNormalizedTireLoadFiltered: number;
	ThresholdLongitudinalSpeed: number;
	LowForwardSpeedSubStepCount: number;
	HighForwardSpeedSubStepCount: number;
	Wheels: VehicleWheel[];
	bUseRVOAvoidance: boolean;
	RVOAvoidanceRadius: number;
	RVOAvoidanceHeight: number;
	AvoidanceConsiderationRadius: number;
	RVOSteeringStep: number;
	RVOThrottleStep: number;
	AvoidanceUID: number;
	AvoidanceGroup: NavAvoidanceMask;
	GroupsToAvoid: NavAvoidanceMask;
	GroupsToIgnore: NavAvoidanceMask;
	AvoidanceWeight: number;
	PendingLaunchVelocity: Vector;
	ReplicatedState: ReplicatedVehicleState;
	RawSteeringInput: number;
	RawThrottleInput: number;
	bRawHandbrakeInput: boolean;
	bRawGearUpInput: boolean;
	bRawGearDownInput: boolean;
	SteeringInput: number;
	ThrottleInput: number;
	BrakeInput: number;
	HandbrakeInput: number;
	IdleBrakeInput: number;
	StopThreshold: number;
	WrongDirectionThreshold: number;
	ThrottleInputRate: VehicleInputRate;
	BrakeInputRate: VehicleInputRate;
	HandbrakeInputRate: VehicleInputRate;
	SteeringInputRate: VehicleInputRate;
	bWasAvoidanceUpdated: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WheeledVehicleMovementComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WheeledVehicleMovementComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WheeledVehicleMovementComponent;
	static C(Other: UObject): WheeledVehicleMovementComponent;
	SetUseAutoGears(bUseAuto: boolean): void;
	SetThrottleInput(Throttle: number): void;
	SetTargetGear(GearNum: number,bImmediate: boolean): void;
	SetSteeringInput(Steering: number): void;
	SetHandbrakeInput(bNewHandbrake: boolean): void;
	SetGroupsToIgnore(GroupFlags: number): void;
	SetGroupsToAvoid(GroupFlags: number): void;
	SetGearUp(bNewGearUp: boolean): void;
	SetGearDown(bNewGearDown: boolean): void;
	SetAvoidanceGroup(GroupFlags: number): void;
	SetAvoidanceEnabled(bEnable: boolean): void;
	ServerUpdateState(InSteeringInput: number,InThrottleInput: number,InBrakeInput: number,InHandbrakeInput: number,CurrentGear: number): void;
	GetUseAutoGears(): boolean;
	GetTargetGear(): number;
	GetForwardSpeed(): number;
	GetEngineRotationSpeed(): number;
	GetEngineMaxRotationSpeed(): number;
	GetCurrentGear(): number;
}

declare class AnimNode_WheelHandler extends AnimNode_SkeletalControlBase { 
	VehicleSimComponent: WheeledVehicleMovementComponent;
}

declare class AnimGraphNode_WheelHandler extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_WheelHandler;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_WheelHandler;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_WheelHandler;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_WheelHandler;
	static C(Other: UObject): AnimGraphNode_WheelHandler;
}

declare class AnimNode_Slot extends AnimNode_Base { 
	Source: PoseLink;
	SlotName: string;
	LastSlotNodeInitializationCounter: any;
}

declare class AnimGraphNode_Slot extends AnimGraphNode_Base { 
	UNode: AnimNode_Slot;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_Slot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_Slot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_Slot;
	static C(Other: UObject): AnimGraphNode_Slot;
}

declare class AnimNode_StateMachine extends AnimNode_Base { 
	StateMachineIndexInClass: number;
	MaxTransitionsPerFrame: number;
	CurrentState: number;
	ElapsedTime: number;
}

declare class AnimGraphNode_StateMachine extends AnimGraphNode_StateMachineBase { 
	UNode: AnimNode_StateMachine;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_StateMachine;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_StateMachine;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_StateMachine;
	static C(Other: UObject): AnimGraphNode_StateMachine;
}

declare type EEvaluatorDataSource = string;
declare type EEvaluatorMode = string;
declare class AnimNode_TransitionPoseEvaluator extends AnimNode_Base { 
	DataSource: EEvaluatorDataSource;
	EvaluatorMode: EEvaluatorMode;
	FramesToCachePose: number;
	CacheFramesRemaining: number;
}

declare class AnimGraphNode_TransitionPoseEvaluator extends AnimGraphNode_Base { 
	UNode: AnimNode_TransitionPoseEvaluator;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_TransitionPoseEvaluator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_TransitionPoseEvaluator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_TransitionPoseEvaluator;
	static C(Other: UObject): AnimGraphNode_TransitionPoseEvaluator;
}

declare class AnimationNode_TwoWayBlend extends AnimNode_Base { 
	A: PoseLink;
	B: PoseLink;
	Alpha: number;
	AlphaScaleBias: InputScaleBias;
}

declare class AnimGraphNode_TwoWayBlend extends AnimGraphNode_Base { 
	BlendNode: AnimationNode_TwoWayBlend;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_TwoWayBlend;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_TwoWayBlend;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_TwoWayBlend;
	static C(Other: UObject): AnimGraphNode_TwoWayBlend;
}

declare class AnimNode_UseCachedPose extends AnimNode_Base { 
	LinkToCachingNode: PoseLink;
}

declare class AnimGraphNode_UseCachedPose extends AnimGraphNode_Base { 
	UNode: AnimNode_UseCachedPose;
	SaveCachedPoseNode: any;
	NameOfCache: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimGraphNode_UseCachedPose;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimGraphNode_UseCachedPose;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_UseCachedPose;
	static C(Other: UObject): AnimGraphNode_UseCachedPose;
}

declare class AnimSingleNodeInstance extends AnimInstance { 
	CurrentAsset: AnimationAsset;
	CurrentVertexAnim: VertexAnimation;
	BlendSpaceInput: Vector;
	BlendSampleData: BlendSampleData[];
	BlendFilter: BlendFilter;
	//CurrentTime: number;
	PlayRate: number;
	PostEvaluateAnimEvent: UnrealEngineDelegate<() => void>;
	bLooping: boolean;
	bPlaying: boolean;
	bReverse: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimSingleNodeInstance;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimSingleNodeInstance;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSingleNodeInstance;
	static C(Other: UObject): AnimSingleNodeInstance;
	StopAnim(): void;
	SetVertexAnimation(NewVertexAnim: VertexAnimation,bIsLooping: boolean,InPlayRate: number): void;
	SetReverse(bInReverse: boolean): void;
	SetPosition(InPosition: number,bFireNotifies: boolean): void;
	SetPlayRate(InPlayRate: number): void;
	SetPlaying(bIsPlaying: boolean): void;
	SetLooping(bIsLooping: boolean): void;
	SetBlendSpaceInput(InBlendInput: Vector): void;
	SetAnimationAsset(NewAsset: AnimationAsset,bIsLooping: boolean,InPlayRate: number): void;
	PlayAnim(bIsLooping: boolean,InPlayRate: number,InStartPosition: number): void;
	GetLength(): number;
}

declare type EMontagePreviewType = string;
declare class AnimPreviewInstance extends AnimSingleNodeInstance { 
	BoneControllers: AnimNode_ModifyBone[];
	CurveBoneControllers: AnimNode_ModifyBone[];
	SkeletalControlAlpha: number;
	MontagePreviewType: EMontagePreviewType;
	MontagePreviewStartSectionIdx: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimPreviewInstance;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimPreviewInstance;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimPreviewInstance;
	static C(Other: UObject): AnimPreviewInstance;
}

declare class AnimStateNodeBase extends EdGraphNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimStateNodeBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimStateNodeBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimStateNodeBase;
	static C(Other: UObject): AnimStateNodeBase;
}

declare class AnimStateConduitNode extends AnimStateNodeBase { 
	BoundGraph: EdGraph;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimStateConduitNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimStateConduitNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimStateConduitNode;
	static C(Other: UObject): AnimStateConduitNode;
}

declare type EAnimStateType = string;
declare class AnimStateNode extends AnimStateNodeBase { 
	BoundGraph: EdGraph;
	StateType: EAnimStateType;
	StateEntered: AnimNotifyEvent;
	StateLeft: AnimNotifyEvent;
	StateFullyBlended: AnimNotifyEvent;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimStateNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimStateNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimStateNode;
	static C(Other: UObject): AnimStateNode;
}

declare type ETransitionBlendMode = string;
declare type ETransitionLogicType = string;
declare class AnimStateTransitionNode extends AnimStateNodeBase { 
	BoundGraph: EdGraph;
	CustomTransitionGraph: EdGraph;
	PriorityOrder: number;
	CrossfadeDuration: number;
	CrossfadeMode: ETransitionBlendMode;
	BlendMode: EAlphaBlendOption;
	CustomBlendCurve: CurveFloat;
	bAutomaticRuleBasedOnSequencePlayerInState: boolean;
	LogicType: ETransitionLogicType;
	TransitionStart: AnimNotifyEvent;
	TransitionEnd: AnimNotifyEvent;
	TransitionInterrupt: AnimNotifyEvent;
	Bidirectional: boolean;
	bSharedRules: boolean;
	bSharedCrossfade: boolean;
	SharedRulesName: string;
	SharedRulesGuid: Guid;
	SharedColor: LinearColor;
	SharedCrossfadeName: string;
	SharedCrossfadeGuid: Guid;
	SharedCrossfadeIdx: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimStateTransitionNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimStateTransitionNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimStateTransitionNode;
	static C(Other: UObject): AnimStateTransitionNode;
}

declare class K2Node_AnimGetter extends K2Node_CallFunction { 
	SourceNode: AnimGraphNode_Base;
	SourceStateNode: AnimStateNodeBase;
	GetterClass: UnrealEngineClass;
	SourceAnimBlueprint: AnimBlueprint;
	CachedTitle: string;
	Contexts: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_AnimGetter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_AnimGetter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AnimGetter;
	static C(Other: UObject): K2Node_AnimGetter;
}

declare type ETransitionGetter = string;
declare class K2Node_TransitionRuleGetter extends K2Node { 
	GetterType: ETransitionGetter;
	AssociatedAnimAssetPlayerNode: AnimGraphNode_Base;
	AssociatedStateNode: AnimStateNode;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_TransitionRuleGetter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_TransitionRuleGetter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_TransitionRuleGetter;
	static C(Other: UObject): K2Node_TransitionRuleGetter;
}

declare class LevelSequenceObjectReferenceMap { 
}

declare class LevelSequence extends UObject { 
	DefaultObjectReferences: LevelSequenceObjectReferenceMap;
	MovieScene: MovieScene;
	PossessedObjects: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelSequence;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelSequence;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequence;
	static C(Other: UObject): LevelSequence;
}

declare class LevelSequenceInstance extends MovieSceneSequence { 
	LevelSequence: LevelSequence;
	bCanRemapBindings: boolean;
	RemappedObjectReferences: LevelSequenceObjectReferenceMap;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelSequenceInstance;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelSequenceInstance;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequenceInstance;
	static C(Other: UObject): LevelSequenceInstance;
}

declare class LevelSequencePlaybackSettings { 
	LoopCount: number;
	PlayRate: number;
}

declare class LevelSequencePlayer extends UObject { 
	LevelSequenceInstance: LevelSequenceInstance;
	bIsPlaying: boolean;
	TimeCursorPosition: number;
	PlaybackSettings: LevelSequencePlaybackSettings;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelSequencePlayer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelSequencePlayer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequencePlayer;
	static C(Other: UObject): LevelSequencePlayer;
	Stop(): void;
	SetPlayRate(PlayRate: number): void;
	SetPlaybackPosition(NewPlaybackPosition: number): void;
	PlayLooping(NumLoops: number): void;
	Play(): void;
	Pause(): void;
	IsPlaying(): boolean;
	GetPlayRate(): number;
	GetPlaybackPosition(): number;
	GetLength(): number;
	static CreateLevelSequencePlayer(WorldContextObject: UObject,LevelSequence: LevelSequence,Settings: LevelSequencePlaybackSettings): LevelSequencePlayer;
}

declare class LevelSequenceActor extends Actor { 
	bAutoPlay: boolean;
	PlaybackSettings: LevelSequencePlaybackSettings;
	SequencePlayer: LevelSequencePlayer;
	LevelSequence: StringAssetReference;
	SequenceInstance: LevelSequenceInstance;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelSequenceActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequenceActor;
	static C(Other: UObject): LevelSequenceActor;
	SetSequence(InSequence: LevelSequence): void;
}

declare class ActorFactory extends UObject { 
	DisplayName: string;
	MenuPriority: number;
	NewActorClassName: string;
	NewActorClass: UnrealEngineClass;
	bShowInEditorQuickMenu: boolean;
	bUseSurfaceOrientation: boolean;
	SpawnPositionOffset: Vector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactory;
	static C(Other: UObject): ActorFactory;
}

declare class ActorFactoryAmbientSound extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryAmbientSound;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryAmbientSound;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryAmbientSound;
	static C(Other: UObject): ActorFactoryAmbientSound;
}

declare class ActorFactoryAtmosphericFog extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryAtmosphericFog;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryAtmosphericFog;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryAtmosphericFog;
	static C(Other: UObject): ActorFactoryAtmosphericFog;
}

declare class ActorFactoryBlueprint extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryBlueprint;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryBlueprint;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryBlueprint;
	static C(Other: UObject): ActorFactoryBlueprint;
}

declare class ActorFactoryBoxReflectionCapture extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryBoxReflectionCapture;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryBoxReflectionCapture;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryBoxReflectionCapture;
	static C(Other: UObject): ActorFactoryBoxReflectionCapture;
}

declare class ActorFactoryBoxVolume extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryBoxVolume;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryBoxVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryBoxVolume;
	static C(Other: UObject): ActorFactoryBoxVolume;
}

declare class ActorFactoryCameraActor extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryCameraActor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryCameraActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryCameraActor;
	static C(Other: UObject): ActorFactoryCameraActor;
}

declare class ActorFactoryCharacter extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryCharacter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryCharacter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryCharacter;
	static C(Other: UObject): ActorFactoryCharacter;
}

declare class ActorFactoryClass extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryClass;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryClass;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryClass;
	static C(Other: UObject): ActorFactoryClass;
}

declare class ActorFactoryCylinderVolume extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryCylinderVolume;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryCylinderVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryCylinderVolume;
	static C(Other: UObject): ActorFactoryCylinderVolume;
}

declare class ActorFactoryDeferredDecal extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryDeferredDecal;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryDeferredDecal;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryDeferredDecal;
	static C(Other: UObject): ActorFactoryDeferredDecal;
}

declare class ActorFactoryDestructible extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryDestructible;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryDestructible;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryDestructible;
	static C(Other: UObject): ActorFactoryDestructible;
}

declare class ActorFactoryDirectionalLight extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryDirectionalLight;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryDirectionalLight;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryDirectionalLight;
	static C(Other: UObject): ActorFactoryDirectionalLight;
}

declare class ActorFactoryEmitter extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryEmitter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryEmitter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryEmitter;
	static C(Other: UObject): ActorFactoryEmitter;
}

declare class ActorFactoryEmptyActor extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryEmptyActor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryEmptyActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryEmptyActor;
	static C(Other: UObject): ActorFactoryEmptyActor;
}

declare class ActorFactoryPawn extends ActorFactoryEmptyActor { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryPawn;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryPawn;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryPawn;
	static C(Other: UObject): ActorFactoryPawn;
}

declare class ActorFactoryExponentialHeightFog extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryExponentialHeightFog;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryExponentialHeightFog;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryExponentialHeightFog;
	static C(Other: UObject): ActorFactoryExponentialHeightFog;
}

declare class ActorFactoryMatineeActor extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryMatineeActor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryMatineeActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryMatineeActor;
	static C(Other: UObject): ActorFactoryMatineeActor;
}

declare class ActorFactoryMovieScene extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryMovieScene;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryMovieScene;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryMovieScene;
	static C(Other: UObject): ActorFactoryMovieScene;
}

declare class ActorFactoryNiagara extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryNiagara;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryNiagara;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryNiagara;
	static C(Other: UObject): ActorFactoryNiagara;
}

declare class ActorFactoryNote extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryNote;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryNote;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryNote;
	static C(Other: UObject): ActorFactoryNote;
}

declare class ActorFactoryPhysicsAsset extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryPhysicsAsset;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryPhysicsAsset;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryPhysicsAsset;
	static C(Other: UObject): ActorFactoryPhysicsAsset;
}

declare class ActorFactoryPlaneReflectionCapture extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryPlaneReflectionCapture;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryPlaneReflectionCapture;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryPlaneReflectionCapture;
	static C(Other: UObject): ActorFactoryPlaneReflectionCapture;
}

declare class ActorFactoryPlayerStart extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryPlayerStart;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryPlayerStart;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryPlayerStart;
	static C(Other: UObject): ActorFactoryPlayerStart;
}

declare class ActorFactoryPointLight extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryPointLight;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryPointLight;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryPointLight;
	static C(Other: UObject): ActorFactoryPointLight;
}

declare class ActorFactorySkeletalMesh extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactorySkeletalMesh;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactorySkeletalMesh;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactorySkeletalMesh;
	static C(Other: UObject): ActorFactorySkeletalMesh;
}

declare class ActorFactoryAnimationAsset extends ActorFactorySkeletalMesh { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryAnimationAsset;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryAnimationAsset;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryAnimationAsset;
	static C(Other: UObject): ActorFactoryAnimationAsset;
}

declare class ActorFactorySkyLight extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactorySkyLight;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactorySkyLight;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactorySkyLight;
	static C(Other: UObject): ActorFactorySkyLight;
}

declare class ActorFactorySphereReflectionCapture extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactorySphereReflectionCapture;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactorySphereReflectionCapture;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactorySphereReflectionCapture;
	static C(Other: UObject): ActorFactorySphereReflectionCapture;
}

declare class ActorFactorySphereVolume extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactorySphereVolume;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactorySphereVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactorySphereVolume;
	static C(Other: UObject): ActorFactorySphereVolume;
}

declare class ActorFactorySpotLight extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactorySpotLight;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactorySpotLight;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactorySpotLight;
	static C(Other: UObject): ActorFactorySpotLight;
}

declare class ActorFactoryStaticMesh extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryStaticMesh;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryStaticMesh;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryStaticMesh;
	static C(Other: UObject): ActorFactoryStaticMesh;
}

declare class ActorFactoryBasicShape extends ActorFactoryStaticMesh { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryBasicShape;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryBasicShape;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryBasicShape;
	static C(Other: UObject): ActorFactoryBasicShape;
}

declare class ActorFactoryInteractiveFoliage extends ActorFactoryStaticMesh { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryInteractiveFoliage;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryInteractiveFoliage;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryInteractiveFoliage;
	static C(Other: UObject): ActorFactoryInteractiveFoliage;
}

declare class ActorFactoryTargetPoint extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryTargetPoint;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryTargetPoint;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryTargetPoint;
	static C(Other: UObject): ActorFactoryTargetPoint;
}

declare class ActorFactoryTextRender extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryTextRender;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryTextRender;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryTextRender;
	static C(Other: UObject): ActorFactoryTextRender;
}

declare class ActorFactoryTriggerBox extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryTriggerBox;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryTriggerBox;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryTriggerBox;
	static C(Other: UObject): ActorFactoryTriggerBox;
}

declare class ActorFactoryTriggerCapsule extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryTriggerCapsule;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryTriggerCapsule;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryTriggerCapsule;
	static C(Other: UObject): ActorFactoryTriggerCapsule;
}

declare class ActorFactoryTriggerSphere extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryTriggerSphere;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryTriggerSphere;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryTriggerSphere;
	static C(Other: UObject): ActorFactoryTriggerSphere;
}

declare class ActorFactoryVectorFieldVolume extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryVectorFieldVolume;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryVectorFieldVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryVectorFieldVolume;
	static C(Other: UObject): ActorFactoryVectorFieldVolume;
}

declare class AnalyticsPrivacySettings extends UObject { 
	bSendUsageData: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnalyticsPrivacySettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnalyticsPrivacySettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnalyticsPrivacySettings;
	static C(Other: UObject): AnalyticsPrivacySettings;
}

declare class Exporter extends UObject { 
	SupportedClass: UnrealEngineClass;
	ExportRootScope: UObject;
	FormatExtension: string[];
	FormatDescription: string[];
	PreferredFormatIndex: number;
	TextIndent: number;
	bText: boolean;
	bSelectedOnly: boolean;
	bForceFileOperations: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Exporter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Exporter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Exporter;
	static C(Other: UObject): Exporter;
}

declare class AnimSequenceExporterFBX extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimSequenceExporterFBX;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimSequenceExporterFBX;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSequenceExporterFBX;
	static C(Other: UObject): AnimSequenceExporterFBX;
}

declare class Commandlet extends UObject { 
	HelpDescription: string;
	HelpUsage: string;
	HelpWebLink: string;
	HelpParamNames: string[];
	HelpParamDescriptions: string[];
	IsServer: boolean;
	IsClient: boolean;
	IsEditor: boolean;
	LogToConsole: boolean;
	ShowErrorCount: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Commandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Commandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Commandlet;
	static C(Other: UObject): Commandlet;
}

declare class AudioTestCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AudioTestCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AudioTestCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioTestCommandlet;
	static C(Other: UObject): AudioTestCommandlet;
}

declare class AutoReimportManager extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AutoReimportManager;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AutoReimportManager;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutoReimportManager;
	static C(Other: UObject): AutoReimportManager;
}

declare class CascadeOptions extends UObject { 
	bShowModuleDump: boolean;
	BackgroundColor: Color;
	bUseSubMenus: boolean;
	bUseSpaceBarReset: boolean;
	bUseSpaceBarResetInLevel: boolean;
	Empty_Background: Color;
	Emitter_Background: Color;
	Emitter_Unselected: Color;
	Emitter_Selected: Color;
	ModuleColor_General_Unselected: Color;
	ModuleColor_General_Selected: Color;
	ModuleColor_TypeData_Unselected: Color;
	ModuleColor_TypeData_Selected: Color;
	ModuleColor_Beam_Unselected: Color;
	ModuleColor_Beam_Selected: Color;
	ModuleColor_Trail_Unselected: Color;
	ModuleColor_Trail_Selected: Color;
	ModuleColor_Spawn_Unselected: Color;
	ModuleColor_Spawn_Selected: Color;
	ModuleColor_Light_Unselected: Color;
	ModuleColor_Light_Selected: Color;
	ModuleColor_Required_Unselected: Color;
	ModuleColor_Required_Selected: Color;
	ModuleColor_Event_Unselected: Color;
	ModuleColor_Event_Selected: Color;
	bShowGrid: boolean;
	GridColor_Hi: Color;
	GridColor_Low: Color;
	GridPerspectiveSize: number;
	bShowParticleCounts: boolean;
	bShowParticleEvents: boolean;
	bShowParticleTimes: boolean;
	bShowParticleDistance: boolean;
	bShowParticleMemory: boolean;
	ParticleMemoryUpdateTime: number;
	bShowFloor: boolean;
	FloorMesh: string;
	FloorPosition: Vector;
	FloorRotation: Rotator;
	FloorScale: number;
	FloorScale3D: Vector;
	ShowPPFlags: number;
	bUseSlimCascadeDraw: boolean;
	SlimCascadeDrawHeight: number;
	bCenterCascadeModuleText: boolean;
	Cascade_MouseMoveThreshold: number;
	MotionModeRadius: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CascadeOptions;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CascadeOptions;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CascadeOptions;
	static C(Other: UObject): CascadeOptions;
}

declare class ChunkDependency { 
	ChunkID: number;
	ParentChunkID: number;
}

declare class ChunkDependencyInfo extends UObject { 
	DependencyArray: ChunkDependency[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ChunkDependencyInfo;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ChunkDependencyInfo;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChunkDependencyInfo;
	static C(Other: UObject): ChunkDependencyInfo;
}

declare class CollisionTestEntry { 
	RootShapeAsset: string;
	ShapeType: string;
	HitResult: HitResult;
}

declare class CollisionPerfTest { 
	RootShapeAsset: string;
	ShapeType: string;
	CreationBounds: Vector;
	CreationElements: Vector;
}

declare class CollisionAutomationTestConfigData extends UObject { 
	ComponentSweepMultiTests: CollisionTestEntry[];
	LineTraceSingleByChannelTests: CollisionTestEntry[];
	LineTracePerformanceTests: CollisionPerfTest[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CollisionAutomationTestConfigData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CollisionAutomationTestConfigData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CollisionAutomationTestConfigData;
	static C(Other: UObject): CollisionAutomationTestConfigData;
}

declare class CompressAnimationsCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CompressAnimationsCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CompressAnimationsCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CompressAnimationsCommandlet;
	static C(Other: UObject): CompressAnimationsCommandlet;
}

declare class ContentBrowserSettings extends UObject { 
	NumObjectsToLoadBeforeWarning: number;
	RealTimeThumbnails: boolean;
	DisplayFolders: boolean;
	DisplayEngineFolder: boolean;
	DisplayDevelopersFolder: boolean;
	DisplayPluginFolders: boolean;
	DisplayCollections: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ContentBrowserSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ContentBrowserSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserSettings;
	static C(Other: UObject): ContentBrowserSettings;
}

declare class CookCommandlet extends Commandlet { 
	FullGCAssetClassNames: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CookCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CookCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CookCommandlet;
	static C(Other: UObject): CookCommandlet;
}

declare class DeveloperSettings extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DeveloperSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DeveloperSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DeveloperSettings;
	static C(Other: UObject): DeveloperSettings;
}

declare class CookerSettings extends DeveloperSettings { 
	bEnableCookOnTheSide: boolean;
	DefaultPVRTCQuality: number;
	DefaultASTCQualityBySpeed: number;
	DefaultASTCQualityBySize: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CookerSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CookerSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CookerSettings;
	static C(Other: UObject): CookerSettings;
}

declare class CookOnTheFlyServer extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CookOnTheFlyServer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CookOnTheFlyServer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CookOnTheFlyServer;
	static C(Other: UObject): CookOnTheFlyServer;
}

declare type ECurveEditorCurveVisibility = string;
declare type ECurveEditorTangentVisibility = string;
declare class CurveEditorSettings extends UObject { 
	bAutoFrameCurveEditor: boolean;
	bShowCurveEditorCurveToolTips: boolean;
	CurveVisibility: ECurveEditorCurveVisibility;
	TangentVisibility: ECurveEditorTangentVisibility;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CurveEditorSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CurveEditorSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorSettings;
	static C(Other: UObject): CurveEditorSettings;
}

declare class CurveEdOptions extends UObject { 
	MinViewRange: number;
	MaxViewRange: number;
	BackgroundColor: LinearColor;
	LabelColor: LinearColor;
	SelectedLabelColor: LinearColor;
	GridColor: LinearColor;
	GridTextColor: LinearColor;
	LabelBlockBkgColor: LinearColor;
	SelectedKeyColor: LinearColor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CurveEdOptions;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CurveEdOptions;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEdOptions;
	static C(Other: UObject): CurveEdOptions;
}

declare class SelectedSocketInfo { 
}

declare class DebugSkelMeshComponent extends SkeletalMeshComponent { 
	bRenderRawSkeleton: boolean;
	bDrawMesh: boolean;
	bShowBoneNames: boolean;
	bDrawBoneInfluences: boolean;
	bDrawNormals: boolean;
	bDrawTangents: boolean;
	bDrawBinormals: boolean;
	bDrawSockets: boolean;
	bSkeletonSocketsVisible: boolean;
	bMeshSocketsVisible: boolean;
	bDisplayRawAnimation: boolean;
	bDisplayNonRetargetedPose: boolean;
	bDisplayAdditiveBasePose: boolean;
	bDisplayBakedAnimation: boolean;
	bDisplaySourceAnimation: boolean;
	bDisplayBound: boolean;
	bPreviewRootMotion: boolean;
	BonesOfInterest: number[];
	SocketsOfInterest: SelectedSocketInfo[];
	SkelMaterials: MaterialInterface[];
	PreviewInstance: AnimPreviewInstance;
	SavedAnimScriptInstance: AnimInstance;
	bIsUsingInGameBounds: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DebugSkelMeshComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DebugSkelMeshComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DebugSkelMeshComponent;
	static C(Other: UObject): DebugSkelMeshComponent;
}

declare class UnrealEdTypes extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UnrealEdTypes;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UnrealEdTypes;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UnrealEdTypes;
	static C(Other: UObject): UnrealEdTypes;
}

declare class DEditorParameterValue extends UObject { 
	bOverride: boolean;
	ParameterName: string;
	ExpressionId: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DEditorParameterValue;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DEditorParameterValue;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DEditorParameterValue;
	static C(Other: UObject): DEditorParameterValue;
}

declare class DFontParameters { 
	FontValue: Font;
	FontPage: number;
}

declare class DEditorFontParameterValue extends DEditorParameterValue { 
	ParameterValue: DFontParameters;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DEditorFontParameterValue;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DEditorFontParameterValue;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DEditorFontParameterValue;
	static C(Other: UObject): DEditorFontParameterValue;
}

declare class DEditorScalarParameterValue extends DEditorParameterValue { 
	ParameterValue: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DEditorScalarParameterValue;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DEditorScalarParameterValue;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DEditorScalarParameterValue;
	static C(Other: UObject): DEditorScalarParameterValue;
}

declare class DComponentMaskParameter { 
	R: boolean;
	G: boolean;
	B: boolean;
	A: boolean;
}

declare class DEditorStaticComponentMaskParameterValue extends DEditorParameterValue { 
	ParameterValue: DComponentMaskParameter;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DEditorStaticComponentMaskParameterValue;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DEditorStaticComponentMaskParameterValue;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DEditorStaticComponentMaskParameterValue;
	static C(Other: UObject): DEditorStaticComponentMaskParameterValue;
}

declare class DEditorStaticSwitchParameterValue extends DEditorParameterValue { 
	ParameterValue: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DEditorStaticSwitchParameterValue;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DEditorStaticSwitchParameterValue;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DEditorStaticSwitchParameterValue;
	static C(Other: UObject): DEditorStaticSwitchParameterValue;
}

declare class DEditorTextureParameterValue extends DEditorParameterValue { 
	ParameterValue: Texture;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DEditorTextureParameterValue;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DEditorTextureParameterValue;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DEditorTextureParameterValue;
	static C(Other: UObject): DEditorTextureParameterValue;
}

declare class DEditorVectorParameterValue extends DEditorParameterValue { 
	ParameterValue: LinearColor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DEditorVectorParameterValue;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DEditorVectorParameterValue;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DEditorVectorParameterValue;
	static C(Other: UObject): DEditorVectorParameterValue;
}

declare class DerivedDataCacheCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DerivedDataCacheCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DerivedDataCacheCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DerivedDataCacheCommandlet;
	static C(Other: UObject): DerivedDataCacheCommandlet;
}

declare class DestructableMeshEditorSettings extends UObject { 
	AnimPreviewFloorColor: Color;
	AnimPreviewSkyColor: Color;
	AnimPreviewSkyBrightness: number;
	AnimPreviewLightBrightness: number;
	AnimPreviewLightingDirection: Rotator;
	AnimPreviewDirectionalColor: Color;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DestructableMeshEditorSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DestructableMeshEditorSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DestructableMeshEditorSettings;
	static C(Other: UObject): DestructableMeshEditorSettings;
}

declare class DiffAssetsCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DiffAssetsCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DiffAssetsCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DiffAssetsCommandlet;
	static C(Other: UObject): DiffAssetsCommandlet;
}

declare class DiffPackagesCommandlet extends Commandlet { 
	Packages: Package;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DiffPackagesCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DiffPackagesCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DiffPackagesCommandlet;
	static C(Other: UObject): DiffPackagesCommandlet;
}

declare class DumpBlueprintsInfoCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DumpBlueprintsInfoCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DumpBlueprintsInfoCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DumpBlueprintsInfoCommandlet;
	static C(Other: UObject): DumpBlueprintsInfoCommandlet;
}

declare class DumpHiddenCategoriesCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DumpHiddenCategoriesCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DumpHiddenCategoriesCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DumpHiddenCategoriesCommandlet;
	static C(Other: UObject): DumpHiddenCategoriesCommandlet;
}

declare type ECommentBoxMode = string;
declare class EdGraphNode_Comment extends EdGraphNode { 
	CommentColor: LinearColor;
	bColorCommentBubble: boolean;
	MoveMode: ECommentBoxMode;
	CommentDepth: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EdGraphNode_Comment;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EdGraphNode_Comment;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphNode_Comment;
	static C(Other: UObject): EdGraphNode_Comment;
}

declare class MaterialGraphNode_Base extends EdGraphNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialGraphNode_Base;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialGraphNode_Base;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialGraphNode_Base;
	static C(Other: UObject): MaterialGraphNode_Base;
}

declare class MaterialGraphNode_Root extends MaterialGraphNode_Base { 
	Material: Material;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialGraphNode_Root;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialGraphNode_Root;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialGraphNode_Root;
	static C(Other: UObject): MaterialGraphNode_Root;
}

declare class MaterialGraph extends EdGraph { 
	Material: Material;
	MaterialFunction: MaterialFunction;
	RootNode: MaterialGraphNode_Root;
	OriginalMaterialFullName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialGraph;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialGraph;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialGraph;
	static C(Other: UObject): MaterialGraph;
}

declare class MaterialGraphNode_Comment extends EdGraphNode_Comment { 
	MaterialExpressionComment: MaterialExpressionComment;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialGraphNode_Comment;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialGraphNode_Comment;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialGraphNode_Comment;
	static C(Other: UObject): MaterialGraphNode_Comment;
}

declare class EdGraphSchema_Niagara extends EdGraphSchema { 
	PC_Float: string;
	PC_Vector: string;
	PC_Matrix: string;
	PC_Curve: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EdGraphSchema_Niagara;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EdGraphSchema_Niagara;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphSchema_Niagara;
	static C(Other: UObject): EdGraphSchema_Niagara;
}

declare class EditorActorFolders extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorActorFolders;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorActorFolders;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorActorFolders;
	static C(Other: UObject): EditorActorFolders;
}

declare class EditorAnimBaseObj extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorAnimBaseObj;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorAnimBaseObj;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorAnimBaseObj;
	static C(Other: UObject): EditorAnimBaseObj;
}

declare class EditorAnimCompositeSegment extends EditorAnimBaseObj { 
	AnimSegment: AnimSegment;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorAnimCompositeSegment;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorAnimCompositeSegment;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorAnimCompositeSegment;
	static C(Other: UObject): EditorAnimCompositeSegment;
}

declare class EditorAnimSegment extends EditorAnimBaseObj { 
	AnimSegment: AnimSegment;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorAnimSegment;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorAnimSegment;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorAnimSegment;
	static C(Other: UObject): EditorAnimSegment;
}

declare class EditorCompositeSection extends EditorAnimBaseObj { 
	CompositeSection: CompositeSection;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorCompositeSection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorCompositeSection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorCompositeSection;
	static C(Other: UObject): EditorCompositeSection;
}

declare class EditorNotifyObject extends EditorAnimBaseObj { 
	Event: AnimNotifyEvent;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorNotifyObject;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorNotifyObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorNotifyObject;
	static C(Other: UObject): EditorNotifyObject;
}

declare class EditorBrushBuilder extends BrushBuilder { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorBrushBuilder;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorBrushBuilder;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorBrushBuilder;
	static C(Other: UObject): EditorBrushBuilder;
}

declare class ConeBuilder extends EditorBrushBuilder { 
	Z: number;
	CapZ: number;
	OuterRadius: number;
	InnerRadius: number;
	Sides: number;
	GroupName: string;
	AlignToSide: boolean;
	Hollow: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ConeBuilder;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ConeBuilder;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConeBuilder;
	static C(Other: UObject): ConeBuilder;
}

declare class CubeBuilder extends EditorBrushBuilder { 
	X: number;
	Y: number;
	Z: number;
	WallThickness: number;
	GroupName: string;
	Hollow: boolean;
	Tessellated: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CubeBuilder;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CubeBuilder;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CubeBuilder;
	static C(Other: UObject): CubeBuilder;
}

declare class CurvedStairBuilder extends EditorBrushBuilder { 
	InnerRadius: number;
	StepHeight: number;
	StepWidth: number;
	AngleOfCurve: number;
	NumSteps: number;
	AddToFirstStep: number;
	GroupName: string;
	CounterClockwise: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CurvedStairBuilder;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CurvedStairBuilder;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurvedStairBuilder;
	static C(Other: UObject): CurvedStairBuilder;
}

declare class CylinderBuilder extends EditorBrushBuilder { 
	Z: number;
	OuterRadius: number;
	InnerRadius: number;
	Sides: number;
	GroupName: string;
	AlignToSide: boolean;
	Hollow: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CylinderBuilder;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CylinderBuilder;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CylinderBuilder;
	static C(Other: UObject): CylinderBuilder;
}

declare class LinearStairBuilder extends EditorBrushBuilder { 
	StepLength: number;
	StepHeight: number;
	StepWidth: number;
	NumSteps: number;
	AddToFirstStep: number;
	GroupName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LinearStairBuilder;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LinearStairBuilder;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinearStairBuilder;
	static C(Other: UObject): LinearStairBuilder;
}

declare type ESheetAxis = string;
declare class SheetBuilder extends EditorBrushBuilder { 
	X: number;
	Y: number;
	XSegments: number;
	YSegments: number;
	Axis: ESheetAxis;
	GroupName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SheetBuilder;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SheetBuilder;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SheetBuilder;
	static C(Other: UObject): SheetBuilder;
}

declare class SpiralStairBuilder extends EditorBrushBuilder { 
	InnerRadius: number;
	StepWidth: number;
	StepHeight: number;
	StepThickness: number;
	NumStepsPer360: number;
	NumSteps: number;
	GroupName: string;
	SlopedCeiling: boolean;
	SlopedFloor: boolean;
	CounterClockwise: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SpiralStairBuilder;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SpiralStairBuilder;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpiralStairBuilder;
	static C(Other: UObject): SpiralStairBuilder;
}

declare class TetrahedronBuilder extends EditorBrushBuilder { 
	Radius: number;
	SphereExtrapolation: number;
	GroupName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TetrahedronBuilder;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TetrahedronBuilder;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TetrahedronBuilder;
	static C(Other: UObject): TetrahedronBuilder;
}

declare class VolumetricBuilder extends EditorBrushBuilder { 
	Z: number;
	Radius: number;
	NumSheets: number;
	GroupName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VolumetricBuilder;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VolumetricBuilder;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VolumetricBuilder;
	static C(Other: UObject): VolumetricBuilder;
}

declare class EditorPerProjectUserSettings extends UObject { 
	bDisplayUIExtensionPoints: boolean;
	bDisplayDocumentationLink: boolean;
	bDisplayActionListItemRefIds: boolean;
	bAlwaysGatherBehaviorTreeDebuggerData: boolean;
	bDisplayEngineVersionInBadge: boolean;
	bShowFrameRateAndMemory: boolean;
	bThrottleCPUWhenNotForeground: boolean;
	bMonitorEditorPerformance: boolean;
	bAutomaticallyHotReloadNewClasses: boolean;
	bKeepAttachHierarchy: boolean;
	bUseCurvesForDistributions: boolean;
	PropertyMatrix_NumberOfPasteOperationsBeforeWarning: number;
	bSCSEditorShowGrid: boolean;
	bSCSEditorShowFloor: boolean;
	SCSViewportCameraSpeed: number;
	bAutoloadCheckedOutPackages: boolean;
	bSuppressFullyLoadPrompt: boolean;
	bAllowSelectTranslucent: boolean;
	BlueprintFavorites: BlueprintPaletteFavorites;
	MaterialQualityLevel: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorPerProjectUserSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorPerProjectUserSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorPerProjectUserSettings;
	static C(Other: UObject): EditorPerProjectUserSettings;
}

declare class Transactor extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Transactor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Transactor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Transactor;
	static C(Other: UObject): Transactor;
}

declare type ELabelAnchorMode = string;
declare type EPlayOnBuildMode = string;
declare type EPlayOnLaunchConfiguration = string;
declare type EPlayNetMode = string;
declare type ELaunchModeType = string;
declare type EPlayModeLocations = string;
declare type EPlayModeType = string;
declare class PlayScreenResolution { 
	Description: string;
	Width: number;
	Height: number;
	AspectRatio: string;
}

declare class LevelEditorPlaySettings extends UObject { 
	PlayFromHerePlayerStartClassName: string;
	GameGetsMouseControl: boolean;
	ShowMouseControlLabel: boolean;
	MouseControlLabelPosition: ELabelAnchorMode;
	ViewportGetsHMDControl: boolean;
	AutoRecompileBlueprints: boolean;
	EnableSound: boolean;
	PlayInEditorSoundQualityLevel: number;
	bOnlyLoadVisibleLevelsInPIE: boolean;
	bPreferToStreamLevelsInPIE: boolean;
	PIEAlwaysOnTop: boolean;
	NewWindowWidth: number;
	NewWindowHeight: number;
	NewWindowPosition: IntPoint;
	CenterNewWindow: boolean;
	StandaloneWindowWidth: number;
	StandaloneWindowHeight: number;
	StandaloneWindowPosition: IntPoint;
	CenterStandaloneWindow: boolean;
	DisableStandaloneSound: boolean;
	AdditionalLaunchParameters: string;
	BuildGameBeforeLaunch: EPlayOnBuildMode;
	LaunchConfiguration: EPlayOnLaunchConfiguration;
	bAutoCompileBlueprintsOnLaunch: boolean;
	PlayNetMode: EPlayNetMode;
	RunUnderOneProcess: boolean;
	PlayNetDedicated: boolean;
	PlayNumberOfClients: number;
	ClientWindowWidth: number;
	AutoConnectToServer: boolean;
	RouteGamepadToSecondWindow: boolean;
	CreateAudioDeviceForEveryPlayer: boolean;
	ClientWindowHeight: number;
	AdditionalServerGameOptions: string;
	AdditionalLaunchOptions: string;
	MultipleInstanceLastHeight: number;
	MultipleInstanceLastWidth: number;
	MultipleInstancePositions: IntPoint[];
	LastExecutedLaunchDevice: string;
	LastExecutedLaunchName: string;
	LastExecutedLaunchModeType: ELaunchModeType;
	LastExecutedPlayModeLocation: EPlayModeLocations;
	LastExecutedPlayModeType: EPlayModeType;
	LaptopScreenResolutions: PlayScreenResolution[];
	MonitorScreenResolutions: PlayScreenResolution[];
	PhoneScreenResolutions: PlayScreenResolution[];
	TabletScreenResolutions: PlayScreenResolution[];
	TelevisionScreenResolutions: PlayScreenResolution[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelEditorPlaySettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelEditorPlaySettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditorPlaySettings;
	static C(Other: UObject): LevelEditorPlaySettings;
}

declare type EWASDType = string;
declare type ELandscapeFoliageEditorControlType = string;
declare class SnapToSurfaceSettings { 
	bEnabled: boolean;
	SnapOffsetExtent: number;
	bSnapRotation: boolean;
}

declare type ERotationGridMode = string;
declare type EMeasuringToolUnits = string;
declare type ELevelViewportType = string;
declare type EViewModeIndex = string;
declare class ExposureSettings { 
	LogOffset: number;
	bFixed: boolean;
}

declare class LevelEditorViewportInstanceSettings { 
	ViewportType: ELevelViewportType;
	PerspViewModeIndex: EViewModeIndex;
	OrthoViewModeIndex: EViewModeIndex;
	EditorShowFlagsString: string;
	GameShowFlagsString: string;
	BufferVisualizationMode: string;
	ExposureSettings: ExposureSettings;
	FOVAngle: number;
	FarViewPlane: number;
	bIsRealtime: boolean;
	bShowFPS: boolean;
	bShowStats: boolean;
	EnabledStats: string[];
}

declare class LevelEditorViewportInstanceSettingsKeyValuePair { 
	ConfigName: string;
	ConfigSettings: LevelEditorViewportInstanceSettings;
}

declare class LevelEditorViewportSettings extends UObject { 
	FlightCameraControlType: EWASDType;
	LandscapeEditorControlType: ELandscapeFoliageEditorControlType;
	FoliageEditorControlType: ELandscapeFoliageEditorControlType;
	bPanMovesCanvas: boolean;
	bCenterZoomAroundCursor: boolean;
	bAllowTranslateRotateZWidget: boolean;
	bClickBSPSelectsBrush: boolean;
	CameraSpeed: number;
	MouseScrollCameraSpeed: number;
	MouseSensitivty: number;
	bInvertMiddleMousePan: boolean;
	bUseAbsoluteTranslation: boolean;
	bLevelStreamingVolumePrevis: boolean;
	bUseUE3OrbitControls: boolean;
	bUsePowerOf2SnapSize: boolean;
	DecimalGridSizes: number[];
	DecimalGridIntervals: number[];
	Pow2GridSizes: number[];
	Pow2GridIntervals: number[];
	CommonRotGridSizes: number[];
	DivisionsOf360RotGridSizes: number[];
	ScalingGridSizes: number[];
	GridEnabled: boolean;
	RotGridEnabled: boolean;
	SnapScaleEnabled: boolean;
	SnapToSurface: SnapToSurfaceSettings;
	bUsePercentageBasedScaling: boolean;
	bEnableLayerSnap: boolean;
	ActiveSnapLayerIndex: number;
	bEnableActorSnap: boolean;
	ActorSnapScale: number;
	ActorSnapDistance: number;
	bSnapVertices: boolean;
	SnapDistance: number;
	CurrentPosGridSize: number;
	CurrentRotGridSize: number;
	CurrentScalingGridSize: number;
	PreserveNonUniformScale: boolean;
	CurrentRotGridMode: ERotationGridMode;
	AspectRatioAxisConstraint: EAspectRatioAxisConstraint;
	bEnableViewportHoverFeedback: boolean;
	bHighlightWithBrackets: boolean;
	bUseLinkedOrthographicViewports: boolean;
	bStrictBoxSelection: boolean;
	bTransparentBoxSelection: boolean;
	bUseSelectionOutline: boolean;
	SelectionHighlightIntensity: number;
	BSPSelectionHighlightIntensity: number;
	HoverHighlightIntensity: number;
	bEnableViewportCameraToUpdateFromPIV: boolean;
	bPreviewSelectedCameras: boolean;
	CameraPreviewSize: number;
	BackgroundDropDistance: number;
	PreviewMeshes: StringAssetReference[];
	BillboardScale: number;
	TransformWidgetSizeAdjustment: number;
	bSaveEngineStats: boolean;
	MeasuringToolUnits: EMeasuringToolUnits;
	PerInstanceSettings: LevelEditorViewportInstanceSettingsKeyValuePair[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelEditorViewportSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelEditorViewportSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditorViewportSettings;
	static C(Other: UObject): LevelEditorViewportSettings;
}

declare class DefaultPhysicsVolume extends PhysicsVolume { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DefaultPhysicsVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DefaultPhysicsVolume;
	static C(Other: UObject): DefaultPhysicsVolume;
}

declare class GameModePrefix { 
	Prefix: string;
	GameMode: string;
}

declare type EVisibilityAggressiveness = string;
declare class LightmassWorldInfoSettings { 
	StaticLightingLevelScale: number;
	NumIndirectLightingBounces: number;
	IndirectLightingQuality: number;
	IndirectLightingSmoothness: number;
	EnvironmentColor: Color;
	EnvironmentIntensity: number;
	EmissiveBoost: number;
	DiffuseBoost: number;
	bUseAmbientOcclusion: boolean;
	bGenerateAmbientOcclusionMaterialMask: boolean;
	DirectIlluminationOcclusionFraction: number;
	IndirectIlluminationOcclusionFraction: number;
	OcclusionExponent: number;
	FullyOccludedSamplesFraction: number;
	MaxOcclusionDistance: number;
	bVisualizeMaterialDiffuse: boolean;
	bVisualizeAmbientOcclusion: boolean;
	VolumeLightSamplePlacementScale: number;
	bCompressLightmaps: boolean;
}

declare type ELightingBuildQuality = string;
declare type ReverbPreset = string;
declare class ReverbSettings { 
	bApplyReverb: boolean;
	ReverbType: ReverbPreset;
	ReverbEffect: ReverbEffect;
	Volume: number;
	FadeTime: number;
}

declare class InteriorSettings { 
	bIsWorldSettings: boolean;
	ExteriorVolume: number;
	ExteriorTime: number;
	ExteriorLPF: number;
	ExteriorLPFTime: number;
	InteriorVolume: number;
	InteriorTime: number;
	InteriorLPF: number;
	InteriorLPFTime: number;
}

declare class MeshProxySettings { 
	ScreenSize: number;
	Material: MaterialSimplificationSettings;
	TextureWidth: number;
	TextureHeight: number;
	bExportNormalMap: boolean;
	bExportMetallicMap: boolean;
	bExportRoughnessMap: boolean;
	bExportSpecularMap: boolean;
	bRecalculateNormals: boolean;
	HardAngleThreshold: number;
	MergeDistance: number;
	bUseClippingPlane: boolean;
	ClippingLevel: number;
	AxisIndex: number;
	bPlaneNegativeHalfspace: boolean;
}

declare class MeshMergingSettings { 
	bGenerateLightMapUV: boolean;
	TargetLightMapUVChannel: number;
	TargetLightMapResolution: number;
	bImportVertexColors: boolean;
	bPivotPointAtZero: boolean;
	bMergePhysicsData: boolean;
	bMergeMaterials: boolean;
	bExportNormalMap: boolean;
	bExportMetallicMap: boolean;
	bExportRoughnessMap: boolean;
	bExportSpecularMap: boolean;
	MergedMaterialAtlasResolution: number;
}

declare class HierarchicalSimplification { 
	bSimplifyMesh: boolean;
	DrawDistance: number;
	DesiredBoundRadius: number;
	DesiredFillingPercentage: number;
	MinNumberOfActorsToBuild: number;
	ProxySetting: MeshProxySettings;
	MergeSetting: MeshMergingSettings;
}

declare class BookMark extends UObject { 
	Location: Vector;
	Rotation: Rotator;
	HiddenLevels: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BookMark;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BookMark;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BookMark;
	static C(Other: UObject): BookMark;
}

declare class NetViewer { 
	InViewer: Actor;
	ViewTarget: Actor;
	ViewLocation: Vector;
	ViewDir: Vector;
}

declare class WorldSettings extends Info { 
	bEnableWorldBoundsChecks: boolean;
	bEnableNavigationSystem: boolean;
	bEnableWorldComposition: boolean;
	bEnableWorldOriginRebasing: boolean;
	bWorldGravitySet: boolean;
	bGlobalGravitySet: boolean;
	KillZ: number;
	KillZDamageType: UnrealEngineClass;
	WorldGravityZ: number;
	GlobalGravityZ: number;
	DefaultPhysicsVolumeClass: UnrealEngineClass;
	PhysicsCollisionHandlerClass: UnrealEngineClass;
	DefaultGameMode: UnrealEngineClass;
	DefaultMapPrefixes: GameModePrefix[];
	GameNetworkManagerClass: UnrealEngineClass;
	PackedLightAndShadowMapTextureSize: number;
	bMinimizeBSPSections: boolean;
	DefaultColorScale: Vector;
	bPrecomputeVisibility: boolean;
	bPlaceCellsOnlyAlongCameraTracks: boolean;
	VisibilityCellSize: number;
	VisibilityAggressiveness: EVisibilityAggressiveness;
	bForceNoPrecomputedLighting: boolean;
	LightmassSettings: LightmassWorldInfoSettings;
	LevelLightingQuality: ELightingBuildQuality;
	DefaultReverbSettings: ReverbSettings;
	DefaultAmbientZoneSettings: InteriorSettings;
	DefaultBaseSoundMix: SoundMix;
	bEnableHierarchicalLODSystem: boolean;
	HierarchicalLODSetup: HierarchicalSimplification[];
	WorldToMeters: number;
	BookMarks: BookMark;
	TimeDilation: number;
	MatineeTimeDilation: number;
	DemoPlayTimeDilation: number;
	Pauser: PlayerState;
	bHighPriorityLoading: boolean;
	bHighPriorityLoadingLocal: boolean;
	ReplicationViewers: NetViewer[];
	AssetUserData: AssetUserData[];
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WorldSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldSettings;
	static C(Other: UObject): WorldSettings;
	OnRep_WorldGravityZ(): void;
}

declare class GameUserSettings extends UObject { 
	bUseVSync: boolean;
	ResolutionSizeX: any;
	ResolutionSizeY: any;
	LastUserConfirmedResolutionSizeX: any;
	LastUserConfirmedResolutionSizeY: any;
	WindowPosX: number;
	WindowPosY: number;
	bUseDesktopResolutionForFullscreen: boolean;
	FullscreenMode: number;
	LastConfirmedFullscreenMode: number;
	Version: any;
	AudioQualityLevel: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameUserSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameUserSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameUserSettings;
	static C(Other: UObject): GameUserSettings;
}

declare class StatColorMapEntry { 
	In: number;
	Out: Color;
}

declare class StatColorMapping { 
	StatName: string;
	ColorMap: StatColorMapEntry[];
	DisableBlend: boolean;
}

declare class GameNameRedirect { 
	OldGameName: string;
	NewGameName: string;
}

declare class ClassRedirect { 
	ObjectName: string;
	OldClassName: string;
	NewClassName: string;
	OldSubobjName: string;
	NewSubobjName: string;
	InstanceOnly: boolean;
}

declare class PluginRedirect { 
	OldPluginName: string;
	NewPluginName: string;
}

declare class StructRedirect { 
	OldStructName: string;
	NewStructName: string;
}

declare class FloatRangeBound { 
	Type: ERangeBoundTypes;
	Value: number;
}

declare class FloatRange { 
	LowerBound: FloatRangeBound;
	UpperBound: FloatRangeBound;
}

declare type ETransitionType = string;
declare class DropNoteInfo { 
	Location: Vector;
	Rotation: Rotator;
	Comment: string;
}

declare class RigidBodyErrorCorrection { 
	LinearDeltaThresholdSq: number;
	LinearInterpAlpha: number;
	LinearRecipFixTime: number;
	AngularDeltaThreshold: number;
	AngularInterpAlpha: number;
	AngularRecipFixTime: number;
	BodySpeedThresholdSq: number;
}

declare class NetDriverDefinition { 
	DefName: string;
	DriverClassName: string;
	DriverClassNameFallback: string;
}

declare class Engine extends UObject { 
	TinyFont: Font;
	TinyFontName: StringAssetReference;
	SmallFont: Font;
	SmallFontName: StringAssetReference;
	MediumFont: Font;
	MediumFontName: StringAssetReference;
	LargeFont: Font;
	LargeFontName: StringAssetReference;
	SubtitleFont: Font;
	SubtitleFontName: StringAssetReference;
	AdditionalFonts: Font[];
	AdditionalFontNames: string[];
	ConsoleClass: UnrealEngineClass;
	ConsoleClassName: StringClassReference;
	GameViewportClientClass: UnrealEngineClass;
	GameViewportClientClassName: StringClassReference;
	LocalPlayerClass: UnrealEngineClass;
	LocalPlayerClassName: StringClassReference;
	WorldSettingsClass: UnrealEngineClass;
	WorldSettingsClassName: StringClassReference;
	NavigationSystemClassName: StringClassReference;
	NavigationSystemClass: UnrealEngineClass;
	AvoidanceManagerClassName: StringClassReference;
	AvoidanceManagerClass: UnrealEngineClass;
	PhysicsCollisionHandlerClass: UnrealEngineClass;
	PhysicsCollisionHandlerClassName: StringClassReference;
	GameUserSettingsClassName: StringClassReference;
	GameUserSettingsClass: UnrealEngineClass;
	AIControllerClassName: StringClassReference;
	GameUserSettings: GameUserSettings;
	LevelScriptActorClass: UnrealEngineClass;
	LevelScriptActorClassName: StringClassReference;
	DefaultBlueprintBaseClassName: StringClassReference;
	GameSingletonClassName: StringClassReference;
	GameSingleton: UObject;
	DefaultTireType: TireType;
	DefaultTireTypeName: StringAssetReference;
	DefaultPreviewPawnClass: UnrealEngineClass;
	DefaultPreviewPawnClassName: StringClassReference;
	PlayOnConsoleSaveDir: string;
	DefaultTexture: Texture2D;
	DefaultTextureName: StringAssetReference;
	DefaultDiffuseTexture: Texture;
	DefaultDiffuseTextureName: StringAssetReference;
	DefaultBSPVertexTexture: Texture2D;
	DefaultBSPVertexTextureName: StringAssetReference;
	HighFrequencyNoiseTexture: Texture2D;
	HighFrequencyNoiseTextureName: StringAssetReference;
	DefaultBokehTexture: Texture2D;
	DefaultBokehTextureName: StringAssetReference;
	WireframeMaterial: Material;
	WireframeMaterialName: string;
	GeomMaterial: Material;
	GeomMaterialName: StringAssetReference;
	DebugMeshMaterial: Material;
	DebugMeshMaterialName: StringAssetReference;
	LevelColorationLitMaterial: Material;
	LevelColorationLitMaterialName: string;
	LevelColorationUnlitMaterial: Material;
	LevelColorationUnlitMaterialName: string;
	LightingTexelDensityMaterial: Material;
	LightingTexelDensityName: string;
	ShadedLevelColorationLitMaterial: Material;
	ShadedLevelColorationLitMaterialName: string;
	ShadedLevelColorationUnlitMaterial: Material;
	ShadedLevelColorationUnlitMaterialName: string;
	RemoveSurfaceMaterial: Material;
	RemoveSurfaceMaterialName: StringAssetReference;
	VertexColorMaterial: Material;
	VertexColorMaterialName: string;
	VertexColorViewModeMaterial_ColorOnly: Material;
	VertexColorViewModeMaterialName_ColorOnly: string;
	VertexColorViewModeMaterial_AlphaAsColor: Material;
	VertexColorViewModeMaterialName_AlphaAsColor: string;
	VertexColorViewModeMaterial_RedOnly: Material;
	VertexColorViewModeMaterialName_RedOnly: string;
	VertexColorViewModeMaterial_GreenOnly: Material;
	VertexColorViewModeMaterialName_GreenOnly: string;
	VertexColorViewModeMaterial_BlueOnly: Material;
	VertexColorViewModeMaterialName_BlueOnly: string;
	BoneWeightMaterial: Material;
	BoneWeightMaterialName: StringAssetReference;
	ConstraintLimitMaterial: Material;
	ConstraintLimitMaterialX: MaterialInstanceDynamic;
	ConstraintLimitMaterialY: MaterialInstanceDynamic;
	ConstraintLimitMaterialZ: MaterialInstanceDynamic;
	ConstraintLimitMaterialName: StringAssetReference;
	InvalidLightmapSettingsMaterial: Material;
	InvalidLightmapSettingsMaterialName: StringAssetReference;
	PreviewShadowsIndicatorMaterial: Material;
	PreviewShadowsIndicatorMaterialName: StringAssetReference;
	ArrowMaterial: Material;
	ArrowMaterialName: StringAssetReference;
	LightingOnlyBrightness: LinearColor;
	LightComplexityColors: Color[];
	ShaderComplexityColors: LinearColor[];
	StationaryLightOverlapColors: LinearColor[];
	LODColorationColors: LinearColor[];
	MaxPixelShaderAdditiveComplexityCount: number;
	MaxES2PixelShaderAdditiveComplexityCount: number;
	MinLightMapDensity: number;
	IdealLightMapDensity: number;
	MaxLightMapDensity: number;
	bRenderLightMapDensityGrayscale: boolean;
	RenderLightMapDensityGrayscaleScale: number;
	RenderLightMapDensityColorScale: number;
	LightMapDensityVertexMappedColor: LinearColor;
	LightMapDensitySelectedColor: LinearColor;
	StatColorMappings: StatColorMapping[];
	EditorBrushMaterial: Material;
	EditorBrushMaterialName: StringAssetReference;
	DefaultPhysMaterial: PhysicalMaterial;
	DefaultPhysMaterialName: StringAssetReference;
	ActiveGameNameRedirects: GameNameRedirect[];
	ActiveClassRedirects: ClassRedirect[];
	ActivePluginRedirects: PluginRedirect[];
	ActiveStructRedirects: StructRedirect[];
	PreIntegratedSkinBRDFTexture: Texture2D;
	PreIntegratedSkinBRDFTextureName: StringAssetReference;
	MiniFontTexture: Texture2D;
	MiniFontTextureName: StringAssetReference;
	WeightMapPlaceholderTexture: Texture;
	WeightMapPlaceholderTextureName: StringAssetReference;
	LightMapDensityTexture: Texture2D;
	LightMapDensityTextureName: StringAssetReference;
	GameViewport: GameViewportClient;
	DeferredCommands: string[];
	TickCycles: number;
	GameCycles: number;
	ClientCycles: number;
	NearClipPlane: number;
	bHardwareSurveyEnabled: boolean;
	bSubtitlesEnabled: boolean;
	bSubtitlesForcedOff: boolean;
	MaximumLoopIterationCount: number;
	bCanBlueprintsTickByDefault: boolean;
	bEnableEditorPSysRealtimeLOD: boolean;
	bSmoothFrameRate: boolean;
	bUseFixedFrameRate: boolean;
	FixedFrameRate: number;
	SmoothedFrameRateRange: FloatRange;
	bCheckForMultiplePawnsSpawnedInAFrame: boolean;
	NumPawnsAllowedToBeSpawnedInAFrame: number;
	bShouldGenerateLowQualityLightmaps: boolean;
	C_WorldBox: Color;
	C_BrushWire: Color;
	C_AddWire: Color;
	C_SubtractWire: Color;
	C_SemiSolidWire: Color;
	C_NonSolidWire: Color;
	C_WireBackground: Color;
	C_ScaleBoxHi: Color;
	C_VolumeCollision: Color;
	C_BSPCollision: Color;
	C_OrthoBackground: Color;
	C_Volume: Color;
	C_BrushShape: Color;
	StreamingDistanceFactor: number;
	TransitionType: ETransitionType;
	TransitionDescription: string;
	TransitionGameMode: string;
	MeshLODRange: number;
	bAllowMatureLanguage: boolean;
	CameraRotationThreshold: number;
	CameraTranslationThreshold: number;
	PrimitiveProbablyVisibleTime: number;
	MaxOcclusionPixelsFraction: number;
	bPauseOnLossOfFocus: boolean;
	MaxParticleResize: number;
	MaxParticleResizeWarn: number;
	PendingDroppedNotes: DropNoteInfo[];
	PhysicErrorCorrection: RigidBodyErrorCorrection;
	NetClientTicksPerSecond: number;
	bHasPendingGlobalReregister: boolean;
	DisplayGamma: number;
	MinDesiredFrameRate: number;
	DefaultSelectedMaterialColor: LinearColor;
	SelectedMaterialColor: LinearColor;
	SelectionOutlineColor: LinearColor;
	SubduedSelectionOutlineColor: LinearColor;
	SelectedMaterialColorOverride: LinearColor;
	bIsOverridingSelectedColor: boolean;
	bEnableOnScreenDebugMessages: boolean;
	bEnableOnScreenDebugMessagesDisplay: boolean;
	bSuppressMapWarnings: boolean;
	bCookSeparateSharedMPGameContent: boolean;
	bDisableAILogging: boolean;
	bEnableVisualLogRecordingOnStart: any;
	ScreenSaverInhibitorSemaphore: number;
	bLockReadOnlyLevels: boolean;
	ParticleEventManagerClassPath: string;
	SelectionHighlightIntensity: number;
	BSPSelectionHighlightIntensity: number;
	HoverHighlightIntensity: number;
	SelectionHighlightIntensityBillboards: number;
	NetDriverDefinitions: NetDriverDefinition[];
	ServerActors: string[];
	RuntimeServerActors: string[];
	bStartedLoadMapMovie: boolean;
	NextWorldContextHandle: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Engine;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Engine;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Engine;
	static C(Other: UObject): Engine;
	GetEditorWorld(): World;
	GetPIEWorld(): World;
	SetClientTravel(InWorld: World,NextURL: string,InTravelType: ETravelType): void;
}

declare class PIELoginInfo { 
	Type: string;
	Id: string;
	Token: string;
}

declare class EditorEngine extends Engine { 
	TempModel: Model;
	ConversionTempModel: Model;
	Trans: Transactor;
	Bad: Texture2D;
	Bkgnd: Texture2D;
	BkgndHi: Texture2D;
	EditorFont: Font;
	PreviewSoundCue: SoundCue;
	PreviewAudioComponent: AudioComponent;
	EditorCube: StaticMesh;
	EditorSphere: StaticMesh;
	EditorPlane: StaticMesh;
	EditorCylinder: StaticMesh;
	bFastRebuild: boolean;
	IsImportingT3D: boolean;
	ClickFlags: any;
	ParentContext: Package;
	UnsnappedClickLocation: Vector;
	ClickLocation: Vector;
	ClickPlane: Plane;
	MouseMovement: Vector;
	DetailMode: EDetailMode;
	UseSizingBox: boolean;
	UseAxisIndicator: boolean;
	GodMode: boolean;
	GameCommandLine: string;
	bShowBrushMarkerPolys: boolean;
	bEnableSocketSnapping: boolean;
	bEnableLODLocking: boolean;
	bGroupingActive: boolean;
	HeightMapExportClassName: string;
	ActorFactories: ActorFactory[];
	ActorsForGlobalReregister: Actor[];
	UserOpenedFile: string;
	InEditorGameURLOptions: string;
	PlayWorld: World;
	PlayWorldLocation: Vector;
	PlayWorldRotation: Rotator;
	bIsPlayWorldQueued: boolean;
	bIsToggleBetweenPIEandSIEQueued: boolean;
	bIsSimulateInEditorQueued: boolean;
	bAllowMultiplePIEWorlds: boolean;
	PlayFromHerePlayerStartClass: UnrealEngineClass;
	bRequestEndPlayMapQueued: boolean;
	bHasPlayWorldPlacement: boolean;
	bUseMobilePreviewForPlayWorld: boolean;
	bUseVRPreviewForPlayWorld: boolean;
	bIsSimulatingInEditor: boolean;
	EditorWorld: World;
	ActorsThatWereSelected: any[];
	PlayWorldDestination: number;
	CurrentPlayWorldDestination: number;
	bMobilePreviewPortrait: boolean;
	BuildPlayDevice: number;
	bOnlinePIEEnabled: boolean;
	PIELogins: PIELoginInfo[];
	PlayInEditorViewportIndex: number;
	UserEditedPlayWorldURL: string;
	ScratchRenderTarget2048: TextureRenderTarget2D;
	ScratchRenderTarget1024: TextureRenderTarget2D;
	ScratchRenderTarget512: TextureRenderTarget2D;
	ScratchRenderTarget256: TextureRenderTarget2D;
	PreviewMeshComp: StaticMeshComponent;
	PreviewMeshIndex: number;
	bShowPreviewMesh: boolean;
	bCustomCameraAlignEmitter: boolean;
	CustomCameraAlignEmitterDistance: number;
	bDrawSocketsInGMode: boolean;
	bDrawParticleHelpers: boolean;
	BrushBuilders: BrushBuilder[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorEngine;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorEngine;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorEngine;
	static C(Other: UObject): EditorEngine;
	RedrawAllViewports(bInvalidateHitProxies: boolean): void;
}

declare class EditorCommandCategory { 
	Parent: string;
	Name: string;
}

declare class EditorCommand { 
	Parent: string;
	CommandName: string;
	ExecCommand: string;
	Description: string;
}

declare class EditorKeyBinding { 
	bCtrlDown: boolean;
	bAltDown: boolean;
	bShiftDown: boolean;
	Key: Key;
	CommandName: string;
}

declare class UnrealEdKeyBindings extends UObject { 
	KeyBindings: EditorKeyBinding[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UnrealEdKeyBindings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UnrealEdKeyBindings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UnrealEdKeyBindings;
	static C(Other: UObject): UnrealEdKeyBindings;
}

declare class ClassPickerDefaults { 
	ClassName: string;
	AssetClass: string;
}

declare class UnrealEdOptions extends UObject { 
	EditorCategories: EditorCommandCategory[];
	EditorCommands: EditorCommand[];
	EditorKeyBindings: UnrealEdKeyBindings;
	bExpandClassPickerClassList: boolean;
	NewAssetDefaultClasses: ClassPickerDefaults[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UnrealEdOptions;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UnrealEdOptions;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UnrealEdOptions;
	static C(Other: UObject): UnrealEdOptions;
}

declare class TemplateMapInfo { 
	ThumbnailTexture: Texture2D;
	Map: string;
}

declare class UnrealEdEngine extends EditorEngine { 
	EditorOptionsInst: UnrealEdOptions;
	AutoReimportManager: AutoReimportManager;
	MaterialCopyPasteBuffer: Material;
	MatineeCopyPasteBuffer: UObject[];
	SoundCueCopyPasteBuffer: SoundCue;
	AnimationCompressionAlgorithms: AnimCompress[];
	PackagesToBeFullyLoadedAtStartup: string[];
	CurrentLODParentActor: Actor;
	bNeedToPromptForCheckout: boolean;
	bNeedWarningForPkgEngineVer: boolean;
	bNeedWarningForWritePermission: boolean;
	SortedSpriteCategories: string[];
	TemplateMapInfos: TemplateMapInfo[];
	CookServer: CookOnTheFlyServer;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UnrealEdEngine;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UnrealEdEngine;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UnrealEdEngine;
	static C(Other: UObject): UnrealEdEngine;
}

declare type EConsoleForGamepadLabels = string;
declare class EditorExperimentalSettings extends UObject { 
	bProceduralFoliage: boolean;
	bEnableLocalizationDashboard: boolean;
	bEnableTranslationPicker: boolean;
	bEnableEditorUtilityBlueprints: boolean;
	bUnifiedBlueprintEditor: boolean;
	bBlueprintableComponents: boolean;
	bMessagingDebugger: boolean;
	bActorMerging: boolean;
	bDeviceOutputLog: boolean;
	ConsoleForGamepadLabels: EConsoleForGamepadLabels;
	bToolbarCustomization: boolean;
	bBreakOnExceptions: boolean;
	bDrawMidpointArrowsInBlueprints: boolean;
	bShowAudioStreamingOptions: boolean;
	bContextMenuChunkAssignments: boolean;
	bDisableCookInEditor: boolean;
	bIterativeCookingForLaunchOn: boolean;
	bEQSEditor: boolean;
	bFeatureLevelES31Preview: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorExperimentalSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorExperimentalSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorExperimentalSettings;
	static C(Other: UObject): EditorExperimentalSettings;
}

declare type ELoadLevelAtStartup = string;
declare class AutoReimportWildcard { 
	Wildcard: string;
	bInclude: boolean;
}

declare class AutoReimportDirectoryConfig { 
	SourceDirectory: string;
	MountPoint: string;
	Wildcards: AutoReimportWildcard[];
}

declare class FilePath { 
	FilePath: string;
}

declare class EditorLoadingSavingSettings extends UObject { 
	LoadLevelAtStartup: ELoadLevelAtStartup;
	bForceCompilationAtStartup: boolean;
	bRestoreOpenAssetTabsOnRestart: boolean;
	bEnableSourceControlCompatabilityCheck: boolean;
	bMonitorContentDirectories: boolean;
	AutoReimportDirectories: string[];
	AutoReimportDirectorySettings: AutoReimportDirectoryConfig[];
	AutoReimportThreshold: number;
	bAutoCreateAssets: boolean;
	bAutoDeleteAssets: boolean;
	bDetectChangesOnRestart: boolean;
	bDeleteSourceFilesWithAssets: boolean;
	bAutoReimportTextures: boolean;
	bAutoReimportCSV: boolean;
	bDirtyMigratedBlueprints: boolean;
	bAutoSaveEnable: boolean;
	bAutoSaveMaps: boolean;
	bAutoSaveContent: boolean;
	AutoSaveTimeMinutes: number;
	AutoSaveWarningInSeconds: number;
	bAutomaticallyCheckoutOnAssetModification: boolean;
	bPromptForCheckoutOnAssetModification: boolean;
	bSCCAutoAddNewFiles: boolean;
	bSCCUseGlobalSettings: boolean;
	TextDiffToolPath: FilePath;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorLoadingSavingSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorLoadingSavingSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorLoadingSavingSettings;
	static C(Other: UObject): EditorLoadingSavingSettings;
}

declare class EditorMiscSettings extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorMiscSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorMiscSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorMiscSettings;
	static C(Other: UObject): EditorMiscSettings;
}

declare class EditorParentPlayerListObj extends UObject { 
	Overrides: AnimParentNodeAssetOverride[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorParentPlayerListObj;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorParentPlayerListObj;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorParentPlayerListObj;
	static C(Other: UObject): EditorParentPlayerListObj;
}

declare type EUnit = string;
declare type EUnitDisplay = string;
declare type EDefaultLocationUnit = string;
declare class EditorProjectAppearanceSettings extends DeveloperSettings { 
	bDisplayUnits: boolean;
	DistanceUnits: EUnit[];
	MassUnits: EUnit[];
	TimeUnits: EUnit[];
	AngleUnits: EUnit;
	SpeedUnits: EUnit;
	TemperatureUnits: EUnit;
	ForceUnits: EUnit;
	UnitDisplay: EUnitDisplay;
	DefaultInputUnits: EDefaultLocationUnit;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorProjectAppearanceSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorProjectAppearanceSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorProjectAppearanceSettings;
	static C(Other: UObject): EditorProjectAppearanceSettings;
}

declare type ELevelEditor2DAxis = string;
declare class Mode2DLayer { 
	Name: string;
	Depth: number;
}

declare class LevelEditor2DSettings extends DeveloperSettings { 
	bEnable2DWidget: boolean;
	bEnableSnapLayers: boolean;
	SnapAxis: ELevelEditor2DAxis;
	SnapLayers: Mode2DLayer[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelEditor2DSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelEditor2DSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditor2DSettings;
	static C(Other: UObject): LevelEditor2DSettings;
}

declare class EditorSettings extends UObject { 
	bLoadTheMostRecentlyLoadedProjectAtStartup: boolean;
	bEditorAnalyticsEnabled: boolean;
	RecentlyOpenedProjectFiles: string[];
	CreatedProjectPaths: string[];
	bCopyStarterContentPreference: boolean;
	CompletedSurveys: Guid[];
	InProgressSurveys: Guid[];
	AutoScalabilityWorkScaleAmount: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorSettings;
	static C(Other: UObject): EditorSettings;
}

declare class EditorSkeletonNotifyObj extends UObject { 
	Name: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorSkeletonNotifyObj;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorSkeletonNotifyObj;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorSkeletonNotifyObj;
	static C(Other: UObject): EditorSkeletonNotifyObj;
}

declare class ExportTextContainer extends UObject { 
	ExportText: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ExportTextContainer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ExportTextContainer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ExportTextContainer;
	static C(Other: UObject): ExportTextContainer;
}

declare class Factory extends UObject { 
	SupportedClass: UnrealEngineClass;
	ContextClass: UnrealEngineClass;
	Formats: string[];
	bCreateNew: boolean;
	bEditAfterNew: boolean;
	bEditorImport: boolean;
	bText: boolean;
	ImportPriority: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Factory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Factory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Factory;
	static C(Other: UObject): Factory;
}

declare class AnimBlueprintFactory extends Factory { 
	BlueprintType: EBlueprintType;
	ParentClass: UnrealEngineClass;
	TargetSkeleton: Skeleton;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimBlueprintFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimBlueprintFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintFactory;
	static C(Other: UObject): AnimBlueprintFactory;
}

declare class AnimCompositeFactory extends Factory { 
	TargetSkeleton: Skeleton;
	SourceAnimation: AnimSequence;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimCompositeFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimCompositeFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCompositeFactory;
	static C(Other: UObject): AnimCompositeFactory;
}

declare class AnimMontageFactory extends Factory { 
	TargetSkeleton: Skeleton;
	SourceAnimation: AnimSequence;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimMontageFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimMontageFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimMontageFactory;
	static C(Other: UObject): AnimMontageFactory;
}

declare class AnimSequenceFactory extends Factory { 
	TargetSkeleton: Skeleton;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimSequenceFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimSequenceFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSequenceFactory;
	static C(Other: UObject): AnimSequenceFactory;
}

declare class BlendSpaceFactory1D extends Factory { 
	TargetSkeleton: Skeleton;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlendSpaceFactory1D;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlendSpaceFactory1D;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlendSpaceFactory1D;
	static C(Other: UObject): BlendSpaceFactory1D;
}

declare class AimOffsetBlendSpaceFactory1D extends BlendSpaceFactory1D { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AimOffsetBlendSpaceFactory1D;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AimOffsetBlendSpaceFactory1D;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AimOffsetBlendSpaceFactory1D;
	static C(Other: UObject): AimOffsetBlendSpaceFactory1D;
}

declare class BlendSpaceFactoryNew extends Factory { 
	TargetSkeleton: Skeleton;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlendSpaceFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlendSpaceFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlendSpaceFactoryNew;
	static C(Other: UObject): BlendSpaceFactoryNew;
}

declare class AimOffsetBlendSpaceFactoryNew extends BlendSpaceFactoryNew { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AimOffsetBlendSpaceFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AimOffsetBlendSpaceFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AimOffsetBlendSpaceFactoryNew;
	static C(Other: UObject): AimOffsetBlendSpaceFactoryNew;
}

declare class BlueprintFactory extends Factory { 
	ParentClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintFactory;
	static C(Other: UObject): BlueprintFactory;
}

declare class BlueprintFunctionLibraryFactory extends BlueprintFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintFunctionLibraryFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintFunctionLibraryFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintFunctionLibraryFactory;
	static C(Other: UObject): BlueprintFunctionLibraryFactory;
}

declare class BlueprintMacroFactory extends BlueprintFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintMacroFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintMacroFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintMacroFactory;
	static C(Other: UObject): BlueprintMacroFactory;
}

declare class BlueprintInterfaceFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintInterfaceFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintInterfaceFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintInterfaceFactory;
	static C(Other: UObject): BlueprintInterfaceFactory;
}

declare class CameraAnimFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CameraAnimFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CameraAnimFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraAnimFactory;
	static C(Other: UObject): CameraAnimFactory;
}

declare class CSVImportFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CSVImportFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CSVImportFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CSVImportFactory;
	static C(Other: UObject): CSVImportFactory;
}

declare class ReimportCurveFactory extends CSVImportFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReimportCurveFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReimportCurveFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReimportCurveFactory;
	static C(Other: UObject): ReimportCurveFactory;
}

declare class ReimportCurveTableFactory extends CSVImportFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReimportCurveTableFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReimportCurveTableFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReimportCurveTableFactory;
	static C(Other: UObject): ReimportCurveTableFactory;
}

declare class ReimportDataTableFactory extends CSVImportFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReimportDataTableFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReimportDataTableFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReimportDataTableFactory;
	static C(Other: UObject): ReimportDataTableFactory;
}

declare class CurveFactory extends Factory { 
	CurveClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CurveFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CurveFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveFactory;
	static C(Other: UObject): CurveFactory;
}

declare class CurveFloatFactory extends CurveFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CurveFloatFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CurveFloatFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveFloatFactory;
	static C(Other: UObject): CurveFloatFactory;
}

declare class CurveImportFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CurveImportFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CurveImportFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveImportFactory;
	static C(Other: UObject): CurveImportFactory;
}

declare class DataAssetFactory extends Factory { 
	DataAssetClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DataAssetFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DataAssetFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataAssetFactory;
	static C(Other: UObject): DataAssetFactory;
}

declare class DataTableFactory extends Factory { 
	Struct: ScriptStruct;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DataTableFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DataTableFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataTableFactory;
	static C(Other: UObject): DataTableFactory;
}

declare class DestructibleMeshFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DestructibleMeshFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DestructibleMeshFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DestructibleMeshFactory;
	static C(Other: UObject): DestructibleMeshFactory;
}

declare class ReimportDestructibleMeshFactory extends DestructibleMeshFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReimportDestructibleMeshFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReimportDestructibleMeshFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReimportDestructibleMeshFactory;
	static C(Other: UObject): ReimportDestructibleMeshFactory;
}

declare class DialogueVoiceFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DialogueVoiceFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DialogueVoiceFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DialogueVoiceFactory;
	static C(Other: UObject): DialogueVoiceFactory;
}

declare class DialogueWaveFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DialogueWaveFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DialogueWaveFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DialogueWaveFactory;
	static C(Other: UObject): DialogueWaveFactory;
}

declare class EnumFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EnumFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EnumFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnumFactory;
	static C(Other: UObject): EnumFactory;
}

declare type EFBXImportType = string;
declare class FbxAssetImportData extends AssetImportData { 
	ImportTranslation: Vector;
	ImportRotation: Rotator;
	ImportUniformScale: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FbxAssetImportData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FbxAssetImportData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FbxAssetImportData;
	static C(Other: UObject): FbxAssetImportData;
}

declare type EFBXNormalImportMethod = string;
declare type EFBXNormalGenerationMethod = string;
declare class FbxMeshImportData extends FbxAssetImportData { 
	bImportMeshLODs: boolean;
	NormalImportMethod: EFBXNormalImportMethod;
	NormalGenerationMethod: EFBXNormalGenerationMethod;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FbxMeshImportData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FbxMeshImportData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FbxMeshImportData;
	static C(Other: UObject): FbxMeshImportData;
}

declare type EVertexColorImportOption = string;
declare class FbxStaticMeshImportData extends FbxMeshImportData { 
	StaticMeshLODGroup: string;
	VertexColorImportOption: EVertexColorImportOption;
	VertexOverrideColor: Color;
	bRemoveDegenerates: boolean;
	bBuildAdjacencyBuffer: boolean;
	bGenerateLightmapUVs: boolean;
	bOneConvexHullPerUCX: boolean;
	bAutoGenerateCollision: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FbxStaticMeshImportData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FbxStaticMeshImportData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FbxStaticMeshImportData;
	static C(Other: UObject): FbxStaticMeshImportData;
}

declare class FbxSkeletalMeshImportData extends FbxMeshImportData { 
	bUpdateSkeletonReferencePose: boolean;
	bUseT0AsRefPose: boolean;
	bPreserveSmoothingGroups: boolean;
	bImportMeshesInBoneHierarchy: boolean;
	bImportMorphTargets: boolean;
	bKeepOverlappingVertices: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FbxSkeletalMeshImportData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FbxSkeletalMeshImportData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FbxSkeletalMeshImportData;
	static C(Other: UObject): FbxSkeletalMeshImportData;
}

declare type EFBXAnimationLengthImportType = string;
declare class FbxAnimSequenceImportData extends FbxAssetImportData { 
	AnimationLength: EFBXAnimationLengthImportType;
	StartFrame: number;
	EndFrame: number;
	bUseDefaultSampleRate: boolean;
	SourceAnimationName: string;
	bImportCustomAttribute: boolean;
	bPreserveLocalTransform: boolean;
	bDeleteExistingMorphTargetCurves: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FbxAnimSequenceImportData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FbxAnimSequenceImportData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FbxAnimSequenceImportData;
	static C(Other: UObject): FbxAnimSequenceImportData;
}

declare class FbxTextureImportData extends FbxAssetImportData { 
	bInvertNormalMaps: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FbxTextureImportData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FbxTextureImportData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FbxTextureImportData;
	static C(Other: UObject): FbxTextureImportData;
}

declare class FbxImportUI extends UObject { 
	bIsObjImport: boolean;
	OriginalImportType: EFBXImportType;
	MeshTypeToImport: EFBXImportType;
	bOverrideFullName: boolean;
	bConvertScene: boolean;
	bImportAsSkeletal: boolean;
	bImportMesh: boolean;
	bCombineMeshes: boolean;
	Skeleton: Skeleton;
	bCreatePhysicsAsset: boolean;
	PhysicsAsset: PhysicsAsset;
	bImportAnimations: boolean;
	AnimationName: string;
	bImportRigidMesh: boolean;
	bImportMaterials: boolean;
	bImportTextures: boolean;
	StaticMeshImportData: FbxStaticMeshImportData;
	SkeletalMeshImportData: FbxSkeletalMeshImportData;
	AnimSequenceImportData: FbxAnimSequenceImportData;
	TextureImportData: FbxTextureImportData;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FbxImportUI;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FbxImportUI;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FbxImportUI;
	static C(Other: UObject): FbxImportUI;
}

declare class FbxFactory extends Factory { 
	ImportUI: FbxImportUI;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FbxFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FbxFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FbxFactory;
	static C(Other: UObject): FbxFactory;
}

declare class ReimportFbxAnimSequenceFactory extends FbxFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReimportFbxAnimSequenceFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReimportFbxAnimSequenceFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReimportFbxAnimSequenceFactory;
	static C(Other: UObject): ReimportFbxAnimSequenceFactory;
}

declare class ReimportFbxSkeletalMeshFactory extends FbxFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReimportFbxSkeletalMeshFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReimportFbxSkeletalMeshFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReimportFbxSkeletalMeshFactory;
	static C(Other: UObject): ReimportFbxSkeletalMeshFactory;
}

declare class ReimportFbxStaticMeshFactory extends FbxFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReimportFbxStaticMeshFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReimportFbxStaticMeshFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReimportFbxStaticMeshFactory;
	static C(Other: UObject): ReimportFbxStaticMeshFactory;
}

declare class FontFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FontFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FontFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontFactory;
	static C(Other: UObject): FontFactory;
}

declare class FontFileImportFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FontFileImportFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FontFileImportFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontFileImportFactory;
	static C(Other: UObject): FontFileImportFactory;
}

declare class ForceFeedbackEffectFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ForceFeedbackEffectFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ForceFeedbackEffectFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ForceFeedbackEffectFactory;
	static C(Other: UObject): ForceFeedbackEffectFactory;
}

declare class HapticFeedbackEffectFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): HapticFeedbackEffectFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): HapticFeedbackEffectFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HapticFeedbackEffectFactory;
	static C(Other: UObject): HapticFeedbackEffectFactory;
}

declare class InterpDataFactoryNew extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpDataFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpDataFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpDataFactoryNew;
	static C(Other: UObject): InterpDataFactoryNew;
}

declare class LevelFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelFactory;
	static C(Other: UObject): LevelFactory;
}

declare class MaterialFactoryNew extends Factory { 
	InitialTexture: Texture;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialFactoryNew;
	static C(Other: UObject): MaterialFactoryNew;
}

declare class MaterialFunctionFactoryNew extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialFunctionFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialFunctionFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialFunctionFactoryNew;
	static C(Other: UObject): MaterialFunctionFactoryNew;
}

declare class MaterialInstanceConstantFactoryNew extends Factory { 
	InitialParent: MaterialInterface;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialInstanceConstantFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialInstanceConstantFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstanceConstantFactoryNew;
	static C(Other: UObject): MaterialInstanceConstantFactoryNew;
}

declare class MaterialParameterCollectionFactoryNew extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialParameterCollectionFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialParameterCollectionFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialParameterCollectionFactoryNew;
	static C(Other: UObject): MaterialParameterCollectionFactoryNew;
}

declare class ModelFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ModelFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ModelFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ModelFactory;
	static C(Other: UObject): ModelFactory;
}

declare class NiagaraEffectFactoryNew extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraEffectFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraEffectFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraEffectFactoryNew;
	static C(Other: UObject): NiagaraEffectFactoryNew;
}

declare class NiagaraScriptFactoryNew extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraScriptFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraScriptFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraScriptFactoryNew;
	static C(Other: UObject): NiagaraScriptFactoryNew;
}

declare class ObjectLibraryFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ObjectLibraryFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ObjectLibraryFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectLibraryFactory;
	static C(Other: UObject): ObjectLibraryFactory;
}

declare class PackageFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PackageFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PackageFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PackageFactory;
	static C(Other: UObject): PackageFactory;
}

declare class PackFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PackFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PackFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PackFactory;
	static C(Other: UObject): PackFactory;
}

declare class ParticleSystemFactoryNew extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleSystemFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleSystemFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleSystemFactoryNew;
	static C(Other: UObject): ParticleSystemFactoryNew;
}

declare class PhysicalMaterialFactoryNew extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PhysicalMaterialFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PhysicalMaterialFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicalMaterialFactoryNew;
	static C(Other: UObject): PhysicalMaterialFactoryNew;
}

declare class PolysFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PolysFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PolysFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PolysFactory;
	static C(Other: UObject): PolysFactory;
}

declare class ReverbEffectFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReverbEffectFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReverbEffectFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReverbEffectFactory;
	static C(Other: UObject): ReverbEffectFactory;
}

declare class SkeletonFactory extends Factory { 
	TargetSkeletalMesh: SkeletalMesh;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SkeletonFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SkeletonFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletonFactory;
	static C(Other: UObject): SkeletonFactory;
}

declare class SlateBrushAssetFactory extends Factory { 
	InitialTexture: Texture2D;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SlateBrushAssetFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SlateBrushAssetFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateBrushAssetFactory;
	static C(Other: UObject): SlateBrushAssetFactory;
}

declare class SlateWidgetStyleAssetFactory extends Factory { 
	StyleType: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SlateWidgetStyleAssetFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SlateWidgetStyleAssetFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateWidgetStyleAssetFactory;
	static C(Other: UObject): SlateWidgetStyleAssetFactory;
}

declare class SoundAttenuationFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundAttenuationFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundAttenuationFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundAttenuationFactory;
	static C(Other: UObject): SoundAttenuationFactory;
}

declare class SoundClassFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundClassFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundClassFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundClassFactory;
	static C(Other: UObject): SoundClassFactory;
}

declare class SoundCueFactoryNew extends Factory { 
	InitialSoundWave: SoundWave;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundCueFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundCueFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCueFactoryNew;
	static C(Other: UObject): SoundCueFactoryNew;
}

declare class SoundFactory extends Factory { 
	bAutoCreateCue: boolean;
	bIncludeAttenuationNode: boolean;
	bIncludeLoopingNode: boolean;
	bIncludeModulatorNode: boolean;
	CueVolume: number;
	CuePackageSuffix: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundFactory;
	static C(Other: UObject): SoundFactory;
}

declare class ReimportSoundFactory extends SoundFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReimportSoundFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReimportSoundFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReimportSoundFactory;
	static C(Other: UObject): ReimportSoundFactory;
}

declare class SoundMixFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundMixFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundMixFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundMixFactory;
	static C(Other: UObject): SoundMixFactory;
}

declare class SoundSurroundFactory extends Factory { 
	CueVolume: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundSurroundFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundSurroundFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSurroundFactory;
	static C(Other: UObject): SoundSurroundFactory;
}

declare class ReimportSoundSurroundFactory extends SoundSurroundFactory { 
	ReimportPaths: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReimportSoundSurroundFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReimportSoundSurroundFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReimportSoundSurroundFactory;
	static C(Other: UObject): ReimportSoundSurroundFactory;
}

declare class StructureFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): StructureFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): StructureFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StructureFactory;
	static C(Other: UObject): StructureFactory;
}

declare class SubsurfaceProfileFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SubsurfaceProfileFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SubsurfaceProfileFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubsurfaceProfileFactory;
	static C(Other: UObject): SubsurfaceProfileFactory;
}

declare class Texture2DFactoryNew extends Factory { 
	Width: number;
	Height: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Texture2DFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Texture2DFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Texture2DFactoryNew;
	static C(Other: UObject): Texture2DFactoryNew;
}

declare class TextureFactory extends Factory { 
	NoCompression: boolean;
	NoAlpha: boolean;
	bDeferCompression: boolean;
	CompressionSettings: TextureCompressionSettings;
	bCreateMaterial: boolean;
	bRGBToBaseColor: boolean;
	bRGBToEmissive: boolean;
	bAlphaToRoughness: boolean;
	bAlphaToEmissive: boolean;
	bAlphaToOpacity: boolean;
	bAlphaToOpacityMask: boolean;
	bTwoSided: boolean;
	Blending: EBlendMode;
	ShadingModel: EMaterialShadingModel;
	MipGenSettings: TextureMipGenSettings;
	LODGroup: TextureGroup;
	bDitherMipMapAlpha: boolean;
	bPreserveBorder: boolean;
	bFlipNormalMapGreenChannel: boolean;
	bUsingExistingSettings: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextureFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextureFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureFactory;
	static C(Other: UObject): TextureFactory;
}

declare class ReimportTextureFactory extends TextureFactory { 
	pOriginalTex: Texture;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReimportTextureFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReimportTextureFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReimportTextureFactory;
	static C(Other: UObject): ReimportTextureFactory;
}

declare class FontImportOptions extends UObject { 
	Data: FontImportOptionsData;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FontImportOptions;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FontImportOptions;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontImportOptions;
	static C(Other: UObject): FontImportOptions;
}

declare class TrueTypeFontFactory extends TextureFactory { 
	ImportOptions: FontImportOptions;
	bPropertiesConfigured: boolean;
	bFontSelected: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TrueTypeFontFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TrueTypeFontFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TrueTypeFontFactory;
	static C(Other: UObject): TrueTypeFontFactory;
}

declare class TextureRenderTargetCubeFactoryNew extends Factory { 
	Width: number;
	Format: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextureRenderTargetCubeFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextureRenderTargetCubeFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureRenderTargetCubeFactoryNew;
	static C(Other: UObject): TextureRenderTargetCubeFactoryNew;
}

declare class TextureRenderTargetFactoryNew extends Factory { 
	Width: number;
	Height: number;
	Format: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextureRenderTargetFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextureRenderTargetFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureRenderTargetFactoryNew;
	static C(Other: UObject): TextureRenderTargetFactoryNew;
}

declare class TouchInterfaceFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TouchInterfaceFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TouchInterfaceFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TouchInterfaceFactory;
	static C(Other: UObject): TouchInterfaceFactory;
}

declare class VectorFieldStaticFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VectorFieldStaticFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VectorFieldStaticFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VectorFieldStaticFactory;
	static C(Other: UObject): VectorFieldStaticFactory;
}

declare class ReimportVectorFieldStaticFactory extends VectorFieldStaticFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReimportVectorFieldStaticFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReimportVectorFieldStaticFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReimportVectorFieldStaticFactory;
	static C(Other: UObject): ReimportVectorFieldStaticFactory;
}

declare class WorldFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WorldFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WorldFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldFactory;
	static C(Other: UObject): WorldFactory;
}

declare class FileServerCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FileServerCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FileServerCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FileServerCommandlet;
	static C(Other: UObject): FileServerCommandlet;
}

declare class FixupRedirectsCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FixupRedirectsCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FixupRedirectsCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FixupRedirectsCommandlet;
	static C(Other: UObject): FixupRedirectsCommandlet;
}

declare class GatherTextCommandletBase extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GatherTextCommandletBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GatherTextCommandletBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GatherTextCommandletBase;
	static C(Other: UObject): GatherTextCommandletBase;
}

declare class GatherTextCommandlet extends GatherTextCommandletBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GatherTextCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GatherTextCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GatherTextCommandlet;
	static C(Other: UObject): GatherTextCommandlet;
}

declare class GatherTextFromAssetsCommandlet extends GatherTextCommandletBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GatherTextFromAssetsCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GatherTextFromAssetsCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GatherTextFromAssetsCommandlet;
	static C(Other: UObject): GatherTextFromAssetsCommandlet;
}

declare class GatherTextFromMetaDataCommandlet extends GatherTextCommandletBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GatherTextFromMetaDataCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GatherTextFromMetaDataCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GatherTextFromMetaDataCommandlet;
	static C(Other: UObject): GatherTextFromMetaDataCommandlet;
}

declare class GatherTextFromSourceCommandlet extends GatherTextCommandletBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GatherTextFromSourceCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GatherTextFromSourceCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GatherTextFromSourceCommandlet;
	static C(Other: UObject): GatherTextFromSourceCommandlet;
}

declare class GenerateGatherArchiveCommandlet extends GatherTextCommandletBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GenerateGatherArchiveCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GenerateGatherArchiveCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GenerateGatherArchiveCommandlet;
	static C(Other: UObject): GenerateGatherArchiveCommandlet;
}

declare class GenerateGatherManifestCommandlet extends GatherTextCommandletBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GenerateGatherManifestCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GenerateGatherManifestCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GenerateGatherManifestCommandlet;
	static C(Other: UObject): GenerateGatherManifestCommandlet;
}

declare class GenerateTextLocalizationReportCommandlet extends GatherTextCommandletBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GenerateTextLocalizationReportCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GenerateTextLocalizationReportCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GenerateTextLocalizationReportCommandlet;
	static C(Other: UObject): GenerateTextLocalizationReportCommandlet;
}

declare class GenerateTextLocalizationResourceCommandlet extends GatherTextCommandletBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GenerateTextLocalizationResourceCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GenerateTextLocalizationResourceCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GenerateTextLocalizationResourceCommandlet;
	static C(Other: UObject): GenerateTextLocalizationResourceCommandlet;
}

declare class InternationalizationConditioningCommandlet extends GatherTextCommandletBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InternationalizationConditioningCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InternationalizationConditioningCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InternationalizationConditioningCommandlet;
	static C(Other: UObject): InternationalizationConditioningCommandlet;
}

declare class InternationalizationExportCommandlet extends GatherTextCommandletBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InternationalizationExportCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InternationalizationExportCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InternationalizationExportCommandlet;
	static C(Other: UObject): InternationalizationExportCommandlet;
}

declare class RepairLocalizationDataCommandlet extends GatherTextCommandletBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): RepairLocalizationDataCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): RepairLocalizationDataCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RepairLocalizationDataCommandlet;
	static C(Other: UObject): RepairLocalizationDataCommandlet;
}

declare class GenerateBlueprintAPICommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GenerateBlueprintAPICommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GenerateBlueprintAPICommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GenerateBlueprintAPICommandlet;
	static C(Other: UObject): GenerateBlueprintAPICommandlet;
}

declare class GenerateDistillFileSetsCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GenerateDistillFileSetsCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GenerateDistillFileSetsCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GenerateDistillFileSetsCommandlet;
	static C(Other: UObject): GenerateDistillFileSetsCommandlet;
}

declare class GroupActor extends Actor { 
	bLocked: boolean;
	GroupActors: Actor[];
	SubGroups: GroupActor[];
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GroupActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GroupActor;
	static C(Other: UObject): GroupActor;
}

declare class HierarchicalLODVolume extends Volume { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): HierarchicalLODVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HierarchicalLODVolume;
	static C(Other: UObject): HierarchicalLODVolume;
}

declare class LevelEditorMiscSettings extends DeveloperSettings { 
	bAutoApplyLightingEnable: boolean;
	bBSPAutoUpdate: boolean;
	bNavigationAutoUpdate: boolean;
	bReplaceRespectsScale: boolean;
	bAllowBackgroundAudio: boolean;
	bEnableRealTimeAudio: boolean;
	EditorVolumeLevel: number;
	bEnableEditorSounds: boolean;
	DefaultLevelStreamingClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelEditorMiscSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelEditorMiscSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditorMiscSettings;
	static C(Other: UObject): LevelEditorMiscSettings;
}

declare class LevelExporterFBX extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelExporterFBX;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelExporterFBX;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelExporterFBX;
	static C(Other: UObject): LevelExporterFBX;
}

declare class LevelExporterLOD extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelExporterLOD;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelExporterLOD;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelExporterLOD;
	static C(Other: UObject): LevelExporterLOD;
}

declare class LevelExporterOBJ extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelExporterOBJ;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelExporterOBJ;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelExporterOBJ;
	static C(Other: UObject): LevelExporterOBJ;
}

declare class LevelExporterSTL extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelExporterSTL;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelExporterSTL;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelExporterSTL;
	static C(Other: UObject): LevelExporterSTL;
}

declare class LevelExporterT3D extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelExporterT3D;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelExporterT3D;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelExporterT3D;
	static C(Other: UObject): LevelExporterT3D;
}

declare class LightmassDebugOptions { 
	bDebugMode: boolean;
	bStatsEnabled: boolean;
	bGatherBSPSurfacesAcrossComponents: boolean;
	CoplanarTolerance: number;
	bUseImmediateImport: boolean;
	bImmediateProcessMappings: boolean;
	bSortMappings: boolean;
	bDumpBinaryFiles: boolean;
	bDebugMaterials: boolean;
	bPadMappings: boolean;
	bDebugPaddings: boolean;
	bOnlyCalcDebugTexelMappings: boolean;
	bUseRandomColors: boolean;
	bColorBordersGreen: boolean;
	bColorByExecutionTime: boolean;
	ExecutionTimeDivisor: number;
}

declare class SwarmDebugOptions { 
	bDistributionEnabled: boolean;
	bForceContentExport: boolean;
	bInitialized: boolean;
}

declare class LightmassOptionsObject extends UObject { 
	DebugSettings: LightmassDebugOptions;
	SwarmSettings: SwarmDebugOptions;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LightmassOptionsObject;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LightmassOptionsObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightmassOptionsObject;
	static C(Other: UObject): LightmassOptionsObject;
}

declare class ListMaterialsUsedWithMeshEmittersCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ListMaterialsUsedWithMeshEmittersCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ListMaterialsUsedWithMeshEmittersCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ListMaterialsUsedWithMeshEmittersCommandlet;
	static C(Other: UObject): ListMaterialsUsedWithMeshEmittersCommandlet;
}

declare class ListStaticMeshesImportedFromSpeedTreesCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ListStaticMeshesImportedFromSpeedTreesCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ListStaticMeshesImportedFromSpeedTreesCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ListStaticMeshesImportedFromSpeedTreesCommandlet;
	static C(Other: UObject): ListStaticMeshesImportedFromSpeedTreesCommandlet;
}

declare class LoadPackageCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LoadPackageCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LoadPackageCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LoadPackageCommandlet;
	static C(Other: UObject): LoadPackageCommandlet;
}

declare class EditorParameterGroup { 
	GroupName: string;
	Parameters: DEditorParameterValue[];
}

declare class MaterialInstanceConstant extends MaterialInstance { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialInstanceConstant;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialInstanceConstant;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstanceConstant;
	static C(Other: UObject): MaterialInstanceConstant;
}

declare class LightmassParameterValue { 
	bOverride: boolean;
}

declare class LightmassBooleanParameterValue extends LightmassParameterValue { 
	ParameterValue: boolean;
}

declare class LightmassScalarParameterValue extends LightmassParameterValue { 
	ParameterValue: number;
}

declare class LightmassParameterizedMaterialSettings { 
	CastShadowAsMasked: LightmassBooleanParameterValue;
	EmissiveBoost: LightmassScalarParameterValue;
	DiffuseBoost: LightmassScalarParameterValue;
	ExportResolutionScale: LightmassScalarParameterValue;
}

declare class MaterialEditorInstanceConstant extends UObject { 
	PhysMaterial: PhysicalMaterial;
	Parent: MaterialInterface;
	ParameterGroups: EditorParameterGroup[];
	RefractionDepthBias: number;
	SubsurfaceProfile: SubsurfaceProfile;
	bOverrideSubsurfaceProfile: boolean;
	bOverrideBaseProperties: boolean;
	BasePropertyOverrides: MaterialInstanceBasePropertyOverrides;
	SourceInstance: MaterialInstanceConstant;
	VisibleExpressions: Guid[];
	LightmassSettings: LightmassParameterizedMaterialSettings;
	bUseOldStyleMICEditorGroups: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialEditorInstanceConstant;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialEditorInstanceConstant;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialEditorInstanceConstant;
	static C(Other: UObject): MaterialEditorInstanceConstant;
}

declare class MaterialEditorMeshComponent extends StaticMeshComponent { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialEditorMeshComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialEditorMeshComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialEditorMeshComponent;
	static C(Other: UObject): MaterialEditorMeshComponent;
}

declare class MaterialEditorOptions extends UObject { 
	bShowGrid: boolean;
	bShowBackground: boolean;
	bHideUnusedConnectors: boolean;
	bRealtimeMaterialViewport: boolean;
	bRealtimeExpressionViewport: boolean;
	bLivePreviewUpdate: boolean;
	bAlwaysRefreshAllPreviews: boolean;
	bUseUnsortedMenus: boolean;
	bShowMobileStats: boolean;
	FavoriteExpressions: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialEditorOptions;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialEditorOptions;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialEditorOptions;
	static C(Other: UObject): MaterialEditorOptions;
}

declare class MaterialGraphNode extends MaterialGraphNode_Base { 
	MaterialExpression: MaterialExpression;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialGraphNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialGraphNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialGraphNode;
	static C(Other: UObject): MaterialGraphNode;
}

declare class MaterialGraphSchema extends EdGraphSchema { 
	PC_Mask: string;
	PC_Required: string;
	PC_Optional: string;
	PC_MaterialInput: string;
	PSC_Red: string;
	PSC_Green: string;
	PSC_Blue: string;
	PSC_Alpha: string;
	ActivePinColor: LinearColor;
	InactivePinColor: LinearColor;
	AlphaPinColor: LinearColor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialGraphSchema;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialGraphSchema;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialGraphSchema;
	static C(Other: UObject): MaterialGraphSchema;
}

declare class ModelExporterT3D extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ModelExporterT3D;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ModelExporterT3D;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ModelExporterT3D;
	static C(Other: UObject): ModelExporterT3D;
}

declare class NiagaraGraph extends EdGraph { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraGraph;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraGraph;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraGraph;
	static C(Other: UObject): NiagaraGraph;
}

declare class NiagaraNode extends EdGraphNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraNode;
	static C(Other: UObject): NiagaraNode;
}

declare class NiagaraNodeConstant extends NiagaraNode { 
	ConstName: string;
	DataType: ENiagaraDataType;
	bNeedsDefault: boolean;
	bExposeToEffectEditor: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraNodeConstant;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraNodeConstant;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraNodeConstant;
	static C(Other: UObject): NiagaraNodeConstant;
}

declare class NiagaraNodeFunctionCall extends NiagaraNode { 
	FunctionScript: NiagaraScript;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraNodeFunctionCall;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraNodeFunctionCall;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraNodeFunctionCall;
	static C(Other: UObject): NiagaraNodeFunctionCall;
}

declare class NiagaraNodeGetAttr extends NiagaraNode { 
	AttrName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraNodeGetAttr;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraNodeGetAttr;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraNodeGetAttr;
	static C(Other: UObject): NiagaraNodeGetAttr;
}

declare class NiagaraNodeInput extends NiagaraNode { 
	Input: NiagaraVariableInfo;
	FloatDefault: number;
	VectorDefault: Vector4;
	MatrixDefault: Matrix;
	DataObjectDefault: NiagaraDataObject;
	bCanBeExposed: boolean;
	bExposeWhenConstant: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraNodeInput;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraNodeInput;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraNodeInput;
	static C(Other: UObject): NiagaraNodeInput;
}

declare class NiagaraNodeOp extends NiagaraNode { 
	OpName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraNodeOp;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraNodeOp;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraNodeOp;
	static C(Other: UObject): NiagaraNodeOp;
}

declare class NiagaraNodeOutput extends NiagaraNode { 
	Outputs: NiagaraVariableInfo[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraNodeOutput;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraNodeOutput;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraNodeOutput;
	static C(Other: UObject): NiagaraNodeOutput;
}

declare class NiagaraNodeOutputUpdate extends NiagaraNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraNodeOutputUpdate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraNodeOutputUpdate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraNodeOutputUpdate;
	static C(Other: UObject): NiagaraNodeOutputUpdate;
}

declare class NiagaraScriptSource extends NiagaraScriptSourceBase { 
	NodeGraph: NiagaraGraph;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraScriptSource;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraScriptSource;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraScriptSource;
	static C(Other: UObject): NiagaraScriptSource;
}

declare class ObjectExporterT3D extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ObjectExporterT3D;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ObjectExporterT3D;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectExporterT3D;
	static C(Other: UObject): ObjectExporterT3D;
}

declare class ParticleSystemAuditCommandlet extends Commandlet { 
	HighSpawnRateOrBurstThreshold: number;
	FarLODDistanceTheshold: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleSystemAuditCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleSystemAuditCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleSystemAuditCommandlet;
	static C(Other: UObject): ParticleSystemAuditCommandlet;
}

declare class PersonaOptions extends UObject { 
	bShowFloor: boolean;
	bShowSky: boolean;
	bShowGrid: boolean;
	bHighlightOrigin: boolean;
	bMuteAudio: boolean;
	ShowMeshStats: number;
	GridSize: number;
	ViewModeIndex: EViewModeIndex;
	ViewportBackgroundColor: LinearColor;
	ViewFOV: number;
	DefaultLocalAxesSelection: any;
	SectionTimingNodeColor: LinearColor;
	NotifyTimingNodeColor: LinearColor;
	BranchingPointTimingNodeColor: LinearColor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PersonaOptions;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PersonaOptions;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PersonaOptions;
	static C(Other: UObject): PersonaOptions;
}

declare class PhATSimOptions extends UObject { 
	PhysicsBlend: number;
	bUpdateJointsFromAnimation: boolean;
	PokePauseTime: number;
	PokeBlendTime: number;
	FloorGap: number;
	GravScale: number;
	MaxFPS: number;
	TimeDilation: number;
	HandleLinearDamping: number;
	HandleLinearStiffness: number;
	HandleAngularDamping: number;
	HandleAngularStiffness: number;
	InterpolationSpeed: number;
	PokeStrength: number;
	bShowConstraintsAsPoints: boolean;
	bShowNamesInHierarchy: boolean;
	ConstraintDrawSize: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PhATSimOptions;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PhATSimOptions;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhATSimOptions;
	static C(Other: UObject): PhATSimOptions;
}

declare class PkgInfoCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PkgInfoCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PkgInfoCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PkgInfoCommandlet;
	static C(Other: UObject): PkgInfoCommandlet;
}

declare class PolysExporterOBJ extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PolysExporterOBJ;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PolysExporterOBJ;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PolysExporterOBJ;
	static C(Other: UObject): PolysExporterOBJ;
}

declare class PolysExporterT3D extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PolysExporterT3D;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PolysExporterT3D;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PolysExporterT3D;
	static C(Other: UObject): PolysExporterT3D;
}

declare class PreviewMaterial extends Material { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PreviewMaterial;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PreviewMaterial;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PreviewMaterial;
	static C(Other: UObject): PreviewMaterial;
}

declare type EProjectPackagingBuildConfigurations = string;
declare class DirectoryPath { 
	Path: string;
}

declare type EProjectPackagingInternationalizationPresets = string;
declare class ProjectPackagingSettings extends UObject { 
	BuildConfiguration: EProjectPackagingBuildConfigurations;
	StagingDirectory: DirectoryPath;
	FullRebuild: boolean;
	ForDistribution: boolean;
	IncludeDebugFiles: boolean;
	UsePakFile: boolean;
	bGenerateChunks: boolean;
	bBuildHttpChunkInstallData: boolean;
	HttpChunkInstallDataDirectory: DirectoryPath;
	HttpChunkInstallDataVersion: string;
	IncludePrerequisites: boolean;
	IncludeCrashReporter: boolean;
	InternationalizationPreset: EProjectPackagingInternationalizationPresets;
	CulturesToStage: string[];
	DefaultCulture: string;
	bCookAll: boolean;
	bCookMapsOnly: boolean;
	bCompressed: boolean;
	MapsToCook: FilePath[];
	DirectoriesToAlwaysCook: DirectoryPath[];
	DirectoriesToAlwaysStageAsUFS: DirectoryPath[];
	DirectoriesToAlwaysStageAsNonUFS: DirectoryPath[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ProjectPackagingSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ProjectPackagingSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProjectPackagingSettings;
	static C(Other: UObject): ProjectPackagingSettings;
}

declare type PropertEditorTestEnum = string;
declare class PropertyEditorTestSubStruct { 
	FirstProperty: number;
	SecondProperty: number;
	CustomizedStructInsideUncustomizedStruct: LinearColor;
	CustomizedStructInsideUncustomizedStruct2: StringAssetReference;
}

declare class PropertyEditorTestBasicStruct { 
	IntPropertyInsideAStruct: number;
	FloatPropertyInsideAStruct: number;
	ObjectPropertyInsideAStruct: UObject;
	InnerStruct: PropertyEditorTestSubStruct;
}

declare class PropertyEditorTestObject extends UObject { 
	Int8Property: any;
	Int16roperty: any;
	Int32Property: number;
	Int64Property: any;
	ByteProperty: number;
	UnsignedInt16Property: any;
	UnsignedInt32Property: any;
	UnsignedInt64Property: any;
	FloatProperty: number;
	NameProperty: string;
	BoolProperty: boolean;
	StringProperty: string;
	TextProperty: string;
	Vector3Property: Vector;
	Vector2Property: Vector2D;
	Vector4Property: Vector4;
	RotatorProperty: Rotator;
	ObjectProperty: UObject;
	ClassProperty: UnrealEngineClass;
	LinearColorProperty: LinearColor;
	ColorProperty: Color;
	EnumProperty: PropertEditorTestEnum;
	IntProperty32Array: number[];
	BytePropertyArray: number[];
	FloatPropertyArray: number[];
	NamePropertyArray: string[];
	BoolPropertyArray: boolean[];
	StringPropertyArray: string[];
	TextPropertyArray: string[];
	Vector3PropertyArray: Vector[];
	Vector2PropertyArray: Vector2D[];
	Vector4PropertyArray: Vector4[];
	RotatorPropertyArray: Rotator[];
	ObjectPropertyArray: UObject[];
	ActorPropertyArray: Actor[];
	LinearColorPropertyArray: LinearColor[];
	ColorPropertyArray: Color[];
	EnumPropertyArray: PropertEditorTestEnum[];
	StructPropertyArray: PropertyEditorTestBasicStruct[];
	FixedArrayOfInts: number[];
	StaticArrayOfInts: number;
	StaticArrayOfIntsWithEnumLabels: number;
	FloatPropertyWithClampedRange: number;
	IntPropertyWithClampedRange: number;
	IntThatCannotBeChanged: number;
	StringThatCannotBeChanged: string;
	ObjectThatCannotBeChanged: PrimitiveComponent;
	ThisIsBrokenIfItsVisibleInADetailsView: PropertyEditorTestBasicStruct;
	StructWithMultipleInstances1: PropertyEditorTestBasicStruct;
	StructWithMultipleInstances2: PropertyEditorTestBasicStruct;
	AssetReferenceCustomStruct: StringAssetReference;
	AssetReferenceCustomStructWithThumbnail: StringAssetReference;
	bEditCondition: boolean;
	SimplePropertyWithEditCondition: number;
	AssetReferenceCustomStructWithEditCondition: StringAssetReference;
	ArrayOfStructs: PropertyEditorTestBasicStruct[];
	EditInlineNewStaticMeshComponent: StaticMeshComponent;
	ArrayOfEditInlineNewSMCs: StaticMeshComponent[];
	TextureProp: Texture;
	StaticMeshProp: StaticMesh;
	AnyMaterialInterface: MaterialInterface;
	OnlyActorsAllowed: Actor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PropertyEditorTestObject;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PropertyEditorTestObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyEditorTestObject;
	static C(Other: UObject): PropertyEditorTestObject;
}

declare class ReplaceActorCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReplaceActorCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReplaceActorCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReplaceActorCommandlet;
	static C(Other: UObject): ReplaceActorCommandlet;
}

declare class ResavePackagesCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ResavePackagesCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ResavePackagesCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ResavePackagesCommandlet;
	static C(Other: UObject): ResavePackagesCommandlet;
}

declare class SceneThumbnailInfo extends ThumbnailInfo { 
	OrbitPitch: number;
	OrbitYaw: number;
	OrbitZoom: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SceneThumbnailInfo;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SceneThumbnailInfo;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneThumbnailInfo;
	static C(Other: UObject): SceneThumbnailInfo;
}

declare class ThumbnailRenderer extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ThumbnailRenderer;
	static C(Other: UObject): ThumbnailRenderer;
}

declare class ThumbnailRenderingInfo { 
	ClassNeedingThumbnailName: string;
	ClassNeedingThumbnail: UnrealEngineClass;
	RendererClassName: string;
	Renderer: ThumbnailRenderer;
}

declare class ThumbnailManager extends UObject { 
	RenderableThumbnailTypes: ThumbnailRenderingInfo[];
	NotSupported: ThumbnailRenderingInfo;
	EditorCube: StaticMesh;
	EditorSphere: StaticMesh;
	EditorCylinder: StaticMesh;
	EditorPlane: StaticMesh;
	EditorSkySphere: StaticMesh;
	FloorPlaneMaterial: Material;
	AmbientCubemap: TextureCube;
	CheckerboardTexture: Texture2D;
	ThumbnailManagerClassName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ThumbnailManager;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ThumbnailManager;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ThumbnailManager;
	static C(Other: UObject): ThumbnailManager;
}

declare type EThumbnailPrimType = string;
declare class SceneThumbnailInfoWithPrimitive extends SceneThumbnailInfo { 
	PrimitiveType: EThumbnailPrimType;
	PreviewMesh: StringAssetReference;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SceneThumbnailInfoWithPrimitive;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SceneThumbnailInfoWithPrimitive;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneThumbnailInfoWithPrimitive;
	static C(Other: UObject): SceneThumbnailInfoWithPrimitive;
}

declare type EOrthoThumbnailDirection = string;
declare class WorldThumbnailInfo extends SceneThumbnailInfo { 
	CameraMode: ECameraProjectionMode;
	OrthoDirection: EOrthoThumbnailDirection;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WorldThumbnailInfo;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WorldThumbnailInfo;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldThumbnailInfo;
	static C(Other: UObject): WorldThumbnailInfo;
}

declare class SequenceExporterT3D extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SequenceExporterT3D;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SequenceExporterT3D;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceExporterT3D;
	static C(Other: UObject): SequenceExporterT3D;
}

declare class SkeletalMeshExporterFBX extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SkeletalMeshExporterFBX;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SkeletalMeshExporterFBX;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMeshExporterFBX;
	static C(Other: UObject): SkeletalMeshExporterFBX;
}

declare class SoundClassGraph extends EdGraph { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundClassGraph;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundClassGraph;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundClassGraph;
	static C(Other: UObject): SoundClassGraph;
}

declare class SoundClassGraphNode extends EdGraphNode { 
	SoundClass: SoundClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundClassGraphNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundClassGraphNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundClassGraphNode;
	static C(Other: UObject): SoundClassGraphNode;
}

declare class SoundClassGraphSchema extends EdGraphSchema { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundClassGraphSchema;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundClassGraphSchema;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundClassGraphSchema;
	static C(Other: UObject): SoundClassGraphSchema;
}

declare class SoundCueGraph extends EdGraph { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundCueGraph;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundCueGraph;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCueGraph;
	static C(Other: UObject): SoundCueGraph;
}

declare class SoundCueGraphNode_Base extends EdGraphNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundCueGraphNode_Base;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundCueGraphNode_Base;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCueGraphNode_Base;
	static C(Other: UObject): SoundCueGraphNode_Base;
}

declare class SoundCueGraphNode extends SoundCueGraphNode_Base { 
	SoundNode: SoundNode;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundCueGraphNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundCueGraphNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCueGraphNode;
	static C(Other: UObject): SoundCueGraphNode;
}

declare class SoundCueGraphNode_Root extends SoundCueGraphNode_Base { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundCueGraphNode_Root;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundCueGraphNode_Root;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCueGraphNode_Root;
	static C(Other: UObject): SoundCueGraphNode_Root;
}

declare class SoundCueGraphSchema extends EdGraphSchema { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundCueGraphSchema;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundCueGraphSchema;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCueGraphSchema;
	static C(Other: UObject): SoundCueGraphSchema;
}

declare class SoundExporterOGG extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundExporterOGG;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundExporterOGG;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundExporterOGG;
	static C(Other: UObject): SoundExporterOGG;
}

declare class SoundExporterWAV extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundExporterWAV;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundExporterWAV;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundExporterWAV;
	static C(Other: UObject): SoundExporterWAV;
}

declare class SoundSurroundExporterWAV extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundSurroundExporterWAV;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundSurroundExporterWAV;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSurroundExporterWAV;
	static C(Other: UObject): SoundSurroundExporterWAV;
}

declare class StaticMeshExporterFBX extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): StaticMeshExporterFBX;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): StaticMeshExporterFBX;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshExporterFBX;
	static C(Other: UObject): StaticMeshExporterFBX;
}

declare class StaticMeshExporterOBJ extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): StaticMeshExporterOBJ;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): StaticMeshExporterOBJ;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshExporterOBJ;
	static C(Other: UObject): StaticMeshExporterOBJ;
}

declare class TemplateMapMetadata extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TemplateMapMetadata;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TemplateMapMetadata;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TemplateMapMetadata;
	static C(Other: UObject): TemplateMapMetadata;
}

declare type ETexAlign = string;
declare class TexAligner extends UObject { 
	DefTexAlign: ETexAlign;
	TAxis: number;
	UTile: number;
	VTile: number;
	Desc: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TexAligner;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TexAligner;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TexAligner;
	static C(Other: UObject): TexAligner;
}

declare class TexAlignerBox extends TexAligner { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TexAlignerBox;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TexAlignerBox;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TexAlignerBox;
	static C(Other: UObject): TexAlignerBox;
}

declare class TexAlignerDefault extends TexAligner { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TexAlignerDefault;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TexAlignerDefault;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TexAlignerDefault;
	static C(Other: UObject): TexAlignerDefault;
}

declare class TexAlignerFit extends TexAligner { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TexAlignerFit;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TexAlignerFit;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TexAlignerFit;
	static C(Other: UObject): TexAlignerFit;
}

declare class TexAlignerPlanar extends TexAligner { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TexAlignerPlanar;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TexAlignerPlanar;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TexAlignerPlanar;
	static C(Other: UObject): TexAlignerPlanar;
}

declare class TextBufferExporterTXT extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextBufferExporterTXT;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextBufferExporterTXT;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBufferExporterTXT;
	static C(Other: UObject): TextBufferExporterTXT;
}

declare class TextureCubeExporterHDR extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextureCubeExporterHDR;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextureCubeExporterHDR;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureCubeExporterHDR;
	static C(Other: UObject): TextureCubeExporterHDR;
}

declare class TextureExporterBMP extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextureExporterBMP;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextureExporterBMP;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureExporterBMP;
	static C(Other: UObject): TextureExporterBMP;
}

declare class TextureExporterHDR extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextureExporterHDR;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextureExporterHDR;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureExporterHDR;
	static C(Other: UObject): TextureExporterHDR;
}

declare class TextureExporterPCX extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextureExporterPCX;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextureExporterPCX;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureExporterPCX;
	static C(Other: UObject): TextureExporterPCX;
}

declare class TextureExporterTGA extends Exporter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextureExporterTGA;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextureExporterTGA;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureExporterTGA;
	static C(Other: UObject): TextureExporterTGA;
}

declare class DefaultSizedThumbnailRenderer extends ThumbnailRenderer { 
	DefaultSizeX: number;
	DefaultSizeY: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DefaultSizedThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DefaultSizedThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DefaultSizedThumbnailRenderer;
	static C(Other: UObject): DefaultSizedThumbnailRenderer;
}

declare class AnimBlueprintThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimBlueprintThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimBlueprintThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintThumbnailRenderer;
	static C(Other: UObject): AnimBlueprintThumbnailRenderer;
}

declare class AnimSequenceThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimSequenceThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimSequenceThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSequenceThumbnailRenderer;
	static C(Other: UObject): AnimSequenceThumbnailRenderer;
}

declare class BlendSpaceThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlendSpaceThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlendSpaceThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlendSpaceThumbnailRenderer;
	static C(Other: UObject): BlendSpaceThumbnailRenderer;
}

declare class BlueprintThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintThumbnailRenderer;
	static C(Other: UObject): BlueprintThumbnailRenderer;
}

declare class ClassThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ClassThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ClassThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassThumbnailRenderer;
	static C(Other: UObject): ClassThumbnailRenderer;
}

declare class DestructibleMeshThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DestructibleMeshThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DestructibleMeshThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DestructibleMeshThumbnailRenderer;
	static C(Other: UObject): DestructibleMeshThumbnailRenderer;
}

declare class LevelThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelThumbnailRenderer;
	static C(Other: UObject): LevelThumbnailRenderer;
}

declare class MaterialFunctionThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialFunctionThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialFunctionThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialFunctionThumbnailRenderer;
	static C(Other: UObject): MaterialFunctionThumbnailRenderer;
}

declare class MaterialInstanceThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialInstanceThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialInstanceThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstanceThumbnailRenderer;
	static C(Other: UObject): MaterialInstanceThumbnailRenderer;
}

declare class SkeletalMeshThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SkeletalMeshThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SkeletalMeshThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMeshThumbnailRenderer;
	static C(Other: UObject): SkeletalMeshThumbnailRenderer;
}

declare class SlateBrushThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SlateBrushThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SlateBrushThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateBrushThumbnailRenderer;
	static C(Other: UObject): SlateBrushThumbnailRenderer;
}

declare class StaticMeshThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): StaticMeshThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): StaticMeshThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshThumbnailRenderer;
	static C(Other: UObject): StaticMeshThumbnailRenderer;
}

declare class WorldThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	GlobalOrbitPitchOffset: number;
	GlobalOrbitYawOffset: number;
	bUseUnlitScene: boolean;
	bAllowWorldThumbnails: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WorldThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WorldThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldThumbnailRenderer;
	static C(Other: UObject): WorldThumbnailRenderer;
}

declare class SoundWaveThumbnailRenderer extends ThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundWaveThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundWaveThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundWaveThumbnailRenderer;
	static C(Other: UObject): SoundWaveThumbnailRenderer;
}

declare class TextureThumbnailRenderer extends ThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextureThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextureThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureThumbnailRenderer;
	static C(Other: UObject): TextureThumbnailRenderer;
}

declare class FontThumbnailRenderer extends TextureThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FontThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FontThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontThumbnailRenderer;
	static C(Other: UObject): FontThumbnailRenderer;
}

declare class ParticleSystemThumbnailRenderer extends TextureThumbnailRenderer { 
	NoImage: Texture2D;
	OutOfDate: Texture2D;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleSystemThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleSystemThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleSystemThumbnailRenderer;
	static C(Other: UObject): ParticleSystemThumbnailRenderer;
}

declare class SubsurfaceProfileRenderer extends TextureThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SubsurfaceProfileRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SubsurfaceProfileRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubsurfaceProfileRenderer;
	static C(Other: UObject): SubsurfaceProfileRenderer;
}

declare class TextureCubeThumbnailRenderer extends TextureThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextureCubeThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextureCubeThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureCubeThumbnailRenderer;
	static C(Other: UObject): TextureCubeThumbnailRenderer;
}

declare class TransBuffer extends Transactor { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TransBuffer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TransBuffer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TransBuffer;
	static C(Other: UObject): TransBuffer;
}

declare class UpdateGameProjectCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UpdateGameProjectCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UpdateGameProjectCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UpdateGameProjectCommandlet;
	static C(Other: UObject): UpdateGameProjectCommandlet;
}

declare class StructVariableDescription { 
	VarName: string;
	VarGuid: Guid;
	FriendlyName: string;
	DefaultValue: string;
	Category: string;
	SubCategory: string;
	SubCategoryObject: any;
	bIsArray: boolean;
	bInvalidMember: boolean;
	CurrentDefaultValue: string;
	ToolTip: string;
	bDontEditoOnInstance: boolean;
	bEnable3dWidget: boolean;
}

declare class UserDefinedStructEditorData extends UObject { 
	UniqueNameId: any;
	VariablesDescriptions: StructVariableDescription[];
	ToolTip: string;
	NativeBase: ScriptStruct;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UserDefinedStructEditorData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UserDefinedStructEditorData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserDefinedStructEditorData;
	static C(Other: UObject): UserDefinedStructEditorData;
}

declare class WrangleContentCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WrangleContentCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WrangleContentCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WrangleContentCommandlet;
	static C(Other: UObject): WrangleContentCommandlet;
}

declare class InstancedStaticMeshInstanceData { 
	Transform: Matrix;
	LightmapUVBias: Vector2D;
	ShadowmapUVBias: Vector2D;
}

declare class PhysicsSerializer extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PhysicsSerializer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PhysicsSerializer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsSerializer;
	static C(Other: UObject): PhysicsSerializer;
}

declare class InstancedStaticMeshMappingInfo { 
}

declare class InstancedStaticMeshComponent extends StaticMeshComponent { 
	PerInstanceSMData: InstancedStaticMeshInstanceData[];
	InstancingRandomSeed: number;
	InstanceStartCullDistance: number;
	InstanceEndCullDistance: number;
	InstanceReorderTable: number[];
	RemovedInstances: number[];
	PhysicsSerializer: PhysicsSerializer;
	NumPendingLightmaps: number;
	CachedMappings: InstancedStaticMeshMappingInfo[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InstancedStaticMeshComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InstancedStaticMeshComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InstancedStaticMeshComponent;
	static C(Other: UObject): InstancedStaticMeshComponent;
	UpdateInstanceTransform(InstanceIndex: number,NewInstanceTransform: Transform,bWorldSpace: boolean,bMarkRenderStateDirty: boolean): boolean;
	SetCullDistances(StartCullDistance: number,EndCullDistance: number): void;
	RemoveInstance(InstanceIndex: number): boolean;
	GetInstanceTransform(InstanceIndex: number,OutInstanceTransform?: Transform,bWorldSpace?: boolean): {OutInstanceTransform: Transform, $: boolean};
	GetInstancesOverlappingSphere(Center: Vector,Radius: number,bSphereInWorldSpace: boolean): number[];
	GetInstanceCount(): number;
	ClearInstances(): void;
	AddInstanceWorldSpace(WorldTransform: Transform): number;
	AddInstance(InstanceTransform: Transform): number;
}

declare class HierarchicalInstancedStaticMeshComponent extends InstancedStaticMeshComponent { 
	SortedInstances: number[];
	NumBuiltInstances: number;
	BuiltInstanceBounds: Box;
	UnbuiltInstanceBounds: Box;
	UnbuiltInstanceBoundsList: Box[];
	OcclusionLayerNumNodes: number;
	bDisableCollision: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): HierarchicalInstancedStaticMeshComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): HierarchicalInstancedStaticMeshComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HierarchicalInstancedStaticMeshComponent;
	static C(Other: UObject): HierarchicalInstancedStaticMeshComponent;
	RemoveInstances(InstancesToRemove: number[]): boolean;
}

declare class FoliageInstancedStaticMeshComponent extends HierarchicalInstancedStaticMeshComponent { 
	OnInstanceTakePointDamage: UnrealEngineMulticastDelegate<(InstanceIndex: number, Damage: number, InstigatedBy: Controller, HitLocation: Vector, ShotFromDirection: Vector, DamageType: DamageType, DamageCauser: Actor) => void>;
	OnInstanceTakeRadialDamage: UnrealEngineMulticastDelegate<(Instances: number[], Damages: number[], InstigatedBy: Controller, Origin: Vector, MaxRadius: number, DamageType: DamageType, DamageCauser: Actor) => void>;
	FoliageHiddenEditorViews: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FoliageInstancedStaticMeshComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FoliageInstancedStaticMeshComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageInstancedStaticMeshComponent;
	static C(Other: UObject): FoliageInstancedStaticMeshComponent;
}

declare class FoliageStatistics extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FoliageStatistics;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FoliageStatistics;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageStatistics;
	static C(Other: UObject): FoliageStatistics;
	static FoliageOverlappingSphereCount(WorldContextObject: UObject,StaticMesh: StaticMesh,CenterPosition: Vector,Radius: number): number;
	static FoliageOverlappingBoxCount(WorldContextObject: UObject,StaticMesh: StaticMesh,Box: Box): number;
}

declare type EFoliageScaling = string;
declare class FloatInterval { 
	Min: number;
	Max: number;
}

declare type FoliageVertexColorMask = string;
declare class Int32Interval { 
	Min: number;
	Max: number;
}

declare class FoliageType extends UObject { 
	UpdateGuid: Guid;
	Density: number;
	DensityAdjustmentFactor: number;
	Radius: number;
	Scaling: EFoliageScaling;
	ScaleX: FloatInterval;
	ScaleY: FloatInterval;
	ScaleZ: FloatInterval;
	VertexColorMask: FoliageVertexColorMask;
	VertexColorMaskThreshold: number;
	VertexColorMaskInvert: boolean;
	ZOffset: FloatInterval;
	AlignToNormal: boolean;
	AlignMaxAngle: number;
	RandomYaw: boolean;
	RandomPitchAngle: number;
	GroundSlopeAngle: FloatInterval;
	Height: FloatInterval;
	LandscapeLayers: string[];
	LandscapeLayer: string;
	CollisionWithWorld: boolean;
	CollisionScale: Vector;
	MinimumLayerWeight: number;
	MeshBounds: BoxSphereBounds;
	LowBoundOriginRadius: Vector;
	Mobility: EComponentMobility;
	CullDistance: Int32Interval;
	bEnableStaticLighting: boolean;
	CastShadow: boolean;
	bAffectDynamicIndirectLighting: boolean;
	bAffectDistanceFieldLighting: boolean;
	bCastDynamicShadow: boolean;
	bCastStaticShadow: boolean;
	bCastShadowAsTwoSided: boolean;
	bReceivesDecals: boolean;
	bOverrideLightMapRes: boolean;
	OverriddenLightMapRes: number;
	bUseAsOccluder: boolean;
	BodyInstance: BodyInstance;
	CustomNavigableGeometry: EHasCustomNavigableGeometry;
	HiddenEditorViews: any;
	IsSelected: boolean;
	CollisionRadius: number;
	ShadeRadius: number;
	NumSteps: number;
	InitialSeedDensity: number;
	AverageSpreadDistance: number;
	SpreadVariance: number;
	SeedsPerStep: number;
	DistributionSeed: number;
	MaxInitialSeedOffset: number;
	bCanGrowInShade: boolean;
	bSpawnsInShade: boolean;
	MaxInitialAge: number;
	MaxAge: number;
	OverlapPriority: number;
	ProceduralScale: FloatInterval;
	ScaleCurve: RuntimeFloatCurve;
	ChangeCount: number;
	ReapplyDensity: boolean;
	ReapplyRadius: boolean;
	ReapplyAlignToNormal: boolean;
	ReapplyRandomYaw: boolean;
	ReapplyScaling: boolean;
	ReapplyScaleX: boolean;
	ReapplyScaleY: boolean;
	ReapplyScaleZ: boolean;
	ReapplyRandomPitchAngle: boolean;
	ReapplyGroundSlope: boolean;
	ReapplyHeight: boolean;
	ReapplyLandscapeLayers: boolean;
	ReapplyZOffset: boolean;
	ReapplyCollisionWithWorld: boolean;
	ReapplyVertexColorMask: boolean;
	ScaleMinX: number;
	ScaleMinY: number;
	ScaleMinZ: number;
	ScaleMaxX: number;
	ScaleMaxY: number;
	ScaleMaxZ: number;
	HeightMin: number;
	HeightMax: number;
	ZOffsetMin: number;
	ZOffsetMax: number;
	StartCullDistance: number;
	EndCullDistance: number;
	UniformScale: boolean;
	LockScaleX: boolean;
	LockScaleY: boolean;
	LockScaleZ: boolean;
	GroundSlope: number;
	MinGroundSlope: number;
	MinScale: number;
	MaxScale: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FoliageType;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FoliageType;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType;
	static C(Other: UObject): FoliageType;
}

declare class FoliageType_InstancedStaticMesh extends FoliageType { 
	Mesh: StaticMesh;
	OverrideMaterials: MaterialInterface[];
	ComponentClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FoliageType_InstancedStaticMesh;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FoliageType_InstancedStaticMesh;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType_InstancedStaticMesh;
	static C(Other: UObject): FoliageType_InstancedStaticMesh;
}

declare class InstancedFoliageActor extends Actor { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InstancedFoliageActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InstancedFoliageActor;
	static C(Other: UObject): InstancedFoliageActor;
}

declare type ENavDataGatheringMode = string;
declare class StaticMeshActor extends Actor { 
	StaticMeshComponent: StaticMeshComponent;
	bStaticMeshReplicateMovement: boolean;
	NavigationGeometryGatheringMode: ENavDataGatheringMode;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): StaticMeshActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshActor;
	static C(Other: UObject): StaticMeshActor;
}

declare class InteractiveFoliageActor extends StaticMeshActor { 
	CapsuleComponent: CapsuleComponent;
	TouchingActorEntryPosition: Vector;
	FoliageVelocity: Vector;
	FoliageForce: Vector;
	FoliagePosition: Vector;
	FoliageDamageImpulseScale: number;
	FoliageTouchImpulseScale: number;
	FoliageStiffness: number;
	FoliageStiffnessQuadratic: number;
	FoliageDamping: number;
	MaxDamageImpulse: number;
	MaxTouchImpulse: number;
	MaxForce: number;
	Mass: number;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InteractiveFoliageActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveFoliageActor;
	static C(Other: UObject): InteractiveFoliageActor;
	CapsuleTouched(Other: Actor,OtherComp: PrimitiveComponent,OtherBodyIndex: number,bFromSweep: boolean,OverlapInfo: HitResult): void;
}

declare class InteractiveFoliageComponent extends StaticMeshComponent { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InteractiveFoliageComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InteractiveFoliageComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveFoliageComponent;
	static C(Other: UObject): InteractiveFoliageComponent;
}

declare class FoliageTypeObject { 
	FoliageTypeObject: UObject;
	TypeInstance: FoliageType_InstancedStaticMesh;
	bIsAsset: boolean;
	Type: UnrealEngineClass;
}

declare class ProceduralFoliageSpawner extends UObject { 
	RandomSeed: number;
	TileSize: number;
	NumUniqueTiles: number;
	FoliageTypes: FoliageTypeObject[];
	bNeedsSimulation: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ProceduralFoliageSpawner;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ProceduralFoliageSpawner;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageSpawner;
	static C(Other: UObject): ProceduralFoliageSpawner;
	Simulate(NumSteps: number): void;
}

declare class ProceduralFoliageComponent extends ActorComponent { 
	FoliageSpawner: ProceduralFoliageSpawner;
	TileOverlap: number;
	bShowDebugTiles: boolean;
	SpawningVolume: Volume;
	ProceduralGuid: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ProceduralFoliageComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ProceduralFoliageComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageComponent;
	static C(Other: UObject): ProceduralFoliageComponent;
}

declare class ProceduralFoliageVolume extends Volume { 
	ProceduralComponent: ProceduralFoliageComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ProceduralFoliageVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageVolume;
	static C(Other: UObject): ProceduralFoliageVolume;
}

declare class ProceduralFoliageBlockingVolume extends Volume { 
	ProceduralFoliageVolume: ProceduralFoliageVolume;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ProceduralFoliageBlockingVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageBlockingVolume;
	static C(Other: UObject): ProceduralFoliageBlockingVolume;
}

declare class ProceduralFoliageInstance { 
	Location: Vector;
	Rotation: Quat;
	Normal: Vector;
	Age: number;
	Scale: number;
	Type: FoliageType_InstancedStaticMesh;
}

declare class ProceduralFoliageTile extends UObject { 
	FoliageSpawner: ProceduralFoliageSpawner;
	InstancesArray: ProceduralFoliageInstance[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ProceduralFoliageTile;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ProceduralFoliageTile;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageTile;
	static C(Other: UObject): ProceduralFoliageTile;
}

declare class ControlPointMeshComponent extends StaticMeshComponent { 
	bSelected: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ControlPointMeshComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ControlPointMeshComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlPointMeshComponent;
	static C(Other: UObject): ControlPointMeshComponent;
}

declare class GrassVariety { 
	GrassMesh: StaticMesh;
	GrassDensity: number;
	bUseGrid: boolean;
	PlacementJitter: number;
	StartCullDistance: number;
	EndCullDistance: number;
	MinLOD: number;
	RandomRotation: boolean;
	AlignToSurface: boolean;
}

declare class LandscapeGrassType extends UObject { 
	GrassVarieties: GrassVariety[];
	GrassMesh: StaticMesh;
	GrassDensity: number;
	PlacementJitter: number;
	StartCullDistance: number;
	EndCullDistance: number;
	RandomRotation: boolean;
	AlignToSurface: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LandscapeGrassType;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LandscapeGrassType;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeGrassType;
	static C(Other: UObject): LandscapeGrassType;
}

declare class LandscapeLayerInfoObject extends UObject { 
	LayerName: string;
	PhysMaterial: PhysicalMaterial;
	Hardness: number;
	bNoWeightBlend: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LandscapeLayerInfoObject;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LandscapeLayerInfoObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeLayerInfoObject;
	static C(Other: UObject): LandscapeLayerInfoObject;
}

declare class WeightmapLayerAllocationInfo { 
	LayerInfo: LandscapeLayerInfoObject;
	WeightmapTextureIndex: number;
	WeightmapTextureChannel: number;
	GrassMapChannelIndex: number;
}

declare class LandscapeComponent extends PrimitiveComponent { 
	SectionBaseX: number;
	SectionBaseY: number;
	ComponentSizeQuads: number;
	SubsectionSizeQuads: number;
	NumSubsections: number;
	OverrideMaterial: MaterialInterface;
	OverrideHoleMaterial: MaterialInterface;
	MaterialInstance: MaterialInstanceConstant;
	WeightmapLayerAllocations: WeightmapLayerAllocationInfo[];
	WeightmapTextures: Texture2D[];
	XYOffsetmapTexture: Texture2D;
	WeightmapScaleBias: Vector4;
	WeightmapSubsectionOffset: number;
	HeightmapScaleBias: Vector4;
	HeightmapTexture: Texture2D;
	CachedLocalBox: Box;
	CollisionComponent: any;
	LightingGuid: Guid;
	IrrelevantLights: Guid[];
	CollisionMipLevel: number;
	StaticLightingResolution: number;
	ForcedLOD: number;
	LODBias: number;
	StateId: Guid;
	BakedTextureMaterialGuid: Guid;
	GIBakedBaseColorTexture: Texture2D;
	LightingLODBias: number;
	SelectDataTexture: Texture2D;
	MobileDataSourceHash: Guid;
	MobileBlendableLayerMask: number;
	MobileMaterialInterface: MaterialInterface;
	MobileWeightNormalmapTexture: Texture2D;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LandscapeComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LandscapeComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeComponent;
	static C(Other: UObject): LandscapeComponent;
}

declare class LandscapeSplineSegmentConnection { 
	ControlPoint: LandscapeSplineControlPoint;
	TangentLen: number;
	SocketName: string;
}

declare type LandscapeSplineMeshOrientation = string;
declare type ESplineMeshAxis = string;
declare class LandscapeSplineMeshEntry { 
	Mesh: StaticMesh;
	MaterialOverrides: MaterialInterface[];
	bCenterH: boolean;
	CenterAdjust: Vector2D;
	bScaleToWidth: boolean;
	Scale: Vector;
	Orientation: LandscapeSplineMeshOrientation;
	ForwardAxis: ESplineMeshAxis;
	UpAxis: ESplineMeshAxis;
}

declare class LandscapeSplineInterpPoint { 
	Center: Vector;
	Left: Vector;
	Right: Vector;
	FalloffLeft: Vector;
	FalloffRight: Vector;
	StartEndFalloff: number;
}

declare class SplineMeshParams { 
	StartPos: Vector;
	StartTangent: Vector;
	StartScale: Vector2D;
	StartRoll: number;
	StartOffset: Vector2D;
	EndPos: Vector;
	EndTangent: Vector;
	EndScale: Vector2D;
	EndRoll: number;
	EndOffset: Vector2D;
}

declare class SplineMeshComponent extends StaticMeshComponent { 
	SplineParams: SplineMeshParams;
	SplineUpDir: Vector;
	bAllowSplineEditingPerInstance: boolean;
	bSmoothInterpRollScale: boolean;
	ForwardAxis: ESplineMeshAxis;
	SplineBoundaryMin: number;
	SplineBoundaryMax: number;
	BodySetup: BodySetup;
	CachedMeshBodySetupGuid: Guid;
	bSelected: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SplineMeshComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SplineMeshComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineMeshComponent;
	static C(Other: UObject): SplineMeshComponent;
	SetStartTangent(StartTangent: Vector): void;
	SetStartScale(StartScale: Vector2D): void;
	SetStartRoll(StartRoll: number): void;
	SetStartPosition(StartPos: Vector): void;
	SetStartOffset(StartOffset: Vector2D): void;
	SetStartAndEnd(StartPos: Vector,StartTangent: Vector,EndPos: Vector,EndTangent: Vector): void;
	SetSplineUpDir(InSplineUpDir: Vector): void;
	SetForwardAxis(InForwardAxis: ESplineMeshAxis): void;
	SetEndTangent(EndTangent: Vector): void;
	SetEndScale(EndScale: Vector2D): void;
	SetEndRoll(EndRoll: number): void;
	SetEndPosition(EndPos: Vector): void;
	SetEndOffset(EndOffset: Vector2D): void;
	SetBoundaryMin(InBoundaryMin: number): void;
	SetBoundaryMax(InBoundaryMax: number): void;
	GetStartTangent(): Vector;
	GetStartScale(): Vector2D;
	GetStartRoll(): number;
	GetStartPosition(): Vector;
	GetStartOffset(): Vector2D;
	GetSplineUpDir(): Vector;
	GetForwardAxis(): ESplineMeshAxis;
	GetEndTangent(): Vector;
	GetEndScale(): Vector2D;
	GetEndRoll(): number;
	GetEndPosition(): Vector;
	GetEndOffset(): Vector2D;
	GetBoundaryMin(): number;
	GetBoundaryMax(): number;
}

declare class LandscapeSplineSegment extends UObject { 
	Connections: LandscapeSplineSegmentConnection;
	LayerName: string;
	bRaiseTerrain: boolean;
	bLowerTerrain: boolean;
	SplineMeshes: LandscapeSplineMeshEntry[];
	bEnableCollision: boolean;
	bCastShadow: boolean;
	RandomSeed: number;
	LDMaxDrawDistance: number;
	TranslucencySortPriority: number;
	bPlaceSplineMeshesInStreamingLevels: boolean;
	bSelected: boolean;
	bNavDirty: boolean;
	SplineInfo: InterpCurveVector;
	Points: LandscapeSplineInterpPoint[];
	Bounds: Box;
	LocalMeshComponents: SplineMeshComponent[];
	ForeignWorlds: any[];
	ModificationKey: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LandscapeSplineSegment;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LandscapeSplineSegment;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeSplineSegment;
	static C(Other: UObject): LandscapeSplineSegment;
}

declare class LandscapeSplineConnection { 
	Segment: LandscapeSplineSegment;
	End: boolean;
}

declare class LandscapeSplineControlPoint extends UObject { 
	Location: Vector;
	Rotation: Rotator;
	Width: number;
	SideFalloff: number;
	EndFalloff: number;
	SegmentMeshOffset: number;
	LayerName: string;
	bRaiseTerrain: boolean;
	bLowerTerrain: boolean;
	Mesh: StaticMesh;
	MaterialOverrides: MaterialInterface[];
	MeshScale: Vector;
	bEnableCollision: boolean;
	bCastShadow: boolean;
	LDMaxDrawDistance: number;
	TranslucencySortPriority: number;
	bPlaceSplineMeshesInStreamingLevels: boolean;
	bSelected: boolean;
	bNavDirty: boolean;
	ConnectedSegments: LandscapeSplineConnection[];
	Points: LandscapeSplineInterpPoint[];
	Bounds: Box;
	LocalMeshComponent: ControlPointMeshComponent;
	ForeignWorld: any;
	ModificationKey: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LandscapeSplineControlPoint;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LandscapeSplineControlPoint;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeSplineControlPoint;
	static C(Other: UObject): LandscapeSplineControlPoint;
}

declare class LandscapeSplinesComponent extends PrimitiveComponent { 
	SplineResolution: number;
	SplineColor: Color;
	ControlPointSprite: Texture2D;
	SplineEditorMesh: StaticMesh;
	bShowSplineEditorMesh: boolean;
	ControlPoints: LandscapeSplineControlPoint[];
	Segments: LandscapeSplineSegment[];
	ForeignWorldSplineDataMap: any;
	CookedForeignMeshComponents: MeshComponent[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LandscapeSplinesComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LandscapeSplinesComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeSplinesComponent;
	static C(Other: UObject): LandscapeSplinesComponent;
}

declare class LandscapeHeightfieldCollisionComponent extends PrimitiveComponent { 
	ComponentLayerInfos: LandscapeLayerInfoObject[];
	SectionBaseX: number;
	SectionBaseY: number;
	CollisionSizeQuads: number;
	CollisionScale: number;
	CollisionQuadFlags: number[];
	HeightfieldGuid: Guid;
	CachedLocalBox: Box;
	RenderComponent: any;
	CookedPhysicalMaterials: PhysicalMaterial[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LandscapeHeightfieldCollisionComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LandscapeHeightfieldCollisionComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeHeightfieldCollisionComponent;
	static C(Other: UObject): LandscapeHeightfieldCollisionComponent;
}

declare class LandscapeEditorLayerSettings { 
	LayerInfoObj: LandscapeLayerInfoObject;
	ReimportLayerFilePath: string;
}

declare type ELandscapeLODFalloff = string;
declare class InterpCurvePointQuat { 
	InVal: number;
	OutVal: Quat;
	ArriveTangent: Quat;
	LeaveTangent: Quat;
	InterpMode: EInterpCurveMode;
}

declare class InterpCurveQuat { 
	Points: InterpCurvePointQuat[];
	bIsLooped: boolean;
	LoopKeyOffset: number;
}

declare class InterpCurvePointFloat { 
	InVal: number;
	OutVal: number;
	ArriveTangent: number;
	LeaveTangent: number;
	InterpMode: EInterpCurveMode;
}

declare class InterpCurveFloat { 
	Points: InterpCurvePointFloat[];
	bIsLooped: boolean;
	LoopKeyOffset: number;
}

declare type ESplineCoordinateSpace = string;
declare type ESplinePointType = string;
declare class SplineComponent extends PrimitiveComponent { 
	SplineInfo: InterpCurveVector;
	SplineRotInfo: InterpCurveQuat;
	SplineScaleInfo: InterpCurveVector;
	SplineReparamTable: InterpCurveFloat;
	bAllowSplineEditingPerInstance: boolean;
	ReparamStepsPerSegment: number;
	Duration: number;
	bStationaryEndpoints: boolean;
	bSplineHasBeenEdited: boolean;
	bClosedLoop: boolean;
	DefaultUpVector: Vector;
	EditorUnselectedSplineSegmentColor: LinearColor;
	EditorSelectedSplineSegmentColor: LinearColor;
	bShouldVisualizeScale: boolean;
	ScaleVisualizationWidth: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SplineComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SplineComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineComponent;
	static C(Other: UObject): SplineComponent;
	SetWorldLocationAtSplinePoint(PointIndex: number,InLocation: Vector): void;
	SetUnselectedSplineSegmentColor(SegmentColor: LinearColor): void;
	SetTangentAtSplinePoint(PointIndex: number,InTangent: Vector,CoordinateSpace: ESplineCoordinateSpace): void;
	SetSplineWorldPoints(Points: Vector[]): void;
	SetSplinePointType(PointIndex: number,Type: ESplinePointType): void;
	SetSplinePoints(Points: Vector[],CoordinateSpace: ESplineCoordinateSpace): void;
	SetSplineLocalPoints(Points: Vector[]): void;
	SetSelectedSplineSegmentColor(SegmentColor: LinearColor): void;
	SetLocationAtSplinePoint(PointIndex: number,InLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): void;
	SetDefaultUpVector(UpVector: Vector,CoordinateSpace: ESplineCoordinateSpace): void;
	SetClosedLoop(bInClosedLoop: boolean): void;
	IsClosedLoop(): boolean;
	GetWorldTangentAtDistanceAlongSpline(Distance: number): Vector;
	GetWorldRotationAtTime(Time: number,bUseConstantVelocity: boolean): Rotator;
	GetWorldRotationAtDistanceAlongSpline(Distance: number): Rotator;
	GetWorldLocationAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetWorldLocationAtSplinePoint(PointIndex: number): Vector;
	GetWorldLocationAtDistanceAlongSpline(Distance: number): Vector;
	GetWorldDirectionAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetWorldDirectionAtDistanceAlongSpline(Distance: number): Vector;
	GetUpVectorAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetUpVectorAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetUpVectorAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetTransformAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean,bUseScale: boolean): Transform;
	GetTransformAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	GetTransformAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	GetTangentAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetTangentAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetTangentAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetSplinePointType(PointIndex: number): ESplinePointType;
	GetSplineLength(): number;
	GetScaleAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetScaleAtSplinePoint(PointIndex: number): Vector;
	GetScaleAtDistanceAlongSpline(Distance: number): Vector;
	GetRotationAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Rotator;
	GetRotationAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	GetRotationAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	GetRollAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): number;
	GetRollAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): number;
	GetRollAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): number;
	GetRightVectorAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetRightVectorAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetRightVectorAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetQuaternionAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Quat;
	GetQuaternionAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Quat;
	GetQuaternionAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Quat;
	GetNumberOfSplinePoints(): number;
	GetLocationAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetLocationAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetLocationAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetLocationAndTangentAtSplinePoint(PointIndex: number,Location?: Vector,Tangent?: Vector,CoordinateSpace?: ESplineCoordinateSpace): {Location: Vector, Tangent: Vector};
	GetLocalLocationAndTangentAtSplinePoint(PointIndex: number,LocalLocation?: Vector,LocalTangent?: Vector): {LocalLocation: Vector, LocalTangent: Vector};
	GetInputKeyAtDistanceAlongSpline(Distance: number): number;
	GetDistanceAlongSplineAtSplinePoint(PointIndex: number): number;
	GetDirectionAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetDirectionAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetDirectionAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetDefaultUpVector(CoordinateSpace: ESplineCoordinateSpace): Vector;
	ClearSplinePoints(): void;
	AddSplineWorldPoint(Position: Vector): void;
	AddSplinePoint(Position: Vector,CoordinateSpace: ESplineCoordinateSpace): void;
	AddSplineLocalPoint(Position: Vector): void;
}

declare class LandscapeProxy extends Actor { 
	SplineComponent: LandscapeSplinesComponent;
	LandscapeGuid: Guid;
	LandscapeSectionOffset: IntPoint;
	bStaticSectionOffset: boolean;
	MaxLODLevel: number;
	ExportLOD: number;
	StaticLightingLOD: number;
	DefaultPhysMaterial: PhysicalMaterial;
	StreamingDistanceMultiplier: number;
	LandscapeMaterial: MaterialInterface;
	LandscapeHoleMaterial: MaterialInterface;
	LODDistanceFactor: number;
	LandscapeComponents: LandscapeComponent[];
	CollisionComponents: LandscapeHeightfieldCollisionComponent[];
	FoliageComponents: HierarchicalInstancedStaticMeshComponent[];
	StaticLightingResolution: number;
	LandscapeActor: any;
	bCastStaticShadow: boolean;
	bCastShadowAsTwoSided: boolean;
	bCastFarShadow: boolean;
	bIsProxy: boolean;
	bIsMovingToLevel: boolean;
	LightmassSettings: LightmassPrimitiveSettings;
	CollisionMipLevel: number;
	CollisionThickness: number;
	BodyInstance: BodyInstance;
	EditorCachedLayerInfos: LandscapeLayerInfoObject[];
	ReimportHeightmapFilePath: string;
	EditorLayerSettings: LandscapeEditorLayerSettings[];
	ComponentSizeQuads: number;
	SubsectionSizeQuads: number;
	NumSubsections: number;
	bUsedForNavigation: boolean;
	NavigationGeometryGatheringMode: ENavDataGatheringMode;
	LODFalloff: ELandscapeLODFalloff;
	MaxPaintedLayersPerComponent: number;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LandscapeProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeProxy;
	static C(Other: UObject): LandscapeProxy;
	EditorApplySpline(InSplineComponent: SplineComponent,StartWidth: number,EndWidth: number,StartSideFalloff: number,EndSideFalloff: number,StartRoll: number,EndRoll: number,NumSubdivisions: number,bRaiseHeights: boolean,bLowerHeights: boolean,PaintLayer: LandscapeLayerInfoObject): void;
	ChangeLODDistanceFactor(InLODDistanceFactor: number): void;
}

declare class LandscapeInfoLayerSettings { 
	LayerInfoObj: LandscapeLayerInfoObject;
	LayerName: string;
	ThumbnailMIC: MaterialInstanceConstant;
	Owner: LandscapeProxy;
	DebugColorChannel: number;
	bValid: boolean;
}

declare type ELandscapeLayerPaintingRestriction = string;
declare class LandscapeInfo extends UObject { 
	LandscapeActor: any;
	LandscapeGuid: Guid;
	ComponentSizeQuads: number;
	SubsectionSizeQuads: number;
	ComponentNumSubsections: number;
	DrawScale: Vector;
	bIsValid: boolean;
	Layers: LandscapeInfoLayerSettings[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LandscapeInfo;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LandscapeInfo;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeInfo;
	static C(Other: UObject): LandscapeInfo;
	GetAlphamapDataToMemory(LayerInfo: LandscapeLayerInfoObject,MinX: number,MinY: number,MaxX: number,MaxY: number): void;
	GetHeightmapDataToMemory(MinX: number,MinY: number,MaxX: number,MaxY: number): void;
	GetLandscapeExtent(MinX?: number,MinY?: number,MaxX?: number,MaxY?: number): {MinX: number, MinY: number, MaxX: number, MaxY: number, $: boolean};
	GetLayerInfoByName(LayerName: string,Owner: LandscapeProxy): LandscapeLayerInfoObject;
	SetAlphamapDataFromMemory(LayerInfo: LandscapeLayerInfoObject,MinX: number,MinY: number,MaxX: number,MaxY: number,PaintingRestriction: ELandscapeLayerPaintingRestriction): void;
	SetHeightmapDataFromMemory(MinX: number,MinY: number,MaxX: number,MaxY: number): void;
}

declare class LandscapeGizmoActor extends Actor { 
	Width: number;
	Height: number;
	LengthZ: number;
	MarginZ: number;
	MinRelativeZ: number;
	RelativeScaleZ: number;
	TargetLandscapeInfo: LandscapeInfo;
	SpriteComponent: BillboardComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LandscapeGizmoActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeGizmoActor;
	static C(Other: UObject): LandscapeGizmoActor;
}

declare type ELandscapeGizmoType = string;
declare class LandscapeGizmoActiveActor extends LandscapeGizmoActor { 
	DataType: ELandscapeGizmoType;
	GizmoTexture: Texture2D;
	TextureScale: Vector2D;
	SampledHeight: Vector[];
	SampledNormal: Vector[];
	SampleSizeX: number;
	SampleSizeY: number;
	CachedWidth: number;
	CachedHeight: number;
	CachedScaleXY: number;
	FrustumVerts: Vector;
	GizmoMaterial: Material;
	GizmoDataMaterial: MaterialInstance;
	GizmoMeshMaterial: Material;
	LayerInfos: LandscapeLayerInfoObject[];
	bSnapToLandscapeGrid: boolean;
	UnsnappedRotation: Rotator;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LandscapeGizmoActiveActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeGizmoActiveActor;
	static C(Other: UObject): LandscapeGizmoActiveActor;
}

declare class LandscapeGizmoRenderComponent extends PrimitiveComponent { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LandscapeGizmoRenderComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LandscapeGizmoRenderComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeGizmoRenderComponent;
	static C(Other: UObject): LandscapeGizmoRenderComponent;
}

declare class LandscapeMeshCollisionComponent extends LandscapeHeightfieldCollisionComponent { 
	MeshGuid: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LandscapeMeshCollisionComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LandscapeMeshCollisionComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeMeshCollisionComponent;
	static C(Other: UObject): LandscapeMeshCollisionComponent;
}

declare class LandscapeInfoMap extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LandscapeInfoMap;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LandscapeInfoMap;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeInfoMap;
	static C(Other: UObject): LandscapeInfoMap;
}

declare class LandscapeMaterialInstanceConstant extends MaterialInstanceConstant { 
	bIsLayerThumbnail: boolean;
	DataWeightmapIndex: number;
	DataWeightmapSize: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LandscapeMaterialInstanceConstant;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LandscapeMaterialInstanceConstant;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeMaterialInstanceConstant;
	static C(Other: UObject): LandscapeMaterialInstanceConstant;
}

declare class LandscapeMeshProxyComponent extends StaticMeshComponent { 
	LandscapeGuid: Guid;
	ProxyComponentBases: IntPoint[];
	ProxyLOD: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LandscapeMeshProxyComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LandscapeMeshProxyComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeMeshProxyComponent;
	static C(Other: UObject): LandscapeMeshProxyComponent;
}

declare class LandscapeMeshProxyActor extends Actor { 
	LandscapeMeshProxyComponent: LandscapeMeshProxyComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LandscapeMeshProxyActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeMeshProxyActor;
	static C(Other: UObject): LandscapeMeshProxyActor;
}

declare class Landscape extends LandscapeProxy { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Landscape;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Landscape;
	static C(Other: UObject): Landscape;
	GetLandscapeInfo(bSpawnNewActor: boolean): LandscapeInfo;
}

declare class MaterialExpressionCustomOutput extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionCustomOutput;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionCustomOutput;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionCustomOutput;
	static C(Other: UObject): MaterialExpressionCustomOutput;
}

declare class GrassInput { 
	Name: string;
	GrassType: LandscapeGrassType;
	Input: ExpressionInput;
}

declare class MaterialExpressionLandscapeGrassOutput extends MaterialExpressionCustomOutput { 
	GrassTypes: GrassInput[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionLandscapeGrassOutput;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionLandscapeGrassOutput;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionLandscapeGrassOutput;
	static C(Other: UObject): MaterialExpressionLandscapeGrassOutput;
}

declare type ELandscapeLayerBlendType = string;
declare class LayerBlendInput { 
	LayerName: string;
	BlendType: ELandscapeLayerBlendType;
	LayerInput: ExpressionInput;
	HeightInput: ExpressionInput;
	PreviewWeight: number;
	ConstLayerInput: Vector;
	ConstHeightInput: number;
}

declare class MaterialExpressionLandscapeLayerBlend extends MaterialExpression { 
	Layers: LayerBlendInput[];
	ExpressionGUID: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionLandscapeLayerBlend;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionLandscapeLayerBlend;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionLandscapeLayerBlend;
	static C(Other: UObject): MaterialExpressionLandscapeLayerBlend;
}

declare type ETerrainCoordMappingType = string;
declare type ELandscapeCustomizedCoordType = string;
declare class MaterialExpressionLandscapeLayerCoords extends MaterialExpression { 
	MappingType: ETerrainCoordMappingType;
	CustomUVType: ELandscapeCustomizedCoordType;
	MappingScale: number;
	MappingRotation: number;
	MappingPanU: number;
	MappingPanV: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionLandscapeLayerCoords;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionLandscapeLayerCoords;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionLandscapeLayerCoords;
	static C(Other: UObject): MaterialExpressionLandscapeLayerCoords;
}

declare class MaterialExpressionLandscapeLayerSample extends MaterialExpression { 
	ParameterName: string;
	PreviewWeight: number;
	ExpressionGUID: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionLandscapeLayerSample;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionLandscapeLayerSample;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionLandscapeLayerSample;
	static C(Other: UObject): MaterialExpressionLandscapeLayerSample;
}

declare class MaterialExpressionLandscapeLayerSwitch extends MaterialExpression { 
	LayerUsed: ExpressionInput;
	LayerNotUsed: ExpressionInput;
	ParameterName: string;
	PreviewUsed: boolean;
	ExpressionGUID: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionLandscapeLayerSwitch;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionLandscapeLayerSwitch;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionLandscapeLayerSwitch;
	static C(Other: UObject): MaterialExpressionLandscapeLayerSwitch;
}

declare class MaterialExpressionLandscapeLayerWeight extends MaterialExpression { 
	Base: ExpressionInput;
	Layer: ExpressionInput;
	ParameterName: string;
	PreviewWeight: number;
	ConstBase: Vector;
	ExpressionGUID: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionLandscapeLayerWeight;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionLandscapeLayerWeight;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionLandscapeLayerWeight;
	static C(Other: UObject): MaterialExpressionLandscapeLayerWeight;
}

declare class MaterialExpressionLandscapeVisibilityMask extends MaterialExpression { 
	ExpressionGUID: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionLandscapeVisibilityMask;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionLandscapeVisibilityMask;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionLandscapeVisibilityMask;
	static C(Other: UObject): MaterialExpressionLandscapeVisibilityMask;
}

declare class EngineBaseTypes extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EngineBaseTypes;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EngineBaseTypes;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EngineBaseTypes;
	static C(Other: UObject): EngineBaseTypes;
}

declare class EngineTypes extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EngineTypes;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EngineTypes;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EngineTypes;
	static C(Other: UObject): EngineTypes;
}

declare class Interface_AssetUserData extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Interface_AssetUserData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Interface_AssetUserData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Interface_AssetUserData;
	static C(Other: UObject): Interface_AssetUserData;
}

declare class AmbientSound extends Actor { 
	AudioComponent: AudioComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AmbientSound;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AmbientSound;
	static C(Other: UObject): AmbientSound;
	Stop(): void;
	Play(StartTime: number): void;
	FadeOut(FadeOutDuration: number,FadeVolumeLevel: number): void;
	FadeIn(FadeInDuration: number,FadeVolumeLevel: number): void;
	AdjustVolume(AdjustVolumeDuration: number,AdjustVolumeLevel: number): void;
}

declare class PendingNetGame extends UObject { 
	NetDriver: NetDriver;
	DemoNetDriver: DemoNetDriver;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PendingNetGame;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PendingNetGame;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PendingNetGame;
	static C(Other: UObject): PendingNetGame;
}

declare class BrushShape extends Brush { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BrushShape;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushShape;
	static C(Other: UObject): BrushShape;
}

declare class AudioVolume extends Volume { 
	Priority: number;
	bEnabled: boolean;
	Settings: ReverbSettings;
	AmbientZoneSettings: InteriorSettings;
	NextLowerPriorityVolume: AudioVolume;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AudioVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioVolume;
	static C(Other: UObject): AudioVolume;
}

declare class BlockingVolume extends Volume { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlockingVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlockingVolume;
	static C(Other: UObject): BlockingVolume;
}

declare class CameraBlockingVolume extends Volume { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CameraBlockingVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraBlockingVolume;
	static C(Other: UObject): CameraBlockingVolume;
}

declare class CullDistanceSizePair { 
	Size: number;
	CullDistance: number;
}

declare class CullDistanceVolume extends Volume { 
	CullDistances: CullDistanceSizePair[];
	bEnabled: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CullDistanceVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CullDistanceVolume;
	static C(Other: UObject): CullDistanceVolume;
}

declare class LightmassCharacterIndirectDetailVolume extends Volume { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LightmassCharacterIndirectDetailVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightmassCharacterIndirectDetailVolume;
	static C(Other: UObject): LightmassCharacterIndirectDetailVolume;
}

declare class LightmassImportanceVolume extends Volume { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LightmassImportanceVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightmassImportanceVolume;
	static C(Other: UObject): LightmassImportanceVolume;
}

declare class NavigationTypes extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavigationTypes;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavigationTypes;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationTypes;
	static C(Other: UObject): NavigationTypes;
}

declare class NavRelevantInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavRelevantInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavRelevantInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavRelevantInterface;
	static C(Other: UObject): NavRelevantInterface;
}

declare class NavModifierVolume extends Volume { 
	AreaClass: UnrealEngineClass;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavModifierVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavModifierVolume;
	static C(Other: UObject): NavModifierVolume;
	SetAreaClass(NewAreaClass: UnrealEngineClass): void;
}

declare class KillZVolume extends PhysicsVolume { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): KillZVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KillZVolume;
	static C(Other: UObject): KillZVolume;
}

declare class PainCausingVolume extends PhysicsVolume { 
	bPainCausing: boolean;
	DamagePerSec: number;
	DamageType: UnrealEngineClass;
	PainInterval: number;
	bEntryPain: boolean;
	BACKUP_bPainCausing: boolean;
	DamageInstigator: Controller;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PainCausingVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PainCausingVolume;
	static C(Other: UObject): PainCausingVolume;
}

declare class BlendableInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlendableInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlendableInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlendableInterface;
	static C(Other: UObject): BlendableInterface;
}

declare class Scene extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Scene;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Scene;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Scene;
	static C(Other: UObject): Scene;
}

declare class Interface_PostProcessVolume extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Interface_PostProcessVolume;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Interface_PostProcessVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Interface_PostProcessVolume;
	static C(Other: UObject): Interface_PostProcessVolume;
}

declare class PostProcessVolume extends Volume { 
	Settings: PostProcessSettings;
	Priority: number;
	BlendRadius: number;
	BlendWeight: number;
	bEnabled: boolean;
	bUnbound: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PostProcessVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PostProcessVolume;
	static C(Other: UObject): PostProcessVolume;
}

declare class PrecomputedVisibilityOverrideVolume extends Volume { 
	OverrideVisibleActors: Actor[];
	OverrideInvisibleActors: Actor[];
	OverrideInvisibleLevels: string[];
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PrecomputedVisibilityOverrideVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrecomputedVisibilityOverrideVolume;
	static C(Other: UObject): PrecomputedVisibilityOverrideVolume;
}

declare class PrecomputedVisibilityVolume extends Volume { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PrecomputedVisibilityVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrecomputedVisibilityVolume;
	static C(Other: UObject): PrecomputedVisibilityVolume;
}

declare class TriggerVolume extends Volume { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TriggerVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TriggerVolume;
	static C(Other: UObject): TriggerVolume;
}

declare class NavAgentInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavAgentInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavAgentInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavAgentInterface;
	static C(Other: UObject): NavAgentInterface;
}

declare class LogVisualizerCameraController extends DebugCameraController { 
	PickedActor: Actor;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LogVisualizerCameraController;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LogVisualizerCameraController;
	static C(Other: UObject): LogVisualizerCameraController;
}

declare class BoxComponent extends ShapeComponent { 
	BoxExtent: Vector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BoxComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BoxComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoxComponent;
	static C(Other: UObject): BoxComponent;
	SetBoxExtent(InBoxExtent: Vector,bUpdateOverlaps: boolean): void;
	GetUnscaledBoxExtent(): Vector;
	GetScaledBoxExtent(): Vector;
}

declare class DecalActor extends Actor { 
	Decal: DecalComponent;
	ArrowComponent: ArrowComponent;
	SpriteComponent: BillboardComponent;
	BoxComponent: BoxComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DecalActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DecalActor;
	static C(Other: UObject): DecalActor;
	SetDecalMaterial(NewDecalMaterial: MaterialInterface): void;
	GetDecalMaterial(): MaterialInterface;
	CreateDynamicMaterialInstance(): MaterialInstanceDynamic;
}

declare class FractureEffect { 
	ParticleSystem: ParticleSystem;
	Sound: SoundBase;
}

declare class DestructibleDamageParameters { 
	DamageThreshold: number;
	DamageSpread: number;
	bEnableImpactDamage: boolean;
	ImpactDamage: number;
	DefaultImpactDamageDepth: number;
	bCustomImpactResistance: boolean;
	ImpactResistance: number;
}

declare class DestructibleDebrisParameters { 
	DebrisLifetimeMin: number;
	DebrisLifetimeMax: number;
	DebrisMaxSeparationMin: number;
	DebrisMaxSeparationMax: number;
	ValidBounds: Box;
}

declare class DestructibleAdvancedParameters { 
	DamageCap: number;
	ImpactVelocityThreshold: number;
	MaxChunkSpeed: number;
	FractureImpulseScale: number;
}

declare class DestructibleSpecialHierarchyDepths { 
	SupportDepth: number;
	MinimumFractureDepth: number;
	bEnableDebris: boolean;
	DebrisDepth: number;
	EssentialDepth: number;
}

declare type EImpactDamageOverride = string;
declare class DestructibleDepthParameters { 
	ImpactDamageOverride: EImpactDamageOverride;
}

declare class DestructibleParametersFlag { 
	bAccumulateDamage: boolean;
	bAssetDefinedSupport: boolean;
	bWorldSupport: boolean;
	bDebrisTimeout: boolean;
	bDebrisMaxSeparation: boolean;
	bCrumbleSmallestChunks: boolean;
	bAccurateRaycasts: boolean;
	bUseValidBounds: boolean;
	bFormExtendedStructures: boolean;
}

declare class DestructibleParameters { 
	DamageParameters: DestructibleDamageParameters;
	DebrisParameters: DestructibleDebrisParameters;
	AdvancedParameters: DestructibleAdvancedParameters;
	SpecialHierarchyDepths: DestructibleSpecialHierarchyDepths;
	DepthParameters: DestructibleDepthParameters[];
	Flags: DestructibleParametersFlag;
}

declare class FractureMaterial { 
	UVScale: Vector2D;
	UVOffset: Vector2D;
	Tangent: Vector;
	UAngle: number;
	InteriorElementIndex: number;
}

declare class DestructibleChunkParameters { 
	bIsSupportChunk: boolean;
	bDoNotFracture: boolean;
	bDoNotDamage: boolean;
	bDoNotCrumble: boolean;
}

declare class DestructibleFractureSettings extends UObject { 
	CellSiteCount: number;
	FractureMaterialDesc: FractureMaterial;
	RandomSeed: number;
	VoronoiSites: Vector[];
	OriginalSubmeshCount: number;
	Materials: MaterialInterface[];
	ChunkParameters: DestructibleChunkParameters[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DestructibleFractureSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DestructibleFractureSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DestructibleFractureSettings;
	static C(Other: UObject): DestructibleFractureSettings;
}

declare class DateTime { 
}

declare class DestructibleMesh extends SkeletalMesh { 
	DefaultDestructibleParameters: DestructibleParameters;
	FractureEffects: FractureEffect[];
	FractureSettings: DestructibleFractureSettings;
	SourceStaticMesh: StaticMesh;
	SourceSMImportTimestamp: DateTime;
	FractureChunkMeshes: StaticMesh[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DestructibleMesh;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DestructibleMesh;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DestructibleMesh;
	static C(Other: UObject): DestructibleMesh;
}

declare class DestructibleComponent extends SkinnedMeshComponent { 
	bFractureEffectOverride: boolean;
	FractureEffects: FractureEffect[];
	bEnableHardSleeping: boolean;
	LargeChunkThreshold: number;
	DestructibleMesh: DestructibleMesh;
	OnComponentFracture: UnrealEngineMulticastDelegate<(HitPoint: Vector, HitDirection: Vector) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DestructibleComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DestructibleComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DestructibleComponent;
	static C(Other: UObject): DestructibleComponent;
	SetDestructibleMesh(NewMesh: DestructibleMesh): void;
	GetDestructibleMesh(): DestructibleMesh;
	ApplyRadiusDamage(BaseDamage: number,HurtOrigin: Vector,DamageRadius: number,ImpulseStrength: number,bFullDamage: boolean): void;
	ApplyDamage(DamageAmount: number,HitLocation: Vector,ImpulseDir: Vector,ImpulseStrength: number): void;
}

declare class DestructibleActor extends Actor { 
	DestructibleComponent: DestructibleComponent;
	bAffectNavigation: boolean;
	OnActorFracture: UnrealEngineMulticastDelegate<(HitPoint: Vector, HitDirection: Vector) => void>;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DestructibleActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DestructibleActor;
	static C(Other: UObject): DestructibleActor;
}

declare class MaterialSpriteElement { 
	Material: MaterialInterface;
	DistanceToOpacityCurve: CurveFloat;
	bSizeIsInScreenSpace: boolean;
	BaseSizeX: number;
	BaseSizeY: number;
	DistanceToSizeCurve: CurveFloat;
}

declare class MaterialBillboardComponent extends PrimitiveComponent { 
	Elements: MaterialSpriteElement[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialBillboardComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialBillboardComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialBillboardComponent;
	static C(Other: UObject): MaterialBillboardComponent;
	AddElement(Material: MaterialInterface,DistanceToOpacityCurve: CurveFloat,bSizeIsInScreenSpace: boolean,BaseSizeX: number,BaseSizeY: number,DistanceToSizeCurve: CurveFloat): void;
}

declare class DocumentationActor extends Actor { 
	DocumentLink: string;
	Billboard: MaterialBillboardComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DocumentationActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DocumentationActor;
	static C(Other: UObject): DocumentationActor;
}

declare class DebugCameraHUD extends HUD { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DebugCameraHUD;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DebugCameraHUD;
	static C(Other: UObject): DebugCameraHUD;
}

declare class LogVisualizerHUD extends DebugCameraHUD { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LogVisualizerHUD;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LogVisualizerHUD;
	static C(Other: UObject): LogVisualizerHUD;
}

declare class AtmospherePrecomputeParameters { 
	DensityHeight: number;
	DecayHeight: number;
	MaxScatteringOrder: number;
	TransmittanceTexWidth: number;
	TransmittanceTexHeight: number;
	IrradianceTexWidth: number;
	IrradianceTexHeight: number;
	InscatterAltitudeSampleNum: number;
	InscatterMuNum: number;
	InscatterMuSNum: number;
	InscatterNuNum: number;
}

declare class AtmosphericFogComponent extends SceneComponent { 
	SunMultiplier: number;
	FogMultiplier: number;
	DensityMultiplier: number;
	DensityOffset: number;
	DistanceScale: number;
	AltitudeScale: number;
	DistanceOffset: number;
	GroundOffset: number;
	StartDistance: number;
	SunDiscScale: number;
	DefaultBrightness: number;
	DefaultLightColor: Color;
	bDisableSunDisk: boolean;
	bDisableGroundScattering: boolean;
	PrecomputeParams: AtmospherePrecomputeParameters;
	TransmittanceTexture: Texture2D;
	IrradianceTexture: Texture2D;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AtmosphericFogComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AtmosphericFogComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AtmosphericFogComponent;
	static C(Other: UObject): AtmosphericFogComponent;
	StartPrecompute(): void;
	SetSunMultiplier(NewSunMultiplier: number): void;
	SetStartDistance(NewStartDistance: number): void;
	SetPrecomputeParams(DensityHeight: number,MaxScatteringOrder: number,InscatterAltitudeSampleNum: number): void;
	SetFogMultiplier(NewFogMultiplier: number): void;
	SetDistanceScale(NewDistanceScale: number): void;
	SetDistanceOffset(NewDistanceOffset: number): void;
	SetDensityOffset(NewDensityOffset: number): void;
	SetDensityMultiplier(NewDensityMultiplier: number): void;
	SetDefaultLightColor(NewLightColor: LinearColor): void;
	SetDefaultBrightness(NewBrightness: number): void;
	SetAltitudeScale(NewAltitudeScale: number): void;
	DisableSunDisk(NewSunDisk: boolean): void;
	DisableGroundScattering(NewGroundScattering: boolean): void;
}

declare class AtmosphericFog extends Info { 
	AtmosphericFogComponent: AtmosphericFogComponent;
	ArrowComponent: ArrowComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AtmosphericFog;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AtmosphericFog;
	static C(Other: UObject): AtmosphericFog;
}

declare class ExponentialHeightFogComponent extends SceneComponent { 
	FogDensity: number;
	FogInscatteringColor: LinearColor;
	DirectionalInscatteringExponent: number;
	DirectionalInscatteringStartDistance: number;
	DirectionalInscatteringColor: LinearColor;
	FogHeightFalloff: number;
	FogMaxOpacity: number;
	StartDistance: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ExponentialHeightFogComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ExponentialHeightFogComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ExponentialHeightFogComponent;
	static C(Other: UObject): ExponentialHeightFogComponent;
	SetStartDistance(Value: number): void;
	SetFogMaxOpacity(Value: number): void;
	SetFogInscatteringColor(Value: LinearColor): void;
	SetFogHeightFalloff(Value: number): void;
	SetFogDensity(Value: number): void;
	SetDirectionalInscatteringStartDistance(Value: number): void;
	SetDirectionalInscatteringExponent(Value: number): void;
	SetDirectionalInscatteringColor(Value: LinearColor): void;
}

declare class ExponentialHeightFog extends Info { 
	Component: ExponentialHeightFogComponent;
	bEnabled: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ExponentialHeightFog;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ExponentialHeightFog;
	static C(Other: UObject): ExponentialHeightFog;
	OnRep_bEnabled(): void;
}

declare class PlayerStart extends NavigationObjectBase { 
	PlayerStartTag: string;
	ArrowComponent: ArrowComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PlayerStart;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerStart;
	static C(Other: UObject): PlayerStart;
}

declare class LightComponentBase extends SceneComponent { 
	LightGuid: Guid;
	Brightness: number;
	Intensity: number;
	LightColor: Color;
	bAffectsWorld: boolean;
	CastShadows: boolean;
	CastStaticShadows: boolean;
	CastDynamicShadows: boolean;
	bAffectTranslucentLighting: boolean;
	bPrecomputedLightingIsValid: boolean;
	IndirectLightingIntensity: number;
	StaticEditorTexture: Texture2D;
	StaticEditorTextureScale: number;
	DynamicEditorTexture: Texture2D;
	DynamicEditorTextureScale: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LightComponentBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LightComponentBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightComponentBase;
	static C(Other: UObject): LightComponentBase;
	SetCastShadows(bNewValue: boolean): void;
	GetLightColor(): LinearColor;
}

declare type ESkyLightSourceType = string;
declare class SkyLightComponent extends LightComponentBase { 
	SourceType: ESkyLightSourceType;
	Cubemap: TextureCube;
	SkyDistanceThreshold: number;
	bLowerHemisphereIsBlack: boolean;
	OcclusionMaxDistance: number;
	Contrast: number;
	MinOcclusion: number;
	OcclusionTint: Color;
	BlendDestinationCubemap: TextureCube;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SkyLightComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SkyLightComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkyLightComponent;
	static C(Other: UObject): SkyLightComponent;
	SetOcclusionTint(InTint: Color): void;
	SetMinOcclusion(InMinOcclusion: number): void;
	SetLightColor(NewLightColor: LinearColor): void;
	SetIntensity(NewIntensity: number): void;
	SetIndirectLightingIntensity(NewIntensity: number): void;
	SetCubemapBlend(SourceCubemap: TextureCube,DestinationCubemap: TextureCube,InBlendFraction: number): void;
	SetCubemap(NewCubemap: TextureCube): void;
	RecaptureSky(): void;
}

declare class SkyLight extends Info { 
	LightComponent: SkyLightComponent;
	bEnabled: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SkyLight;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkyLight;
	static C(Other: UObject): SkyLight;
	OnRep_bEnabled(): void;
}

declare class WindDirectionalSourceComponent extends SceneComponent { 
	Strength: number;
	Speed: number;
	MinGustAmount: number;
	MaxGustAmount: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WindDirectionalSourceComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WindDirectionalSourceComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WindDirectionalSourceComponent;
	static C(Other: UObject): WindDirectionalSourceComponent;
}

declare class WindDirectionalSource extends Info { 
	Component: WindDirectionalSourceComponent;
	ArrowComponent: ArrowComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WindDirectionalSource;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WindDirectionalSource;
	static C(Other: UObject): WindDirectionalSource;
}

declare class LevelBounds extends Actor { 
	bAutoUpdateBounds: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelBounds;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelBounds;
	static C(Other: UObject): LevelBounds;
}

declare class TextureLightProfile extends Texture2D { 
	Brightness: number;
	TextureMultiplier: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextureLightProfile;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextureLightProfile;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureLightProfile;
	static C(Other: UObject): TextureLightProfile;
}

declare class LightComponent extends LightComponentBase { 
	Temperature: number;
	bUseTemperature: boolean;
	ShadowMapChannel: number;
	SourceRadius: number;
	MinRoughness: number;
	ShadowBias: number;
	ShadowSharpen: number;
	InverseSquaredFalloff: boolean;
	CastTranslucentShadows: boolean;
	bCastShadowsFromCinematicObjectsOnly: boolean;
	bAffectDynamicIndirectLighting: boolean;
	LightFunctionMaterial: MaterialInterface;
	LightFunctionScale: Vector;
	IESTexture: TextureLightProfile;
	bUseIESBrightness: boolean;
	IESBrightnessScale: number;
	LightFunctionFadeDistance: number;
	DisabledBrightness: number;
	bEnableLightShaftBloom: boolean;
	BloomScale: number;
	BloomThreshold: number;
	BloomTint: Color;
	bUseRayTracedDistanceFieldShadows: boolean;
	RayStartOffsetDepthScale: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LightComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LightComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightComponent;
	static C(Other: UObject): LightComponent;
	SetTemperature(NewTemperature: number): void;
	SetLightFunctionScale(NewLightFunctionScale: Vector): void;
	SetLightFunctionMaterial(NewLightFunctionMaterial: MaterialInterface): void;
	SetLightFunctionFadeDistance(NewLightFunctionFadeDistance: number): void;
	SetLightFunctionDisabledBrightness(NewValue: number): void;
	SetLightColor(NewLightColor: LinearColor,bSRGB: boolean): void;
	SetIntensity(NewIntensity: number): void;
	SetIndirectLightingIntensity(NewIntensity: number): void;
	SetIESTexture(NewValue: TextureLightProfile): void;
	SetEnableLightShaftBloom(bNewValue: boolean): void;
	SetBloomTint(NewValue: Color): void;
	SetBloomThreshold(NewValue: number): void;
	SetBloomScale(NewValue: number): void;
	SetAffectTranslucentLighting(bNewValue: boolean): void;
	SetAffectDynamicIndirectLighting(bNewValue: boolean): void;
}

declare class Light extends Actor { 
	LightComponent: LightComponent;
	bEnabled: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Light;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Light;
	static C(Other: UObject): Light;
	ToggleEnabled(): void;
	SetLightFunctionScale(NewLightFunctionScale: Vector): void;
	SetLightFunctionMaterial(NewLightFunctionMaterial: MaterialInterface): void;
	SetLightFunctionFadeDistance(NewLightFunctionFadeDistance: number): void;
	SetLightColor(NewLightColor: LinearColor): void;
	SetEnabled(bSetEnabled: boolean): void;
	SetCastShadows(bNewValue: boolean): void;
	SetBrightness(NewBrightness: number): void;
	SetAffectTranslucentLighting(bNewValue: boolean): void;
	OnRep_bEnabled(): void;
	IsEnabled(): boolean;
	GetLightColor(): LinearColor;
	GetBrightness(): number;
}

declare class DirectionalLight extends Light { 
	ArrowComponent: ArrowComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DirectionalLight;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DirectionalLight;
	static C(Other: UObject): DirectionalLight;
}

declare class LightmassLightSettings { 
	IndirectLightingSaturation: number;
	ShadowExponent: number;
	bUseAreaShadowsForStationaryLight: boolean;
}

declare class LightmassPointLightSettings extends LightmassLightSettings { 
}

declare class PointLightComponent extends LightComponent { 
	Radius: number;
	AttenuationRadius: number;
	bUseInverseSquaredFalloff: boolean;
	LightFalloffExponent: number;
	SourceRadius: number;
	SourceLength: number;
	LightmassSettings: LightmassPointLightSettings;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PointLightComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PointLightComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PointLightComponent;
	static C(Other: UObject): PointLightComponent;
	SetSourceRadius(bNewValue: number): void;
	SetSourceLength(NewValue: number): void;
	SetLightFalloffExponent(NewLightFalloffExponent: number): void;
	SetAttenuationRadius(NewRadius: number): void;
}

declare class PointLight extends Light { 
	PointLightComponent: PointLightComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PointLight;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PointLight;
	static C(Other: UObject): PointLight;
	SetRadius(NewRadius: number): void;
	SetLightFalloffExponent(NewLightFalloffExponent: number): void;
}

declare class SpotLightComponent extends PointLightComponent { 
	InnerConeAngle: number;
	OuterConeAngle: number;
	LightShaftConeAngle: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SpotLightComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SpotLightComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpotLightComponent;
	static C(Other: UObject): SpotLightComponent;
	SetOuterConeAngle(NewOuterConeAngle: number): void;
	SetInnerConeAngle(NewInnerConeAngle: number): void;
}

declare class SpotLight extends Light { 
	SpotLightComponent: SpotLightComponent;
	ArrowComponent: ArrowComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SpotLight;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpotLight;
	static C(Other: UObject): SpotLight;
	SetOuterConeAngle(NewOuterConeAngle: number): void;
	SetInnerConeAngle(NewInnerConeAngle: number): void;
}

declare class GeneratedMeshAreaLight extends SpotLight { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GeneratedMeshAreaLight;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeneratedMeshAreaLight;
	static C(Other: UObject): GeneratedMeshAreaLight;
}

declare class DrawSphereComponent extends SphereComponent { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DrawSphereComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DrawSphereComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DrawSphereComponent;
	static C(Other: UObject): DrawSphereComponent;
}

declare class LODActor extends Actor { 
	StaticMeshComponent: StaticMeshComponent;
	SubActors: Actor[];
	LODDrawDistance: number;
	LODLevel: number;
	SubObjects: UObject[];
	DrawSphereComponent: DrawSphereComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LODActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LODActor;
	static C(Other: UObject): LODActor;
}

declare class MaterialInstanceActor extends Actor { 
	TargetActors: Actor[];
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialInstanceActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstanceActor;
	static C(Other: UObject): MaterialInstanceActor;
}

declare class MatineeActorCameraAnim extends MatineeActor { 
	CameraAnim: CameraAnim;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MatineeActorCameraAnim;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MatineeActorCameraAnim;
	static C(Other: UObject): MatineeActorCameraAnim;
}

declare class AbstractNavData extends NavigationData { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AbstractNavData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbstractNavData;
	static C(Other: UObject): AbstractNavData;
}

declare class NavigationGraph extends NavigationData { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavigationGraph;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationGraph;
	static C(Other: UObject): NavigationGraph;
}

declare type ERecastPartitioning = string;
declare class RecastNavMesh extends NavigationData { 
	bDrawTriangleEdges: boolean;
	bDrawPolyEdges: boolean;
	bDrawFilledPolys: boolean;
	bDrawNavMeshEdges: boolean;
	bDrawTileBounds: boolean;
	bDrawPathCollidingGeometry: boolean;
	bDrawTileLabels: boolean;
	bDrawPolygonLabels: boolean;
	bDrawDefaultPolygonCost: boolean;
	bDrawLabelsOnPathNodes: boolean;
	bDrawNavLinks: boolean;
	bDrawFailedNavLinks: boolean;
	bDrawClusters: boolean;
	bDrawOctree: boolean;
	bDistinctlyDrawTilesBeingBuilt: boolean;
	bDrawNavMesh: boolean;
	DrawOffset: number;
	bFixedTilePoolSize: boolean;
	TilePoolSize: number;
	TileSizeUU: number;
	CellSize: number;
	CellHeight: number;
	AgentRadius: number;
	AgentHeight: number;
	AgentMaxHeight: number;
	AgentMaxSlope: number;
	AgentMaxStepHeight: number;
	MinRegionArea: number;
	MergeRegionSize: number;
	MaxSimplificationError: number;
	MaxSimultaneousTileGenerationJobsCount: number;
	TileNumberHardLimit: number;
	PolyRefTileBits: number;
	PolyRefNavPolyBits: number;
	PolyRefSaltBits: number;
	DefaultDrawDistance: number;
	DefaultMaxSearchNodes: number;
	DefaultMaxHierarchicalSearchNodes: number;
	RegionPartitioning: ERecastPartitioning;
	LayerPartitioning: ERecastPartitioning;
	RegionChunkSplits: number;
	LayerChunkSplits: number;
	bSortNavigationAreasByCost: boolean;
	bPerformVoxelFiltering: boolean;
	bMarkLowHeightAreas: boolean;
	bDoFullyAsyncNavDataGathering: boolean;
	bUseBetterOffsetsFromCorners: boolean;
	bUseVirtualFilters: boolean;
	bUseVoxelCache: boolean;
	TileSetUpdateInterval: number;
	HeuristicScale: number;
	VerticalDeviationFromGroundCompensation: number;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): RecastNavMesh;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RecastNavMesh;
	static C(Other: UObject): RecastNavMesh;
}

declare class NavigationGraphNode extends Actor { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavigationGraphNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationGraphNode;
	static C(Other: UObject): NavigationGraphNode;
}

declare class PlayerStartPIE extends PlayerStart { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PlayerStartPIE;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerStartPIE;
	static C(Other: UObject): PlayerStartPIE;
}

declare class NavPathObserverInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavPathObserverInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavPathObserverInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavPathObserverInterface;
	static C(Other: UObject): NavPathObserverInterface;
}

declare class NavTestRenderingComponent extends PrimitiveComponent { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavTestRenderingComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavTestRenderingComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavTestRenderingComponent;
	static C(Other: UObject): NavTestRenderingComponent;
}

declare class NavigationInvokerComponent extends ActorComponent { 
	TileGenerationRadius: number;
	TileRemovalRadius: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavigationInvokerComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavigationInvokerComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationInvokerComponent;
	static C(Other: UObject): NavigationInvokerComponent;
}

declare type ENavCostDisplay = string;
declare class NavigationTestingActor extends Actor { 
	CapsuleComponent: CapsuleComponent;
	EdRenderComp: NavTestRenderingComponent;
	InvokerComponent: NavigationInvokerComponent;
	bActAsNavigationInvoker: boolean;
	NavAgentProps: NavAgentProperties;
	QueryingExtent: Vector;
	MyNavData: NavigationData;
	ProjectedLocation: Vector;
	bProjectedLocationValid: boolean;
	bSearchStart: boolean;
	bUseHierarchicalPathfinding: boolean;
	bGatherDetailedInfo: boolean;
	bShowNodePool: boolean;
	bShowBestPath: boolean;
	bShowDiffWithPreviousStep: boolean;
	bShouldBeVisibleInGame: boolean;
	CostDisplayMode: ENavCostDisplay;
	TextCanvasOffset: Vector2D;
	bPathExist: boolean;
	bPathIsPartial: boolean;
	bPathSearchOutOfNodes: boolean;
	PathfindingTime: number;
	PathCost: number;
	PathfindingSteps: number;
	OtherActor: NavigationTestingActor;
	FilterClass: UnrealEngineClass;
	ShowStepIndex: number;
	OffsetFromCornersDistance: number;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavigationTestingActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationTestingActor;
	static C(Other: UObject): NavigationTestingActor;
}

declare type ENavLinkDirection = string;
declare class NavigationLinkBase { 
	LeftProjectHeight: number;
	MaxFallDownLength: number;
	Direction: ENavLinkDirection;
	SnapRadius: number;
	SnapHeight: number;
	bUseSnapHeight: boolean;
	bSnapToCheapestArea: boolean;
	AreaClass: UnrealEngineClass;
	SupportedAgents: NavAgentSelector;
	bSupportsAgent0: boolean;
	bSupportsAgent1: boolean;
	bSupportsAgent2: boolean;
	bSupportsAgent3: boolean;
	bSupportsAgent4: boolean;
	bSupportsAgent5: boolean;
	bSupportsAgent6: boolean;
	bSupportsAgent7: boolean;
	bSupportsAgent8: boolean;
	bSupportsAgent9: boolean;
	bSupportsAgent10: boolean;
	bSupportsAgent11: boolean;
	bSupportsAgent12: boolean;
	bSupportsAgent13: boolean;
	bSupportsAgent14: boolean;
	bSupportsAgent15: boolean;
	Description: string;
}

declare class NavigationLink extends NavigationLinkBase { 
	Left: Vector;
	Right: Vector;
}

declare class NavigationSegmentLink extends NavigationLinkBase { 
	LeftStart: Vector;
	LeftEnd: Vector;
	RightStart: Vector;
	RightEnd: Vector;
}

declare class NavLinkDefinition extends UObject { 
	Links: NavigationLink[];
	SegmentLinks: NavigationSegmentLink[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavLinkDefinition;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavLinkDefinition;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkDefinition;
	static C(Other: UObject): NavLinkDefinition;
}

declare class NavLinkHostInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavLinkHostInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavLinkHostInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkHostInterface;
	static C(Other: UObject): NavLinkHostInterface;
}

declare class NavRelevantComponent extends ActorComponent { 
	bNavigationRelevant: boolean;
	bAttachToOwnersRoot: boolean;
	CachedNavParent: UObject;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavRelevantComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavRelevantComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavRelevantComponent;
	static C(Other: UObject): NavRelevantComponent;
	SetNavigationRelevancy(bRelevant: boolean): void;
}

declare class NavLinkCustomComponent extends NavRelevantComponent { 
	NavLinkUserId: any;
	EnabledAreaClass: UnrealEngineClass;
	DisabledAreaClass: UnrealEngineClass;
	LinkRelativeStart: Vector;
	LinkRelativeEnd: Vector;
	LinkDirection: ENavLinkDirection;
	bLinkEnabled: boolean;
	bNotifyWhenEnabled: boolean;
	bNotifyWhenDisabled: boolean;
	bCreateBoxObstacle: boolean;
	ObstacleOffset: Vector;
	ObstacleExtent: Vector;
	ObstacleAreaClass: UnrealEngineClass;
	BroadcastRadius: number;
	BroadcastInterval: number;
	BroadcastChannel: ECollisionChannel;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavLinkCustomComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavLinkCustomComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkCustomComponent;
	static C(Other: UObject): NavLinkCustomComponent;
}

declare class NavLinkRenderingComponent extends PrimitiveComponent { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavLinkRenderingComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavLinkRenderingComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkRenderingComponent;
	static C(Other: UObject): NavLinkRenderingComponent;
}

declare class NavLinkProxy extends Actor { 
	PointLinks: NavigationLink[];
	SegmentLinks: NavigationSegmentLink[];
	SmartLinkComp: NavLinkCustomComponent;
	bSmartLinkIsRelevant: boolean;
	EdRenderComp: NavLinkRenderingComponent;
	SpriteComponent: BillboardComponent;
	OnSmartLinkReached: UnrealEngineMulticastDelegate<(MovingActor: Actor, DestinationPoint: Vector) => void>;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavLinkProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkProxy;
	static C(Other: UObject): NavLinkProxy;
	SetSmartLinkEnabled(bEnabled: boolean): void;
	ResumePathFollowing(Agent: Actor): void;
	ReceiveSmartLinkReached(Agent: Actor,Destination: Vector): void;
	IsSmartLinkEnabled(): boolean;
	HasMovingAgents(): boolean;
}

declare class Note extends Actor { 
	Text: string;
	SpriteComponent: BillboardComponent;
	ArrowComponent: ArrowComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Note;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Note;
	static C(Other: UObject): Note;
}

declare class Interface_CollisionDataProvider extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Interface_CollisionDataProvider;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Interface_CollisionDataProvider;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Interface_CollisionDataProvider;
	static C(Other: UObject): Interface_CollisionDataProvider;
}

declare class WheeledVehicle extends Pawn { 
	Mesh: SkeletalMeshComponent;
	VehicleMovement: WheeledVehicleMovementComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WheeledVehicle;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WheeledVehicle;
	static C(Other: UObject): WheeledVehicle;
}

declare class ReflectionCaptureComponent extends SceneComponent { 
	Brightness: number;
	StateId: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReflectionCaptureComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReflectionCaptureComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReflectionCaptureComponent;
	static C(Other: UObject): ReflectionCaptureComponent;
}

declare class ReflectionCapture extends Actor { 
	CaptureComponent: ReflectionCaptureComponent;
	SpriteComponent: BillboardComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReflectionCapture;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReflectionCapture;
	static C(Other: UObject): ReflectionCapture;
}

declare class BoxReflectionCapture extends ReflectionCapture { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BoxReflectionCapture;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoxReflectionCapture;
	static C(Other: UObject): BoxReflectionCapture;
}

declare class PlaneReflectionCapture extends ReflectionCapture { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PlaneReflectionCapture;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlaneReflectionCapture;
	static C(Other: UObject): PlaneReflectionCapture;
}

declare class SphereReflectionCapture extends ReflectionCapture { 
	DrawCaptureRadius: DrawSphereComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SphereReflectionCapture;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SphereReflectionCapture;
	static C(Other: UObject): SphereReflectionCapture;
}

declare class RigidBodyBase extends Actor { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): RigidBodyBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigidBodyBase;
	static C(Other: UObject): RigidBodyBase;
}

declare class ConstrainComponentPropName { 
	ComponentName: string;
}

declare type EConstraintFrame = string;
declare class PhysicsConstraintComponent extends SceneComponent { 
	ConstraintActor1: Actor;
	ComponentName1: ConstrainComponentPropName;
	ConstraintActor2: Actor;
	ComponentName2: ConstrainComponentPropName;
	ConstraintSetup: PhysicsConstraintTemplate;
	OnConstraintBroken: UnrealEngineMulticastDelegate<(ConstraintIndex: number) => void>;
	ConstraintInstance: ConstraintInstance;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PhysicsConstraintComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PhysicsConstraintComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsConstraintComponent;
	static C(Other: UObject): PhysicsConstraintComponent;
	SetLinearZLimit(ConstraintType: ELinearConstraintMotion,LimitSize: number): void;
	SetLinearYLimit(ConstraintType: ELinearConstraintMotion,LimitSize: number): void;
	SetLinearXLimit(ConstraintType: ELinearConstraintMotion,LimitSize: number): void;
	SetLinearVelocityTarget(InVelTarget: Vector): void;
	SetLinearVelocityDrive(bEnableDriveX: boolean,bEnableDriveY: boolean,bEnableDriveZ: boolean): void;
	SetLinearPositionTarget(InPosTarget: Vector): void;
	SetLinearPositionDrive(bEnableDriveX: boolean,bEnableDriveY: boolean,bEnableDriveZ: boolean): void;
	SetLinearDriveParams(InSpring: number,InDamping: number,InForceLimit: number): void;
	SetDisableCollision(bDisableCollision: boolean): void;
	SetConstraintReferencePosition(Frame: EConstraintFrame,RefPosition: Vector): void;
	SetConstraintReferenceOrientation(Frame: EConstraintFrame,PriAxis: Vector,SecAxis: Vector): void;
	SetConstraintReferenceFrame(Frame: EConstraintFrame,RefFrame: Transform): void;
	SetConstrainedComponents(Component1: PrimitiveComponent,BoneName1: string,Component2: PrimitiveComponent,BoneName2: string): void;
	SetAngularVelocityTarget(InVelTarget: Vector): void;
	SetAngularVelocityDrive(bEnableSwingDrive: boolean,bEnableTwistDrive: boolean): void;
	SetAngularTwistLimit(ConstraintType: EAngularConstraintMotion,TwistLimitAngle: number): void;
	SetAngularSwing2Limit(MotionType: EAngularConstraintMotion,Swing2LimitAngle: number): void;
	SetAngularSwing1Limit(MotionType: EAngularConstraintMotion,Swing1LimitAngle: number): void;
	SetAngularOrientationTarget(InPosTarget: Rotator): void;
	SetAngularOrientationDrive(bEnableSwingDrive: boolean,bEnableTwistDrive: boolean): void;
	SetAngularDriveParams(InSpring: number,InDamping: number,InForceLimit: number): void;
	GetCurrentTwist(): number;
	GetCurrentSwing2(): number;
	GetCurrentSwing1(): number;
	GetConstraintForce(OutLinearForce?: Vector,OutAngularForce?: Vector): {OutLinearForce: Vector, OutAngularForce: Vector};
	BreakConstraint(): void;
}

